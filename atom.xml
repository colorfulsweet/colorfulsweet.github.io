<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silence</title>
  
  <subtitle>世上有条唯一的路，除了你无人能走</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sookie2010.github.io/"/>
  <updated>2018-05-21T00:48:43.758Z</updated>
  <id>https://sookie2010.github.io/</id>
  
  <author>
    <name>柠烟夏季</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>模块化编程(2)</title>
    <link href="https://sookie2010.github.io/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B(2)/"/>
    <id>https://sookie2010.github.io/JavaScript/模块化编程(2)/</id>
    <published>2018-05-06T12:19:42.000Z</published>
    <updated>2018-05-21T00:48:43.758Z</updated>
    
    <content type="html"><![CDATA[<p>模块存在的价值是为了能够更方便地复用代码 , 更加有利于功能的封装<br>但是如果要实现的话 , 就必须要求每个人都按照同样的方式去编写模块<br>目前通行的JavaScript模块规范有两种 , 分别是<code>CommonJS</code>和<code>AMD</code><br><a id="more"></a></p><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>从node.js出现之后 , 将JavaScript用于服务器编程<br>同时也标志着JS的模块化编程正式诞生<br>在网页环境下 , 没有模块也不是特别大的问题 , 因为网页程序的复杂性和规模都相对有限 , 但是在服务器端就必须要有模块 , 否则服务器端程序就会难以扩展和维护</p><p>nodejs的模块系统 , 就是按照CommonJS规范实现的<br>这个规范当中 , 有一个全局方法 <code>require</code> , 用于加载模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mod1 = <span class="built_in">require</span>(<span class="string">"module1"</span>);</span><br><span class="line">mod1.biz();</span><br></pre></td></tr></table></figure><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>有了在服务端可用的模块化编程方式 , 大家很自然就想要在客户端也能实现的方式 , 并且最好能够兼容<br>这样同样的一个模块的代码 , 不用修改任何内容就可以同时应用于服务端和客户端</p><p>但是如果直接套用在nodejs当中的实现方式 , 就会存在线程阻塞的问题<br>也就是必须要等require方法执行完毕 , 加载运行这个模块的代码之后 , 后面的代码才会被执行<br>对于服务端来说 , 这并不是什么问题 , 因为代码都在本地 , 不可能出现长期阻塞的问题<br>但是对于客户端来说 , js文件需要发送http请求去获取 , 所以同步加载的方式就十分影响性能了</p><p>AMD ( Asynchronous Module Definition <code>异步模块定义</code> ) , 这种规范的要求是采用异步方式加载模块<br>形式如下 :<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">"module1"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">mod</span>) </span>&#123;</span><br><span class="line">  mod.biz();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>规范只是约定一种形式 , 具体要应用的话需要有对应的库来实现<br>这里通过<code>require.js</code>来介绍</p><h3 id="require-js"><a href="#require-js" class="headerlink" title="require.js"></a>require.js</h3><p><a href="http://www.requirejs.cn/" target="_blank" rel="noopener">require.js官网</a></p><p>require.js主要解决两个问题</p><ol><li>实现js文件的异步加载 , 避免网页失去响应</li><li>管理模块之间的依赖性 , 便于代码的编写和维护</li></ol><p>使用require.js需要指定一个主模块 , 以及在主模块中可以去引入若干个子模块 , 主模块相当于是程序执行的入口<br>( 如果没有子模块的话就不需要require.js了 )</p><p>目录结构<br><img src="/images/JavaScript/modules.png" alt="require demo"></p><h4 id="data-main入口点"><a href="#data-main入口点" class="headerlink" title="data-main入口点"></a>data-main入口点</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/require.js"</span> <span class="attr">data-main</span>=<span class="string">"js/main"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js目录下的main.js就是作为主模块 , 后面的.js可以省略</p><h4 id="子模块的编写方式"><a href="#子模块的编写方式" class="headerlink" title="子模块的编写方式"></a>子模块的编写方式</h4><p>require.js加载的模块 , 采用AMD规范 , 也就是说模块必须按照AMD的规范来写<br>模块必须采用特定的define函数来定义<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    biz : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"子模块的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这个函数返回的对象就是这个模块需要暴露出的对象</p><p>如果该模块需要依赖其他模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module2.js</span></span><br><span class="line">define([<span class="string">"module1"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">mod1</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">biz2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mod1.biz() + <span class="string">"ok"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    biz : biz2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="主模块的编写方式"><a href="#主模块的编写方式" class="headerlink" title="主模块的编写方式"></a>主模块的编写方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"modules/module1"</span>,<span class="string">"modules/module2"</span>], </span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">mod1,mod2</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//mod1和mod2分别是在子模块中暴露出的对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>require函数接受两个参数 , 第一个参数是子模块的相对路径和名称 ( 如果在同一个路径下可以不加路径 ) , <strong>必须是一个数组</strong><br>第二个参数是子模块加载完成之后执行的回调函数</p><font color="blueviolet">更加灵活的自定义加载</font><p>模块的引入采用的是子模块的js文件与主模块文件的相对位置<br>如果要加在的子模块较多 , 这么相对路径就需要加在每个子模块的前面<br>为了更清晰一些 , 我们可以采用下面的方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line"><span class="comment">//注意这里的baseUrl是相对于引入主模块的页面的路径</span></span><br><span class="line"><span class="comment">//页面是 /require_demo/test.html</span></span><br><span class="line"><span class="comment">//子模块位于 /require_demo/other/module3.js</span></span><br><span class="line">  baseUrl : <span class="string">"./other/"</span>,</span><br><span class="line">  paths : &#123;</span><br><span class="line">    mod3 : <span class="string">"module3"</span>,</span><br><span class="line">    mod4 : <span class="string">"module4"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//上面的代码相当于对子模块的路径创建了映射</span></span><br><span class="line"><span class="comment">//下面才是真正引入模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"mod3"</span>,<span class="string">"mod4"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">mod3, mod4</span>)</span>&#123;</span><br><span class="line">  mod3.biz3();</span><br><span class="line">  mod4.biz4();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面的写法其实就等价于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">"../other/module3"</span>,<span class="string">"../other/module4"</span>],</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">mod3, mod4</span>)</span>&#123;</span><br><span class="line">  mod3.biz3();</span><br><span class="line">  mod4.biz4();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>paths里面也可以直接使用完整的网络URL地址</p></blockquote><h4 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a>加载非规范的模块</h4><p>采用上面的方式去加载的子模块 , 模块当中必须按照AMD的规范去写<br>如果子模块本身并不符合这个要求<br>在不方便修改子模块的情况下 , 我们可以采用如下的方式去加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  shim : &#123;</span><br><span class="line">    underscore : &#123;</span><br><span class="line">      exports : <span class="string">"_"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  paths : &#123; <span class="comment">//这部分并没有什么差别</span></span><br><span class="line">    underscore : <span class="string">"./plugins/underscore"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"underscore"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">_</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//测试代码</span></span><br><span class="line">  _.each([<span class="number">1</span>,<span class="number">10</span>,<span class="number">20</span>],<span class="built_in">console</span>.log);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>未按照AMD规范编写的模块 , 通常采用的是暴露出一个变量放入到window当中作为全局变量 , 比如underscore这个库 , 暴露出的就是<code>_</code></p><h5 id="模块依赖性声明"><a href="#模块依赖性声明" class="headerlink" title="模块依赖性声明"></a>模块依赖性声明</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">shim : &#123;</span><br><span class="line">  <span class="string">"jquery.scroll"</span> : &#123;</span><br><span class="line">    deps : [<span class="string">"jquery"</span>],</span><br><span class="line">    exports : <span class="string">"jQuery.fn.scroll"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模块存在的价值是为了能够更方便地复用代码 , 更加有利于功能的封装&lt;br&gt;但是如果要实现的话 , 就必须要求每个人都按照同样的方式去编写模块&lt;br&gt;目前通行的JavaScript模块规范有两种 , 分别是&lt;code&gt;CommonJS&lt;/code&gt;和&lt;code&gt;AMD&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/tags/JavaScript/"/>
    
      <category term="模块化" scheme="https://sookie2010.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>模块化编程(1)</title>
    <link href="https://sookie2010.github.io/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B(1)/"/>
    <id>https://sookie2010.github.io/JavaScript/模块化编程(1)/</id>
    <published>2018-05-06T12:15:26.000Z</published>
    <updated>2018-05-21T00:48:43.758Z</updated>
    
    <content type="html"><![CDATA[<h4 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h4><blockquote><p>网页中<code>&lt;script&gt;</code>标签</p><ul><li>如果是src引入一个文件的形式 , 加载这个文件的过程默认是同步的 , 如果引入了多个文件 , 则按照声明的顺序进行加载运行 , 前面的文件尚未加载运行完毕 , 不会加载后面的文件<a id="more"></a></li><li>从src所指定的地址获取文件的动作是异步的 , 如果前面有未加载完成的脚本 , 那么该脚本即使已经获取到 , 也不会先加载运行</li><li>给script标签添加<code>async=&quot;async&quot;</code>属性 , 可以指定这个脚本的加载运行以异步方式执行</li><li>在IE当中 , 使用<code>defer</code>指定异步方式执行脚本</li></ul></blockquote><p>例如 :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/test/demo1.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/test/demo2.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果不加 defer async=”async” 的情况下 , demo1.js 和 demo2.js 会顺序加载运行 , 假如demo2.js当中有对demo1.js的依赖 , 那么这种情况下不会出现问题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/test/demo1.js"</span> <span class="attr">defer</span> <span class="attr">async</span>=<span class="string">"async"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/test/demo2.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果demo1.js由于文件庞大 网络不畅等原因加载缓慢 , 我们可以给demo1.js添加异步加载标识<br>这种情况下 , demo2.js将<strong>有可能</strong>先于demo1.js加载运行 , 如果存在依赖 , 将<strong>有可能</strong>报错</p><hr><h3 id="模块化的实现方式"><a href="#模块化的实现方式" class="headerlink" title="模块化的实现方式"></a>模块化的实现方式</h3><p>JS在很长一段时间内不是一种支持模块化编程的语言<br>虽然ES6正式支持了类和模块 , 在nodejs环境下的模块化编程没有问题<br>但是能够在浏览器环境中普遍使用还需要很长时间<br>所以需要采用其他的方法去模拟实现模块化</p><h4 id="原始写法"><a href="#原始写法" class="headerlink" title="原始写法"></a>原始写法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将若干个函数简单堆积在一起 , 可以认为是一个模块<br>但是这种模式是将这些函数对象作为全局变量<br>如果函数很多 , 会造成全局变量的污染<br>与其他模块也可能发生变量的命名冲突问题</p><h4 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = &#123;</span><br><span class="line">  _count : <span class="number">0</span>,</span><br><span class="line">  up : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    _count ++;</span><br><span class="line">  &#125;,</span><br><span class="line">  down : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    _count --;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种写法只讲一个对象作为全局变量 , 一定程度上避免了全局变量的污染<br>但是这种写法会暴露所有的模块成员 , 无法做到只有模块内部方法能够访问的局部变量</p><h4 id="立即执行函数写法"><a href="#立即执行函数写法" class="headerlink" title="立即执行函数写法"></a>立即执行函数写法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    up : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      _count ++;</span><br><span class="line">    &#125;,</span><br><span class="line">    down : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      _count --;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这种写法 , 把模块内需要保护的变量作为函数的局部变量 , 在外部无法直接去访问<br>可以算是相对科学的写法了 , 之后的几种都是对这种写法的改造和扩展</p><h4 id="放大模式"><a href="#放大模式" class="headerlink" title="放大模式"></a>放大模式</h4><p>如果一个模块需要分成几个部分写在不同的地方 , 或者说一个模块需要去继承另一个模块 , 就需要使用放大模式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>)</span>&#123;</span><br><span class="line">  mod.biz = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我是另外加入的方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(module1);</span><br></pre></td></tr></table></figure></p><h4 id="宽放大模式"><a href="#宽放大模式" class="headerlink" title="宽放大模式"></a>宽放大模式</h4><p>上面的放大模式显然需要保证模块加载的先后顺序<br>如果传入的module1是undefined , 肯定会报错<br>然而部署在外网的项目 , 如果严格限制了模块的加载顺序 , 很容易造成页面加载缓慢<br>为了适应这种情况 , 可以采用宽放大模式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>)</span>&#123;</span><br><span class="line">  mod.biz = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我是另外加入的方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure></p><p>module1模块的两部分都采取这种写法 , 加载的先后就无所谓了<br>先加载的会在空对象上添加方法</p><h4 id="输入全局变量"><a href="#输入全局变量" class="headerlink" title="输入全局变量"></a>输入全局变量</h4><p>一个模块最好能够是独立的 , 不与其他模块中的部分直接进行交互<br>但是如果在模块内需要其他模块产生的对象<br>可以显式地将这些对象输入到模块内部</p><p>比如需要用到jQuery的对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;准备知识&quot;&gt;&lt;a href=&quot;#准备知识&quot; class=&quot;headerlink&quot; title=&quot;准备知识&quot;&gt;&lt;/a&gt;准备知识&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;网页中&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是src引入一个文件的形式 , 加载这个文件的过程默认是同步的 , 如果引入了多个文件 , 则按照声明的顺序进行加载运行 , 前面的文件尚未加载运行完毕 , 不会加载后面的文件
    
    </summary>
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/tags/JavaScript/"/>
    
      <category term="模块化" scheme="https://sookie2010.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>生成器函数</title>
    <link href="https://sookie2010.github.io/JavaScript/Symbol/"/>
    <id>https://sookie2010.github.io/JavaScript/Symbol/</id>
    <published>2018-05-06T12:09:40.000Z</published>
    <updated>2018-05-21T00:48:43.748Z</updated>
    
    <content type="html"><![CDATA[<p>在ES6标准当中 , 新引入了一种基本数据类型 , 就是<code>Symbol</code><br><a id="more"></a><br>在此之前的基本数据类型有</p><ul><li>undefined</li><li>null</li><li>object</li><li>number</li><li>boolean</li><li>string</li></ul><p>通常我们可以使用<code>typeof</code>来判断一个对象的类型<br>但是存在一些特例</p><ol><li>对于一个函数对象 , 对其执行typeof操作 , 获得的是<code>&quot;function&quot;</code></li><li>对于null , 对其执行typeof操作 , 获得的是<code>&quot;object&quot;</code></li></ol><hr><p>Symbol对象可以认为是一个<strong>唯一标识</strong><br>我们可以采用如下的方式来构造出一个Symbol对象</p><ul><li>Symbol() - 这种方式每次调用 , 返回的对象都不同</li><li>Symbol.for(string) - 这种方式会试图访问已经存在的Symbol对象 , 如果不存在则创建一个新的<br>Symbol.for(“aa”) == Symbol.for(“aa”)  会获得<strong>true</strong></li><li>使用预定义的Symbol对象 , 比如Symbol.iterator</li><li>使用typeof Symbol对象 , 返回”symbol”</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="构造一个对象当中的私有属性"><a href="#构造一个对象当中的私有属性" class="headerlink" title="构造一个对象当中的私有属性"></a>构造一个对象当中的私有属性</h4><p>JavaScript的对象属性默认是可以被外界访问和修改的<br>通常我们对于不希望被访问的变量 , 以下划线开头明明<br>但是这只是一种约定 , 并不具有强制作用<br>如果我们开发的第三方模块当中 , 需要有只提供给模块内方法访问的私有属性<br>那么就可以借助Symbol来实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [_x, _y] = [<span class="built_in">Symbol</span>(), <span class="built_in">Symbol</span>()];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[_x] = x;</span><br><span class="line">    <span class="keyword">this</span>[_y] = y;</span><br><span class="line">  &#125;</span><br><span class="line">  Point.prototype.length = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="keyword">this</span>[_x],</span><br><span class="line">    y = <span class="keyword">this</span>[_y];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(x * x + y * y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.length()); <span class="comment">//5</span></span><br></pre></td></tr></table></figure></p><p>在上面提到过 , 每次调用Symbol()返回的对象都是不同的<br>所以在自动执行的函数内部 , _x 和 _y其实是不同的对象<br>或者我们也可以用<code>Symbol(&quot;x&quot;)</code>和<code>Symbol(&quot;y&quot;)</code>来进行区分 , 这不是必须的</p><p>这种情况下 , 内部的两个属性就真正成为了私有属性 , 无法在外部访问到它的值<br>因为在外部再次调用Symbol()产生的是不同的对象</p><h4 id="避免命名冲突"><a href="#避免命名冲突" class="headerlink" title="避免命名冲突"></a>避免命名冲突</h4><p>对于相对复杂的模块 , 暴露出的对象内部的私有变量可能需要很多<br>如果这些私有变量没有被完全私有化<br>那么这个模块的兼容性和可扩展性就会很差<br>因为在扩展时十分容易出现命名的冲突问题</p><p>或者可以用一个十分冗长的字符串作为属性名 , 那么源代码的可读性就基本不存在了</p><p>使用Symbol可以解决这个问题 , 与上面的类似的<br>变量私有化 , 则不会产生同名的冲突</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在ES6标准当中 , 新引入了一种基本数据类型 , 就是&lt;code&gt;Symbol&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript6" scheme="https://sookie2010.github.io/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>new关键字做了什么</title>
    <link href="https://sookie2010.github.io/JavaScript/new%E5%85%B3%E9%94%AE%E5%AD%97%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://sookie2010.github.io/JavaScript/new关键字做了什么/</id>
    <published>2018-05-02T12:05:33.000Z</published>
    <updated>2018-05-21T00:48:43.748Z</updated>
    
    <content type="html"><![CDATA[<p>假设说现在要构造若干个”士兵”对象 , 每个士兵都有类型 攻击力 生命值 这些属性<br>同时有奔跑 攻击 防御 这些可以执行的动作 , 在代码中表现为方法<br><a id="more"></a><br>简单粗暴的方式可以这样做<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> soldiers = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> soldier = &#123;</span><br><span class="line">    type : <span class="string">"步兵"</span>,</span><br><span class="line">    id : i,</span><br><span class="line">    health : <span class="number">100</span>,</span><br><span class="line">    run : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"奔跑"</span>);&#125;,</span><br><span class="line">    attack : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"攻击"</span>);&#125;,</span><br><span class="line">    defense : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"防御"</span>);&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  soldiers.push(soldier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方式显然存在一个问题 , 就是浪费了大量的内存<br>因为每个士兵可以执行的行为都是一样的 , 这几个函数完全可以共用<br>这种方式却给每个对象创建了独立的函数<br>兵种也是一样的 , 只有id和生命值 , 每个士兵都要具备自己的值</p><p>可以给每个对象指定各自的原型对象 , 只要这些共用的方法写在原型对象当中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> soldiers = [];</span><br><span class="line"><span class="keyword">var</span> soldierProto = &#123;</span><br><span class="line">  type : <span class="string">"步兵"</span>,</span><br><span class="line">  run : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"奔跑"</span>)&#125;,</span><br><span class="line">  attack : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"攻击"</span>);&#125;,</span><br><span class="line">  defense : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"防御"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> soldier = &#123;</span><br><span class="line">    id : i,</span><br><span class="line">    health : <span class="number">100</span></span><br><span class="line">  &#125;;</span><br><span class="line">  solider.__proto__ = soldierProto;</span><br><span class="line">  soldiers.push(soldier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在把创建士兵的代码放在了两个地方 , 很不优雅<br>所以可以用一个函数把两者联系起来<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSoldier</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _soldier = &#123;&#125;; <span class="comment">//临时对象</span></span><br><span class="line">  _soldier.__proto__ = createSoldier[<span class="string">"原型"</span>];</span><br><span class="line">  _soldier.id = id;</span><br><span class="line">  _soldier.health = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> _soldier;</span><br><span class="line">&#125;</span><br><span class="line">createSoldier[<span class="string">"原型"</span>]= &#123;</span><br><span class="line">  type : <span class="string">"士兵"</span>,</span><br><span class="line">  attackNum : <span class="number">5</span>, <span class="comment">//攻击力</span></span><br><span class="line">  run : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"奔跑"</span>);&#125;,</span><br><span class="line">  attack : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"攻击"</span>);&#125;,</span><br><span class="line">  defense : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"防御"</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码在函数中添加了一个属性 , 叫做”原型”<br>主要做的就是把需要作为原型的对象保存在函数对象的一个属性当中 , 使调用这个函数的时候可以获取到这个原型对象<br>new关键字所做的事情 , 其实就相当于是上面代码里面我们自己手动实现的事情</p><ul><li>自动创建临时对象 ( 在函数内部使用this可以访问到这个临时对象 )</li><li>自动绑定该Function对象的原型 ( 统一叫做<code>prototype</code> )</li><li>自动return这个临时对象</li></ul><p>现在写一个可以用new去调用的纯粹的构造函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">soldier</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.health = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">soldier.prototype = &#123;</span><br><span class="line">  type : <span class="string">"士兵"</span>,</span><br><span class="line">  attackNum : <span class="number">5</span>, <span class="comment">//攻击力</span></span><br><span class="line">  run : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"奔跑"</span>);&#125;,</span><br><span class="line">  attack : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"攻击"</span>);&#125;,</span><br><span class="line">  defense : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"防御"</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外 , 为了记录 <strong>临时对象是由哪个函数创建的</strong> , 会在定义这个函数的时候 , 在函数的prototype属性 ( 是Object ) 上面自动添加一个<code>constructor</code>属性 , 比如 :<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Sookie"</span>;</span><br><span class="line">&#125;</span><br><span class="line">func.prototype.constructor === func; <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>所以如果像上面那样直接给函数的prototype属性赋值一个对象的话 , 这个constructor就没了<br>所以可以采取下面两种做法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 手工把这个属性加上</span></span><br><span class="line">soldier.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span> : soldier,</span><br><span class="line">  type : "士兵",</span><br><span class="line">  attackNum : 5, //攻击力</span><br><span class="line">  run : function()&#123;<span class="built_in">console</span>.log(<span class="string">"奔跑"</span>);&#125;,</span><br><span class="line">  attack : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"攻击"</span>);&#125;,</span><br><span class="line">  defense : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"防御"</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 不去覆盖原本的prototype属性对象, 而是直接在上面添加属性</span></span><br><span class="line">soldier.prototype.type = <span class="string">"士兵"</span>;</span><br><span class="line">soldier.prototype.attackNum = <span class="number">5</span>;</span><br><span class="line">soldier.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"奔跑"</span>);&#125;;</span><br><span class="line">soldier.prototype.attack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"攻击"</span>);&#125;;</span><br><span class="line">soldier.prototype.defense = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"防御"</span>);&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设说现在要构造若干个”士兵”对象 , 每个士兵都有类型 攻击力 生命值 这些属性&lt;br&gt;同时有奔跑 攻击 防御 这些可以执行的动作 , 在代码中表现为方法&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>生成器函数</title>
    <link href="https://sookie2010.github.io/JavaScript/%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0/"/>
    <id>https://sookie2010.github.io/JavaScript/生成器函数/</id>
    <published>2018-04-29T11:57:44.000Z</published>
    <updated>2018-05-21T00:48:43.758Z</updated>
    
    <content type="html"><![CDATA[<p><code>function *</code>声明可以用于定义一个生成器函数 , 它返回一个Generator对象<br><a id="more"></a><br>语法</p><pre>function * name([param[,param[,...param]]]){ statement }</pre><p>生成器是一种可以从中退出后重新进入的函数<br>函数内部的局部变量会在每次执行后被保存 , 下次进入可以继续使用</p><p>调用生成器函数并不会执行它的主体 , 而是返回对应的一个Generator对象<br>当这个对象的<code>next()</code>方法被调用时 , 生成器函数的主体会被执行至第一个<code>yield</code>表达式 , 该表达式定义了生成器本次生成的值<br>next()方法返回一个对象<br>包含<strong>value</strong>属性 , 是本次生成的值<br>以及<strong>done</strong>属性 , 表示生成器是否已经产出了最后一个值 ( 产出最后的值之后 , 调用next返回的对象当中value都是undefined )</p><blockquote><p>Generator对象中的方法</p><ul><li>Generator.prototype.next()<br>返回一个由yield表达式生成的值</li><li>Generator.prototype.return( [val] )<br>返回给定的值并结束生成器</li><li>Generator.prototype.throw( [msg] )<br>向生成器抛出一个错误</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">num</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(a &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    a++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = num();</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><hr><h4 id="yield"><a href="#yield" class="headerlink" title="yield *"></a>yield *</h4><p>可以将生成器中需要生成的值委派至另一个生成器<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">anotherGenerator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> i;</span><br><span class="line">  <span class="keyword">yield</span>* anotherGenerator(i);</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = generator(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p><blockquote><p>生成器函数在浏览器当中的兼容性不佳 , 更推荐在nodejs当中使用 , 而不是在页面脚本当中使用<br><img src="/images/JavaScript/generate_function1.png" alt="generate function"><br><img src="/images/JavaScript/generate_function2.png" alt="generate function"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;function *&lt;/code&gt;声明可以用于定义一个生成器函数 , 它返回一个Generator对象&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript6" scheme="https://sookie2010.github.io/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>扩展运算符的用法</title>
    <link href="https://sookie2010.github.io/JavaScript/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://sookie2010.github.io/JavaScript/扩展运算符的用法/</id>
    <published>2018-04-28T11:53:47.000Z</published>
    <updated>2018-05-21T00:48:43.758Z</updated>
    
    <content type="html"><![CDATA[<p>ES6标准新加入的<code>扩展运算符(Spread Operator)</code> , 可以使JS代码变得更加简洁 , 编写起来更加灵活<br><a id="more"></a></p><h4 id="不使用apply去调用函数"><a href="#不使用apply去调用函数" class="headerlink" title="不使用apply去调用函数"></a>不使用apply去调用函数</h4><p>如果现在有一个数组 , 需要将它当中的每个元素逐个对应到一个函数的参数进行传入的话 , 在以往需要这样写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a,b,c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a+b+c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">10</span>,<span class="number">2</span>,<span class="number">60</span>];</span><br><span class="line">func.apply(<span class="literal">null</span>, args);</span><br></pre></td></tr></table></figure></p><p>如果使用扩展运算符 , 只需按照如下方式调用即可<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(...args);</span><br></pre></td></tr></table></figure></p><h4 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h4><p>以往合并数组的方式通常是使用<code>concat</code>方法<br>或者也可以遍历数组 , 逐个push或者unshift到另一个数组当中<br>现在有了扩展运算符 , 就可以运用更加灵活简洁的方式了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">10</span>,<span class="number">30</span>,<span class="string">"ab"</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="literal">true</span>,<span class="string">"pp"</span>];</span><br><span class="line"></span><br><span class="line">arr1.unshift(...arr2);</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure><p>或者也可以在数组内部进行合并<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">10</span>,<span class="number">20</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, ...arr1, <span class="number">100</span>];</span><br></pre></td></tr></table></figure></p><p>语法更简洁了 , 而且可以灵活控制位置</p><h4 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h4><p>其实与上面的数组内合并是类似的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr1];</span><br></pre></td></tr></table></figure></p><h4 id="将类数组转化为数组"><a href="#将类数组转化为数组" class="headerlink" title="将类数组转化为数组"></a>将类数组转化为数组</h4><p>在以前我们需要用<code>Array.prototype.slice</code>来讲类数组( 比如arguments )来转化为真正的数组对象<br>现在可以直接使用扩展运算符了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divArr = [...document.querySelectorAll(<span class="string">"div"</span>)];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"><span class="comment">//等同于[...arguments]</span></span><br><span class="line">  <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>所谓解构 , 其实就是分解数组或对象的结构 , 将其中的元素直接赋值给变量</p><h5 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h5><p>比如通过不定参数来获取数组后面的尾随元素<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,...b] = [<span class="string">'a2'</span>,<span class="string">'b2'</span>,<span class="string">'c2'</span>,<span class="string">'d2'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//a2</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//['b2','c2','d2']</span></span><br></pre></td></tr></table></figure></p><p>也可以在某些位置留空 , 跳过数组当中对应位置的元素<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,,b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>对于多维数组 , 也是同样适用的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [one,[[two],three]] = [<span class="number">1</span>, [[<span class="number">2</span>],<span class="number">3</span>]];</span><br></pre></td></tr></table></figure></p><p>数组结构同样可以适用于<strong>生成器</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line"><span class="built_in">console</span>.log(sixth);</span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><h5 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;name:&quot;Sookie&quot;, age:18&#125;;</span><br><span class="line">var &#123;name : nameA&#125; = obj;</span><br><span class="line">console.log(nameA); //Sookie</span><br></pre></td></tr></table></figure><p>当属性名与变量名一致的时候 , 也可以简写如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;name&#125; = obj;</span><br></pre></td></tr></table></figure></p><p>与数组类似 , 多层嵌套的对象结构同样可以使用类似的结构分别赋值给对应的变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> complicatedObj = &#123;</span><br><span class="line">      arrayProp: [</span><br><span class="line">        <span class="string">"Zapp"</span>,</span><br><span class="line">        &#123; <span class="attr">second</span>: <span class="string">"Brannigan"</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> &#123; <span class="attr">arrayProp</span>: [first, &#123; second &#125;] &#125; = complicatedObj;</span><br></pre></td></tr></table></figure></p><blockquote><p>当解构对象时 , 如果没有变量声明的标识符 ( var  const  let ) , 直接这样写会报错<br><code>{a} = {a:10}</code><br>因为JS解析器会把 { 开始的语句解析为一个块语句<br><code>({a} = {a:10})</code>这样写就是正确的</p></blockquote><p>我们可以给解构的结果添加一个默认值<br>如果解构的目标数组或者对象当中没有获取到对应的值 , 那么将使用这个默认值<br>( 不指定默认值将得到undefined )<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [missing=<span class="literal">true</span>] = [];</span><br><span class="line"><span class="keyword">var</span> &#123;msg=<span class="string">"success"</span>&#125; = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6标准新加入的&lt;code&gt;扩展运算符(Spread Operator)&lt;/code&gt; , 可以使JS代码变得更加简洁 , 编写起来更加灵活&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript6" scheme="https://sookie2010.github.io/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>ES6的重要新特性</title>
    <link href="https://sookie2010.github.io/JavaScript/ES6%E7%9A%84%E9%87%8D%E8%A6%81%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://sookie2010.github.io/JavaScript/ES6的重要新特性/</id>
    <published>2018-04-22T11:50:19.000Z</published>
    <updated>2018-05-21T00:48:43.738Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>函数的默认参数</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="function"><span class="keyword">function</span>(<span class="params">height=<span class="number">50</span>,color=<span class="string">"red"</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//some code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><p>在没有这种写法的时候<br>我们通常需要通过下面的方式来设置函数参数的默认值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="function"><span class="keyword">function</span>(<span class="params">height,color</span>) </span>&#123;</span><br><span class="line">  height = height || <span class="number">50</span>;</span><br><span class="line">  color = color || <span class="string">"red"</span>;</span><br><span class="line">  <span class="comment">//some code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是这种方式存在缺陷 , 就是当实参为0 或者 “”等这种会被判定为false的值 , 他们就会被默认值所替代<br>而包含参数默认值的函数则不会存在这个问题 </p><ol start="2"><li><strong>模板表达式</strong><br>以往如果需要在字符串中嵌入某个变量值 , 需要使用加号进行拼接<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> port = <span class="number">7001</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"the server is listening at "</span> + port + <span class="string">"!"</span>);</span><br></pre></td></tr></table></figure></li></ol><p>在ES6当中 , 使用<code>反引号</code>包裹的字符串 , 可以使用<code>${varName}</code>的形式来表示模板字符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> port = <span class="number">7001</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`the server is listening at <span class="subst">$&#123;port&#125;</span>!`</span>);</span><br></pre></td></tr></table></figure></p><p>用法类似JSP当中的 EL表达式</p><ol start="3"><li><strong>多行字符串</strong><br>以往要在代码中换行显示字符串 , 需要使用加好进行拼接 , 如果要使字符串当中实际包含换行 , 则需要使用转义字符<code>\n</code></li></ol><p>反引号当中的字符串可以直接进行换行 , 而不需要使用<code>\n</code>符号</p><ol start="4"><li><strong>拆包表达式</strong><br>如果要把一个JS对象当中的值赋给局部变量 , 以往通常需要这么做<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">  name : <span class="string">"Sookie"</span>,</span><br><span class="line">  age : <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = data.name;</span><br><span class="line"><span class="keyword">var</span> age = data.age;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`name : <span class="subst">$&#123;name&#125;</span>, age : <span class="subst">$&#123;age&#125;</span>`</span>);</span><br></pre></td></tr></table></figure></li></ol><p>在ES6当中 , 使用以下语句可以达到相同的效果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;name,age&#125; = data;</span><br></pre></td></tr></table></figure></p><p>对于数组的支持<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">  name : <span class="string">"Sookie"</span>,</span><br><span class="line">  age : <span class="number">18</span>,</span><br><span class="line">  skill : [<span class="string">"JavaScript"</span>,<span class="string">"Java"</span>,<span class="string">"MongoDB"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这里相当于产生了3个局部变量</span></span><br><span class="line"><span class="keyword">var</span> [sk1, sk2, sk3] = data.skill;</span><br><span class="line"><span class="built_in">console</span>.log(sk1, sk2, sk3);</span><br></pre></td></tr></table></figure></p><p>如果要跳过数组中某个位置的元素也是可以的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [sk1, , sk3] = data.skill;</span><br></pre></td></tr></table></figure></p><ol start="5"><li><strong>块级作用域的<code>let</code>和<code>const</code></strong><br>let可以认为是一个更新的var , 使用它定义的局部变量 , 作用域仅存在与当前的代码块( 包括复合语句 )<br>而由于变量的定义提升问题 , var是不能完全做到这一点的<br>例如 , 从习惯了写Java的程序员 , 通常习惯于下面这种写法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span> ; i++)&#123;</span><br><span class="line">  sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">//45</span></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//10</span></span><br></pre></td></tr></table></figure></li></ol><p>但是变量 i 的作用域并不仅限于for循环的子句<br>如果使用如下方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span> ; i++)&#123;</span><br><span class="line">  sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">//45</span></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">//ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure></p><p>就把 i 的作用域限制在了代码块当中</p><p>对于使用<code>const</code>定义的变量 , 可以参照C语言中的const关键字 , 和Java当中的final关键字<br>作用仅仅是该引用的指向不可变 , 但是指向的对象本身是可变的</p><ol start="6"><li><strong>类与面向对象</strong><br>在ES5当中 , 要定义一个类, 只能是编写一个构造函数 , 这个函数与普通的函数没有本质区别 , 只是使用new关键字进行调用 , 它就可以构造一个对象<br>而<code>class</code>关键字 , 在ES6之前 , 只是作为一个没有意义的保留字存在的<br>现在 , 我们可以使用与Java十分相像的方式去写一个类<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;, data = []) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"Sookie"</span>;</span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">  showName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`the name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> model = <span class="keyword">new</span> BaseModel();</span><br><span class="line">model.showName();</span><br></pre></td></tr></table></figure></li></ol><p>constructor表示这个类的构造函数<br>需要注意的是 : 对于对象当中属性的赋值 , 必须要在构造函数当中完成 , 而不能像Java那样直接对类中的属性设定初始值</p><p>#####继承<br>继承的实现方式与Java也十分类似<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span> <span class="keyword">extends</span> <span class="title">BaseModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;, data = []) &#123;</span><br><span class="line">    <span class="comment">//如果要显式调用父类的构造方法, super必须放在第一条语句</span></span><br><span class="line">    <span class="keyword">super</span>(options, data);</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  showAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`the name is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> model = <span class="keyword">new</span> MyModel();</span><br><span class="line">model.showName();</span><br><span class="line">model.showAge();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;strong&gt;函数的默认参数&lt;/strong&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; link = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;height=&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;,color=&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//some code...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript6" scheme="https://sookie2010.github.io/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>Promise(2)</title>
    <link href="https://sookie2010.github.io/JavaScript/Promise(2)/"/>
    <id>https://sookie2010.github.io/JavaScript/Promise(2)/</id>
    <published>2018-04-20T11:45:09.000Z</published>
    <updated>2018-05-21T00:48:43.748Z</updated>
    
    <content type="html"><![CDATA[<p>如果只是执行一次单步回调 , 那么传统的回调函数执行的方式其实并没有什么问题</p><p>Promise的主要意义是在于解决多重回调的多层嵌套问题<br>如果回调的嵌套层级太多 , 会造成代码可读性很差 , 难以维护<br><a id="more"></a><br>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params">num, func</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num);</span><br><span class="line">  func(num);</span><br><span class="line">&#125;;</span><br><span class="line">test(<span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  test(<span class="number">2</span>, <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    test(<span class="number">3</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"回调成功"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>使用Promise可以将上述的代码改造成线性的模式 , 可读性增强 , 同时也更便于调试<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>让then方法的函数每次都是返回不同的Promise实例 , 再去指定这个实例的回调函数即可</p><p>并且对于Promise对象 , 它的回调执行是异步的<br>例如 :<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">"AA"</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"BB"</span>);</span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">BB</span></span><br><span class="line"><span class="comment">AA</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>对于异步操作实现的原理 , 可以参考JS的事件驱动模型<br>JS引擎会将回调函数的执行加入到事件队列当中<br>从而实现在单线程的条件下 , 代码的异步执行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果只是执行一次单步回调 , 那么传统的回调函数执行的方式其实并没有什么问题&lt;/p&gt;
&lt;p&gt;Promise的主要意义是在于解决多重回调的多层嵌套问题&lt;br&gt;如果回调的嵌套层级太多 , 会造成代码可读性很差 , 难以维护&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/tags/JavaScript/"/>
    
      <category term="Promise" scheme="https://sookie2010.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>Promise(1)</title>
    <link href="https://sookie2010.github.io/JavaScript/Promise(1)/"/>
    <id>https://sookie2010.github.io/JavaScript/Promise(1)/</id>
    <published>2018-04-20T11:43:20.000Z</published>
    <updated>2018-05-21T00:48:43.738Z</updated>
    
    <content type="html"><![CDATA[<p>在JavaScript当中 , 不存在真正的多线程 , 从而导致所有需要异步执行的操作都需要使用回调函数实现<br><a id="more"></a><br>例如 : 使用定时器去执行一个回调函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.debug(<span class="string">"Time Out!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"before"</span>);</span><br><span class="line">setTimeout(callback,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"after"</span>);</span><br></pre></td></tr></table></figure></p><p>定时器会在1秒之后去执行callback这个回调函数<br>这就实现了一个简单的异步操作<br>异步操作会在将来的某个时间点触发一个函数调用<br>Ajax的异步请求也是一种异步操作</p><p>类似这种<strong>承诺将来会执行</strong>的对象 , 在ES6当中被统一规范为<code>Promise对象</code></p><p>这个对象的最大作用就是将执行代码和处理结果的回调函数进行了分离 , 从而在存在多重回调的情境当中 , 代码的可读性更强</p><p>一个简单的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        resolve(<span class="string">'success'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">'failed'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test);</span><br><span class="line"><span class="comment">//then传入的是resolve的实现</span></span><br><span class="line"><span class="comment">//catch传入的是reject的实现</span></span><br><span class="line">p1.then(<span class="built_in">console</span>.log).catch(<span class="built_in">console</span>.error);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">也可以用如下的方式, 实际效果同上</span></span><br><span class="line"><span class="comment">p1.then(console.log, console.log);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>Promise对象在创建的时候 , 传入的这个函数当中并不关心成功与失败具体的回调是什么 , 而只是关心何时去执行该回调函数</p><p>Promise对象有3种状态</p><ol><li><code>Fulfilled</code> 成功的状态</li><li><code>Rejected</code> 失败的状态</li><li><code>Pending</code> Promise 对象实例创建时候的初始状态</li></ol><p>可以由初始状态转换到成功状态 , 或者由初始状态转换到失败状态 , 并且不可逆<br>我们可以在初始化函数里面自己编写逻辑来确定何种情况下执行成功的回调函数( resolve ) 或者失败的函数( reject )<br>如果抛出错误而且没有进行捕获 , 则一定会执行失败的函数( reject )</p><p>如果对于某种状态 , 要执行多个回调函数<br>可以进行链式调用 , 也就是连缀多个<code>then</code>方法<br>前一个then方法中的返回值会作为下一个回调函数的参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        resolve(<span class="string">'success'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">'failed'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test);</span><br><span class="line">p1</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我是第一个回调函数:"</span> + msg);</span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我是第二个回调函数:"</span> + msg);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure></p><p>当然上面这种方式只能适用于多重回调函数中只有一个参数的情况<br>如果要传多个参数<br>必须使用数组的形式传递<br>比如参数中是<code>function([msg1, msg2])</code><br>前一个回调函数中<code>return [&quot;AA&quot;,&quot;BB&quot;]</code></p><hr><h4 id="Promise-all-和-Promise-race"><a href="#Promise-all-和-Promise-race" class="headerlink" title="Promise.all 和 Promise.race"></a>Promise.all 和 Promise.race</h4><p><code>Promise.all</code>方法可以接收一个Promise对象构成的数组作为参数 , 返回一个Promise对象<br>当数组中的这些Promise对象<strong>全部</strong>转换为成功状态的时候 , 这个对象才转换为成功状态 , 否则就转换为失败状态<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status = [<span class="literal">true</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(status[<span class="number">0</span>]) &#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="string">"failed"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(status[<span class="number">1</span>]) &#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="string">"failed"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test1);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test2);</span><br><span class="line">p1.then(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.log(<span class="string">"成功"</span> + msg))</span><br><span class="line">.catch(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.error(<span class="string">"失败"</span> + msg));</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.log(<span class="string">"成功"</span> + msg))</span><br><span class="line">.catch(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.error(<span class="string">"失败"</span> + msg));</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1,p2])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">msgs</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msgs <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//true</span></span><br><span class="line">  <span class="built_in">console</span>.log(msgs);<span class="comment">//[ 'success', 'success' ]</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//注意 : 这里的回调函数的参数就是所有Promise对象成功回调函数传入参数的数组</span></span><br><span class="line"><span class="comment">//(如果只有一个参数,则不构成数组)</span></span><br></pre></td></tr></table></figure></p><p><code>Promise.race</code>方法的用法与all类似 , 它返回的Promise对象是当数组中<strong>存在</strong>Promise对象转为成功状态的时候 , 它就转为成功状态 , 如果全是失败状态 , 它才是失败状态<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">status[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test1);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test2);</span><br><span class="line">p3.then(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.log(<span class="string">"成功"</span> + msg))</span><br><span class="line">.catch(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.error(<span class="string">"失败"</span> + msg));</span><br><span class="line"></span><br><span class="line">p4.then(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.log(<span class="string">"成功"</span> + msg))</span><br><span class="line">.catch(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.error(<span class="string">"失败"</span> + msg));</span><br><span class="line"><span class="built_in">Promise</span>.race([p3,p4])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">msgs</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//参数规则同Promise.all</span></span><br><span class="line">  <span class="built_in">console</span>.log(msgs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在JavaScript当中 , 不存在真正的多线程 , 从而导致所有需要异步执行的操作都需要使用回调函数实现&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sookie2010.github.io/tags/JavaScript/"/>
    
      <category term="Promise" scheme="https://sookie2010.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>2.3、shell(4)-使用技巧</title>
    <link href="https://sookie2010.github.io/linux/2.3%E3%80%81shell(4)-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://sookie2010.github.io/linux/2.3、shell(4)-使用技巧/</id>
    <published>2018-03-05T16:52:25.000Z</published>
    <updated>2018-05-21T00:48:43.788Z</updated>
    
    <content type="html"><![CDATA[<h4 id="判断上一条命令执行是否成功"><a href="#判断上一条命令执行是否成功" class="headerlink" title="判断上一条命令执行是否成功"></a>判断上一条命令执行是否成功</h4><p><code>$?</code>变量的值是上一条命令执行的返回值<br>通过判断这个变量的值 , 可以知道上一条命令是否执行成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"执行成功"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"执行失败"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="逐行读取文件"><a href="#逐行读取文件" class="headerlink" title="逐行读取文件"></a>逐行读取文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> LINE</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$LINE</span> </span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;判断上一条命令执行是否成功&quot;&gt;&lt;a href=&quot;#判断上一条命令执行是否成功&quot; class=&quot;headerlink&quot; title=&quot;判断上一条命令执行是否成功&quot;&gt;&lt;/a&gt;判断上一条命令执行是否成功&lt;/h4&gt;&lt;p&gt;&lt;code&gt;$?&lt;/code&gt;变量的值是上一条命令执行的返回值&lt;br&gt;通过判断这个变量的值 , 可以知道上一条命令是否执行成功&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; [ $? -eq 0 ];&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;执行成功&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;执行失败&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://sookie2010.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://sookie2010.github.io/tags/linux/"/>
    
      <category term="shell" scheme="https://sookie2010.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>2.2、shell编程(3)-流程控制与函数</title>
    <link href="https://sookie2010.github.io/linux/2.2%E3%80%81shell%E7%BC%96%E7%A8%8B(3)-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%87%BD%E6%95%B0/"/>
    <id>https://sookie2010.github.io/linux/2.2、shell编程(3)-流程控制与函数/</id>
    <published>2018-03-05T16:52:22.000Z</published>
    <updated>2018-05-21T00:48:43.778Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  command1</span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">  command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  command3</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>如果else没有语句执行<br>则不能留空 , 最好直接不写这个else<br><a id="more"></a><br>举例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ `ps ax | grep -c <span class="string">"ssh"</span>` -ge 1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"RUNNING"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># grep的-c参数代表对过滤后的行进行计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用test命令做判断</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> `ps ax | grep -c <span class="string">"ssh"</span>` -ge 1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"RUNNING"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=1 ; i&lt;=10 ; i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 注意使用(()), 里面的变量并不需要加$</span></span><br></pre></td></tr></table></figure><p><code>for (( ; ; ))</code> - 死循环</p><h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><p>bash支持对集合进行迭代的foreach类型语法<br>使用<code>for ... in ...</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># seq命令可以生成一个序列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 10`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样也是一个序列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代遍历一个数组</span></span><br><span class="line">arr=(<span class="string">"ab"</span> <span class="string">"cd"</span> <span class="string">"ef"</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable">$&#123;arr[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$item</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>如果一个命令返回的是一个集合 , 也可以执行循环迭代<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> `ls /usr/<span class="built_in">local</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$item</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>当然如果是找一个目录下的文件 , 也可以不用ls命令<br>for循环自带路径查找功能<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> /usr/<span class="built_in">local</span>/*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$item</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 注意路径不要加引号</span></span><br></pre></td></tr></table></figure></p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>while循环是在判断条件为false的时候结束循环<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cnt=1</span><br><span class="line"><span class="keyword">while</span> (( <span class="variable">$cnt</span>&lt;=5 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$cnt</span></span><br><span class="line">  <span class="built_in">let</span> <span class="string">"cnt++"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p><code>while :</code>或者<code>while true</code>表示死循环</p><h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h4><p>格式与while循环基本一致 , 只不过是当判断条件为true的时候结束循环<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cnt=1</span><br><span class="line">until (( <span class="variable">$cnt</span>&gt;=5 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$cnt</span></span><br><span class="line">  <span class="built_in">let</span> <span class="string">"cnt++"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><h4 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue"></a>break与continue</h4><p>表示跳出循环以及继续下一次循环 , 与其他语言当中类似</p><h3 id="多选择语句"><a href="#多选择语句" class="headerlink" title="多选择语句"></a>多选择语句</h3><p>类似其他语言当中的switch , bash当中使用case关键字<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"input a number:"</span></span><br><span class="line"><span class="comment"># read表示从终端读取用户输入内容</span></span><br><span class="line"><span class="built_in">read</span> num</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$num</span> <span class="keyword">in</span></span><br><span class="line">    1) <span class="built_in">echo</span> <span class="string">"数字1"</span></span><br><span class="line">    ;;</span><br><span class="line">    2) <span class="built_in">echo</span> <span class="string">"数字2"</span></span><br><span class="line">    ;;</span><br><span class="line">    3|4) <span class="built_in">echo</span> <span class="string">"3或者4"</span></span><br><span class="line">    ;;</span><br><span class="line">    ok) <span class="built_in">echo</span> <span class="string">"字符串ok"</span></span><br><span class="line">    ;;</span><br><span class="line">    *) <span class="built_in">echo</span> <span class="string">"其他内容"</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>shell当中可以自定义函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">myFunc</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"参数 <span class="variable">$1</span>,<span class="variable">$2</span>,<span class="variable">$3</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"所有参数:"</span></span><br><span class="line">  <span class="keyword">for</span> arg <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$arg</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line">myFunc <span class="string">"aa"</span> <span class="string">"bb"</span></span><br></pre></td></tr></table></figure></p><blockquote><p><strong>说明</strong> : </p><ol><li>与获取脚本的参数类似 , 使用<code>$序号</code>或者<code>${序号}</code>来获取<br>但是如果到了10 , 就必须写作<code>${10}</code> , 否则会与$1产生歧义</li><li><code>function</code> 关键字也可以省略</li></ol></blockquote><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>一个shell脚本当中可以引入另一个shell脚本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">. /home/sookie/test2.sh</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">source</span> /home/sookie/test2.sh</span><br></pre></td></tr></table></figure></p><p>被引入的文件并不需要可执行权限</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;判断&quot;&gt;&lt;a href=&quot;#判断&quot; class=&quot;headerlink&quot; title=&quot;判断&quot;&gt;&lt;/a&gt;判断&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; condition1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  command1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; condition2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  command2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  command3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果else没有语句执行&lt;br&gt;则不能留空 , 最好直接不写这个else&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="https://sookie2010.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://sookie2010.github.io/tags/linux/"/>
    
      <category term="shell" scheme="https://sookie2010.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>2.0、shell编程(1)-初见</title>
    <link href="https://sookie2010.github.io/linux/2.0%E3%80%81shell%E7%BC%96%E7%A8%8B(1)-%E5%88%9D%E8%A7%81/"/>
    <id>https://sookie2010.github.io/linux/2.0、shell编程(1)-初见/</id>
    <published>2018-03-05T14:38:32.000Z</published>
    <updated>2018-05-21T00:48:43.778Z</updated>
    
    <content type="html"><![CDATA[<p><code>shell</code>俗称为<strong>壳</strong> , 是指提供使用者使用界面的软件<br>也叫做命令解析器<br>接收用户的命令 , 然后调用相应的应用程序<br>(接收命令的方式可以是命令行 , 也可以是图形界面)<br><a id="more"></a><br>在linux发展过程中 , 出现过很多的shell</p><ul><li><code>sh</code>(全称 Bourne Shell): 是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。<br>Bourne Shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell。</li><li><code>bash</code>（全称 Bourne Again Shell）: LinuxOS 默认的，它是 Bourne Shell 的扩展。<br>与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。</li><li><code>csh</code>(全称 C Shell): 是一种比 Bourne Shell更适合的变种 Shell，它的语法与 C 语言很相似。<br>Tcsh: 是 Linux 提供的 C Shell 的一个扩展版本。<br>Tcsh 包括命令行编辑，可编程单词补全，拼写校正，历史命令替换，作业控制和类似 C 语言的语法，他不仅和 Bash Shell 提示符兼容，而且还提供比 Bash Shell 更多的提示符参数。</li><li><code>ksh</code> (全称 Korn Shell): 集合了 C Shell 和 Bourne Shell 的优点并且和 Bourne Shell 完全兼容。</li><li><code>pdksh</code>: 是 Linux 系统提供的 ksh 的扩展。</li><li><code>pdksh</code> 支持人物控制，可以在命令行上挂起，后台执行，唤醒或终止程序。</li></ul><hr><ul><li><strong>交互式shell</strong> : 等待用户的命令 , 提交后就立即执行该命令</li><li><strong>非交互式shell</strong> : 不等待用户的输入 , 而是去读取写在文件中的命令代码 , 并且执行 , 这个文件就被称为shell脚本</li></ul><blockquote><p><strong>脚本</strong>其实就是短小的、用来让计算机自动化完成一系列工作的程序，这类程序可以用文本编辑器修改，不需要编译，通常是解释运行的。</p></blockquote><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>test.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World!"</span></span><br></pre></td></tr></table></figure></p><p>echo就是对传入的参数直接进行输出的程序<br>这个脚本的作用就是执行该命令<br><code>#!</code>是一个约定的标记 , 它告诉系统这个脚本要用什么解释器来执行</p><p>之后需要给这个文件加上可执行权限<br><code>chmod +x test.sh</code><br>然后就可以执行该脚本了<br><code>./test.sh</code></p><p>当然如果这样执行 , 是根据脚本内容中指定的解释器运行<br>如果没有指定 , 则使用系统默认的<br>我们也可以在运行时指定使用某个解释器<br>比如<code>sh test.sh</code></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>命名规则是可以包含 字母 数字 下划线 , 且以字母或者数字开头<br>使用变量则是在前面加<code>$</code>或者用<code>${}</code><br>( 当然如果在字符串内部使用 , 为了防止歧义, 必须用${} )<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">"sookie"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"my name is <span class="variable">$&#123;name&#125;</span>123"</span></span><br><span class="line"><span class="comment"># 大括号是为了帮助解释器识别变量名称的边界</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将该变量设为只读, 之后若再赋值就会报错</span></span><br><span class="line"><span class="built_in">readonly</span> name</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong> : 等号的两端不能加空格</p><h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>使用<code>unset 变量名称</code>可以删除对应的变量</p><blockquote><p>按照上面方式定义的变量实际上是这个shell脚本当中的<strong>局部变量</strong><br>在操作系统当中可以设置<strong>环境变量</strong> , 所有的shell脚本当中都可以直接使用</p></blockquote><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串的边界可以是单引号也可以是双引号 也可以无引号 , 但是实际应用当中有一些区别</p><ul><li><code>单引号</code>当中的内容都会原样输出 , 不可以使用转义字符 , 不可以使用字符串模板</li><li><code>双引号</code>当中的内容可以使用转义字符 , 也可以使用字符串模板</li><li><code>无引号</code>不可以使用转义字符 , 但是可以使用字符串模板<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">"sookie"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'my name is $&#123;name&#125;1'</span></span><br><span class="line"><span class="comment"># output: my name is $&#123;name&#125;1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"my name is <span class="variable">$&#123;name&#125;</span>1"</span></span><br><span class="line"><span class="comment"># output: my name is sookie1</span></span><br><span class="line"><span class="built_in">echo</span> my name is <span class="variable">$&#123;name&#125;</span>1</span><br><span class="line"><span class="comment"># output: my name is sookie1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><p>shell当中字符串的拼接不需要用加号<br>直接写在一起即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">"sookie"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'my name is '</span><span class="variable">$&#123;name&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取字符串长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#name&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#截取子串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;name:1:3&#125;</span> <span class="comment">#输出 ook</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将字符串内容当做命令执行</span></span><br><span class="line"><span class="built_in">echo</span> `ls /usr/<span class="built_in">local</span>`</span><br></pre></td></tr></table></figure></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>同大多数解释型语言一样 , 对于数组并没有严格的越界限制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数组定义, 元素之间用空白分割</span></span><br><span class="line">arr=(1 <span class="string">"aa"</span> 2.6)</span><br><span class="line"></span><br><span class="line"><span class="comment">#超出当前数组边界的下标形式赋值, 会将元素追加至末尾</span></span><br><span class="line">arr[6]=<span class="string">"bb"</span> <span class="comment">#当前数组当中有4个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取数组长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#arr[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#遍历数组</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable">$&#123;arr[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;item&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除数组元素</span></span><br><span class="line"><span class="built_in">unset</span> arr[1]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;shell&lt;/code&gt;俗称为&lt;strong&gt;壳&lt;/strong&gt; , 是指提供使用者使用界面的软件&lt;br&gt;也叫做命令解析器&lt;br&gt;接收用户的命令 , 然后调用相应的应用程序&lt;br&gt;(接收命令的方式可以是命令行 , 也可以是图形界面)&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="https://sookie2010.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://sookie2010.github.io/tags/linux/"/>
    
      <category term="shell" scheme="https://sookie2010.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>2.1、shell编程(2)-从入门到重新入门</title>
    <link href="https://sookie2010.github.io/linux/2.1%E3%80%81shell%E7%BC%96%E7%A8%8B(2)-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8/"/>
    <id>https://sookie2010.github.io/linux/2.1、shell编程(2)-从入门到重新入门/</id>
    <published>2018-03-04T16:52:22.000Z</published>
    <updated>2018-05-21T00:48:43.778Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>在外部执行时可以给脚本传参<br>在脚本当中获取时 , <code>$0</code>是执行的文件路径<br><code>$1</code>代表第一个参数 , <code>$2</code>代表第二个参数 , 以此类推<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"当前文件:<span class="variable">$0</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第一个参数:<span class="variable">$1</span>"</span></span><br><span class="line"><span class="comment">#参数个数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"共传入<span class="variable">$#</span>个参数"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#遍历所有的参数</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$arg</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#脚本运行进程的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PID:$$"</span></span><br></pre></td></tr></table></figure></p><p>执行脚本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./test.sh aa bb</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果参数内容包含空白, 要加引号才能作为一个参数传递</span></span><br><span class="line">./test.sh aa <span class="string">"bb cc"</span></span><br></pre></td></tr></table></figure></p><h4 id="变量的判断"><a href="#变量的判断" class="headerlink" title="变量的判断"></a>变量的判断</h4><p>对于shell脚本来说 , 传参通常是比较灵活的<br>所以经常需要判断是否传入了这个参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"包含第一个参数"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"未包含第一个参数"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>这是判断某个变量是否有值的方式<br>因为解释型语言的语法比较松散 , 对于变量先定义后使用没有严格要求<br>所以直接使用一个变量而不进行检查可能造成灾难性的后果</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>原生bash对数学运算的支持比较有限</p><h5 id="方法1-expression"><a href="#方法1-expression" class="headerlink" title="方法1 $((expression))"></a>方法1 <code>$((expression))</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num1=3</span><br><span class="line">num2=4</span><br><span class="line"><span class="built_in">echo</span> $((num1+num2))</span><br><span class="line"><span class="built_in">echo</span> $((num1**num2)) <span class="comment">#乘方</span></span><br></pre></td></tr></table></figure><p>变量的引用加不加$都可以 , 不能计算浮点数</p><h5 id="方法2-expression"><a href="#方法2-expression" class="headerlink" title="方法2 $[expression]"></a>方法2 <code>$[expression]</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1=3</span><br><span class="line">num2=4</span><br><span class="line"><span class="built_in">echo</span> $[num1+num2]</span><br></pre></td></tr></table></figure><p>变量的引用加不加$都可以 , 不能计算浮点数</p><h5 id="方法3-let关键字"><a href="#方法3-let关键字" class="headerlink" title="方法3 let关键字"></a>方法3 <code>let</code>关键字</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num1=3</span><br><span class="line">num2=4</span><br><span class="line"><span class="built_in">let</span> sum=<span class="variable">$num1</span>+<span class="variable">$num2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$sum</span></span><br></pre></td></tr></table></figure><p>变量的引用加不加$都可以 , 不能计算浮点数 , 加号两端不能有空格</p><h5 id="方法4-使用expr"><a href="#方法4-使用expr" class="headerlink" title="方法4 使用expr"></a>方法4 使用<code>expr</code></h5><p>这是一个内建的用于数学运算的命令<br>需要注意的是运算符两边必须要有空格<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">expr 2 + 6</span><br><span class="line">expr 4 - 9</span><br><span class="line"><span class="comment">#注意为了防止歧义 乘法要写 \* 而不能直接写 *</span></span><br><span class="line">expr 5 \* 4</span><br><span class="line"><span class="comment">#除法保留整数</span></span><br><span class="line">expr 9 / 2</span><br><span class="line"><span class="comment">#取余</span></span><br><span class="line">expr 9 % 2</span><br><span class="line"></span><br><span class="line"><span class="comment">#浮点数计算</span></span><br><span class="line">expr <span class="string">"3.9 + 1.8"</span>|bc</span><br><span class="line"><span class="comment">#scale表示保留到的小数位数</span></span><br><span class="line">expr <span class="string">"scale=3;1.2 * 8.73"</span>|bc</span><br></pre></td></tr></table></figure></p><h4 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h4><p>bash当中原生支持关系运算</p><p>比较是否相等<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"相等"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"不相等"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th>运算符</th><th>含义</th><th>其他表示方式</th><th>备注</th></tr></thead><tbody><tr><td>-eq</td><td>是否相等</td><td>==</td><td></td></tr><tr><td>-ne</td><td>是否不相等</td><td>!=</td><td></td></tr><tr><td>-gt</td><td>大于</td><td>&gt;</td><td></td></tr><tr><td>-lt</td><td>小于</td><td>&lt;</td><td></td></tr><tr><td>-ge</td><td>大于等于</td><td>>=</td><td>使用>=需要使用(( ))</td></tr><tr><td>-le</td><td>小于等于</td><td>&lt;=</td><td>使用&lt;=需要使用(( ))</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -ge <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"大于等于"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 等价于上面的写法, 注意用(( ))</span></span><br><span class="line"><span class="keyword">if</span> (( <span class="variable">$a</span> &gt;= <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"大于等于"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><blockquote><p>关系运算符只能用于整数 , 或者能够解析为整数的字符串</p></blockquote><h4 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h4><table><thead><tr><th>运算符</th><th>含义</th><th>其他表示方式</th></tr></thead><tbody><tr><td>!</td><td>非</td><td></td></tr><tr><td>-o</td><td>或</td><td>&#124;&#124;</td></tr><tr><td>-a</td><td>与</td><td>&amp;&amp;</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a小于10 并且 b大于20</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 10 -a <span class="variable">$b</span> -gt 20 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"yes"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"no"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 与上面的含义相同, 但是注意使用[[ ]]</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> -lt 10 &amp;&amp; <span class="variable">$b</span> -gt 20 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"yes"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"no"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong><br>推荐使用 <code>[[ ... ]]</code> 条件判断结构，而不是 <code>[ ... ]</code>，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、|| 操作符能够正常存在于 [[ ]] 条件判断结构中，但是如果出现在 [ ] 结构中的话，会报错。</p></blockquote><h4 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h4><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>=</td><td>两个字符串是否相同(区别于数字的比较)</td></tr><tr><td>!=</td><td>两个字符串是否不相同</td></tr><tr><td>-z</td><td>字符串长度为0返回true</td></tr><tr><td>-n</td><td>字符串长度不为0返回true</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"123"</span></span><br><span class="line">b=<span class="string">"456"</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> = <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"相同"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"不同"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 字符串本身也可以用作判断条件</span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="variable">$a</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"字符串为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>使用<code>-n</code>和<code>-z</code>的时候需要注意 , 需要在字符串变量引用上加双引号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$a</span>"</span>]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"OK"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>如果不加双引号 , 当a为空的时候 , 相当于执行<br><code>if [ -n ]</code> , 这个时候会把里面的<strong>-n</strong>当做一个普通字符串来处理 , 而不是运算符<br>自然每次都会是true , <strong>-z</strong> 同理</p><h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><p>一个字符串也可以表示一个文件(目录)的路径<br>使用这些方式可以获得这个文件的各种信息</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于0），不为空返回 true</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filepath=/usr/<span class="built_in">local</span>/test.txt</span><br><span class="line"><span class="keyword">if</span> [ -e filepath ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"文件存在"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"文件不存在"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;传参&quot;&gt;&lt;a href=&quot;#传参&quot; class=&quot;headerlink&quot; title=&quot;传参&quot;&gt;&lt;/a&gt;传参&lt;/h3&gt;&lt;p&gt;在外部执行时可以给脚本传参&lt;br&gt;在脚本当中获取时 , &lt;code&gt;$0&lt;/code&gt;是执行的文件路径&lt;br&gt;&lt;code&gt;$1&lt;/code&gt;代表第一个参数 , &lt;code&gt;$2&lt;/code&gt;代表第二个参数 , 以此类推&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="https://sookie2010.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://sookie2010.github.io/tags/linux/"/>
    
      <category term="shell" scheme="https://sookie2010.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>7.0、使用浏览器访问MongoDB</title>
    <link href="https://sookie2010.github.io/MongoDB/7.0%E3%80%81%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEMongoDB/"/>
    <id>https://sookie2010.github.io/MongoDB/7.0、使用浏览器访问MongoDB/</id>
    <published>2018-02-16T12:42:18.000Z</published>
    <updated>2018-05-21T00:48:43.778Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB可以开启一个HTTP协议的端口提供REST服务 , 这个端口是数据库的服务端口加1000<br>比如数据库的服务端口是27017<br>那么开启REST服务之后 , 通过浏览器访问的端口就是28017<br><a id="more"></a><br>配置方式</p><ul><li><code>httpinterface</code> - 置为true表示开启HTTP协议端口</li><li><code>rest</code> - 置为true表示开启rest服务</li></ul><p>REST是mongoDB自带的一套API , 可以提供查询 , 但是不支持增删改操作 , 也不支持权限认证</p><p>配置完成之后重启服务 , 即可直接使用浏览器访问<br><img src="/images/MongoDB/browser.png" alt="browser"><br>在主页面可以查看到数据库的一些基本情况</p><hr><h4 id="执行查询操作"><a href="#执行查询操作" class="headerlink" title="执行查询操作"></a>执行查询操作</h4><p>列出databaseName数据库中的collectionName集合下的所有数据：<br><code>http://127.0.0.1:28017/databaseName/collectionName/</code><br>给上面的数据集添加一个limit参数限制返回10条<br><code>http://127.0.0.1:28017/databaseName/collectionName/?limit=-10</code><br>给上面的数据加上一个skip参数设定跳过5条记录<br><code>http://127.0.0.1:28017/databaseName/collectionName/?skip=5</code><br>同时加上limit限制和skip限制<br><code>http://127.0.0.1:28017/databaseName/collectionName/?skip=5&amp;limit=10</code><br>按条件{a:1}进行结果筛选（在关键字filter后面接上你的字段名）<br><code>http://127.0.0.1:28017/databaseName/collectionName/?filter_a=1</code><br>加条件的同时再加上limit限制返回条数<br><code>http://127.0.0.1:28017/databaseName/collectionName/?filter_a=1&amp;limit=-10</code><br>执行任意命令<br>如果要执行特定的命令，可以通过在admin.$cmd上面执行find命令，同样的你也可以在REST API里实现，如下，执行{listDatabase:1}命令：<br><code>http://localhost:28017/admin/$cmd/?filter_listDatabases=1&amp;limit=1</code><br>查询集合的记录个数：<code>http://host:port/db/$cmd/?filter_count=collection&amp;limit=1</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB可以开启一个HTTP协议的端口提供REST服务 , 这个端口是数据库的服务端口加1000&lt;br&gt;比如数据库的服务端口是27017&lt;br&gt;那么开启REST服务之后 , 通过浏览器访问的端口就是28017&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://sookie2010.github.io/categories/MongoDB/"/>
    
    
      <category term="数据库" scheme="https://sookie2010.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MongoDB" scheme="https://sookie2010.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>6.1、快速搭建复制集</title>
    <link href="https://sookie2010.github.io/MongoDB/6.1%E3%80%81%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%A4%8D%E5%88%B6%E9%9B%86/"/>
    <id>https://sookie2010.github.io/MongoDB/6.1、快速搭建复制集/</id>
    <published>2018-02-11T11:47:03.000Z</published>
    <updated>2018-05-21T00:48:43.778Z</updated>
    
    <content type="html"><![CDATA[<p>在一个复制集当中 , 每个节点都需要具备独立的进程 , 所以要分别进行配置<br>这里需要用到几个重要的配置项<br><a id="more"></a></p><ul><li><code>replSet</code> - 复制集的名称 , 不同节点设置的复制集名称必须一致 , 才能保证这些节点被加入到同一个复制集当中</li><li><code>oplogSize</code> - 复制集的缓存大小 , 单位MB<br>( 不同的节点之间是通过oplog进行同步的 )</li></ul><p>当然 , 如果要在一台机器上模拟一个复制集 , 对于每个节点的实例需要配置不同的端口号</p><p>步骤</p><ol><li>编写配置文件 , 并启动多个实例</li><li>连接其中一个节点 , 执行配置<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">config = &#123;</span><br><span class="line">  _id:<span class="string">"TestReplSet"</span>,<span class="comment">//复制集的唯一标识</span></span><br><span class="line">  members:[</span><br><span class="line">  <span class="comment">//复制集当中的成员</span></span><br><span class="line">    &#123;<span class="attr">_id</span>:<span class="number">0</span>,<span class="attr">host</span>:<span class="string">"127.0.0.1:28001"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">_id</span>:<span class="number">1</span>,<span class="attr">host</span>:<span class="string">"127.0.0.1:28002"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">_id</span>:<span class="number">2</span>,<span class="attr">host</span>:<span class="string">"127.0.0.1:28003"</span>,</span><br><span class="line">    arbiterOnly:<span class="literal">true</span></span><br><span class="line">    <span class="comment">//置为仲裁节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里是相当于定义了一个名为config的全局变量<br><strong>其他的节点配置项</strong></p><blockquote><ul><li><code>priority</code> - 值为整数 ( 0~1000 ) , 默认是1 , 代表这个节点的权重 , 也就是成为主节点的机会 , 如果是0则永远不会成为主节点</li><li><code>hidden</code>  - 是否是隐藏节点 , true/false , 如果设置为true , 那么priority必须是0</li><li><code>vote</code> - 整数值 , 该节点是否具有投票权 , 值为0或1</li><li><code>slaveDelay</code> - 整数值 , 延迟时间复制数据 , 单位是秒 ( 对于一些误操作 , 可以利用延时挽回数据的损失 )</li></ul></blockquote><ol start="3"><li>执行复制集的初始化<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure></li></ol><p>稍等片刻即可完成复制集的搭建了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个复制集当中 , 每个节点都需要具备独立的进程 , 所以要分别进行配置&lt;br&gt;这里需要用到几个重要的配置项&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://sookie2010.github.io/categories/MongoDB/"/>
    
    
      <category term="数据库" scheme="https://sookie2010.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MongoDB" scheme="https://sookie2010.github.io/tags/MongoDB/"/>
    
      <category term="集群" scheme="https://sookie2010.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>6.0、复制集</title>
    <link href="https://sookie2010.github.io/MongoDB/6.0%E3%80%81%E5%A4%8D%E5%88%B6%E9%9B%86/"/>
    <id>https://sookie2010.github.io/MongoDB/6.0、复制集/</id>
    <published>2018-02-11T11:45:02.000Z</published>
    <updated>2018-05-21T00:48:43.778Z</updated>
    
    <content type="html"><![CDATA[<p>复制集是由一组拥有相同数据集的mongod实例所组成的<code>集群</code><br><a id="more"></a><br>在这个复制集集群当中 , 各个节点可能有以下几种状态</p><ul><li><code>Primary</code> 主节点，一个复制集至多有一个节点处于Primary状态，只有主节点才对外提供读写服务。如果主节点挂掉，复制集将会投票选出一个备用节点成为新的主节点。</li><li><code>Secondary</code> 备用节点，复制集允许有多个备用节点，每个备用节点的数据与主节点的数据是完全同步的。</li><li><code>Recovering</code> 恢复中，当复制集中某台服务器挂掉或者掉线后数据无法同步，重新恢复服务后从其他成员复制数据，这时就处于恢复过程，数据同步后，该节点又回到备用状态。</li><li><code>Arbiter</code> 仲裁节点，该类节点可以不用单独存在，如果配置为仲裁节点，就主要负责在复本集中监控其他节点状态，投票选出主节点。该节点将不会用于存放数据。如果没有仲裁节点，那么投票工作将由所有节点共同进行。</li><li><code>Down</code> 无效节点，当服务器挂掉或掉线时就会处于该状态。</li></ul><p>复制集就是通过在备用节点上备份数据来提高数据库的可靠性<br>主节点会把所有的<strong>写操作</strong>记录到<code>oplog</code>当中<br>( 包括所有的增删改操作 )<br>备用节点通过oplog来进行数据的同步</p><blockquote><p>对于mysql的集群部署 , 拥有super权限的用户可以在备用节点执行写入操作 , mongoDB的备用节点是绝对不可以进行写操作的<br>而且mysql的集群可以拥有双主结构</p></blockquote><p>对于<strong>读操作</strong> , 默认情况下都是指向主节点的 , 虽然备用节点也在实时更新数据 , 但数据相对主节点来说也是有可能滞后的<br>如果对数据的时效性要求不是特别严格 , 也可以把读操作指向备用节点 , 从而分担主节点的压力</p><p>MongoDB复制集的特点</p><ul><li><strong>数据一致性</strong> - 主节点在一个集群中至多有一个 , 但并不是固定的 , 但可以设定节点的优先级 , 让一个性能更好的节点优先成为主节点</li><li><strong>大多数原则 ( 二分之一原则 )</strong> - 集群存活节点小于等于二分之一的时候 , 集群不可写 , 只可读<br>也就是说 , 能否选举出新的主节点 , 是由当前复制集成员的存活数量来决定的<br>即使之前的主节点正常工作 , 备用节点挂掉的过多 , 这个主节点也会自动降级为备用节点</li><li><strong>备用节点无法写入</strong> - 在备用节点写入数据有造成主键冲突的可能性</li><li><strong>自动容灾</strong> - 主节点挂掉以后 , 会自动从备用节点中选举出一个主节点</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复制集是由一组拥有相同数据集的mongod实例所组成的&lt;code&gt;集群&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://sookie2010.github.io/categories/MongoDB/"/>
    
    
      <category term="数据库" scheme="https://sookie2010.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MongoDB" scheme="https://sookie2010.github.io/tags/MongoDB/"/>
    
      <category term="集群" scheme="https://sookie2010.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>3.3、Docker(3)-部署wordpress实践</title>
    <link href="https://sookie2010.github.io/linux/3.3%E3%80%81Docker(3)-WordPress%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5/"/>
    <id>https://sookie2010.github.io/linux/3.3、Docker(3)-WordPress部署实践/</id>
    <published>2018-02-10T14:38:32.000Z</published>
    <updated>2018-05-21T00:48:43.788Z</updated>
    
    <content type="html"><![CDATA[<p>站在 Docker 的角度，软件就是容器的组合：业务逻辑容器、数据库容器、储存容器、队列容器……Docker 使得软件可以拆分成若干个标准化容器，然后像搭积木一样组合起来。</p><p>这正是微服务（microservices）的思想：软件把任务外包出去，让各种外部服务完成这些任务，软件本身只是底层服务的调度中心和组装层。<br><a id="more"></a><br><img src="/images/linux/20180505231057.png" alt="微服务"></p><p>微服务很适合用 Docker 容器实现，每个容器承载一个服务。一台计算机同时运行多个容器，从而就能很轻松地模拟出复杂的微服务架构。</p><p><img src="/images/linux/20180505231120.png" alt="应用解耦"></p><p>现在尝试实践搭建一个wordpress的服务<br>这是一个php编写的博客系统</p><p>运行需要依赖的环境有 : mysql  php  apache<br>当然也包括php的扩展包mysqli , 用于实现mysql数据库的连接</p><h3 id="自建wordpress容器"><a href="#自建wordpress容器" class="headerlink" title="自建wordpress容器"></a>自建wordpress容器</h3><h4 id="尝试启动一个php-apache容器"><a href="#尝试启动一个php-apache容器" class="headerlink" title="尝试启动一个php-apache容器"></a>尝试启动一个php-apache容器</h4><p>创建应用目录 php-demo , 然后进入该目录执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">-d \</span><br><span class="line">--rm \</span><br><span class="line">--name wordpress \</span><br><span class="line">--volume <span class="string">"<span class="variable">$PWD</span>/"</span>:/var/www/html \</span><br><span class="line">php:7.2-apache</span><br></pre></td></tr></table></figure></p><blockquote><p>linux当中 , 命令末尾的<code>\</code>代表换行继续输入命令 , 而不立即执行</p></blockquote><ul><li><code>-d</code> : 容器在后台运行 , 输出内容不会打印到终端(可以用docker logs [ContainerId]查看)</li><li><code>--rm</code> : 容器运行停止后 , 自动删除容器文件</li><li><code>--name</code> : 指定容器的名字</li><li><code>--volume</code> : 指定目录映射 , 这里表示把当前目录映射到容器内的/var/www/html目录<br>这个目录是apache服务器对外访问的默认目录<br>这样我们就可以直接在当前目录中添加php页面文件进行访问</li></ul><p>成功从远程仓库下载<strong>php:7.2-apache</strong>镜像并启动容器之后<br>会提示容器对外访问的IP地址 , 比如<strong>172.17.0.2</strong> , 可以直接访问这个地址</p><p>但是此时还没有在访问目录中添加php页面<br>可以写个测试页面index.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>此时再访问就可以看到php信息了</p><h4 id="安装wordpress"><a href="#安装wordpress" class="headerlink" title="安装wordpress"></a>安装wordpress</h4><p>删掉index.php<br>官网下载wordpress安装包 , 直接解压到该目录下<br>然后访问就可以看到wordpress的初始化页面了<br><img src="/images/linux/wordpress_init.png" alt="wordpress_init"><br>但是目前还没有mysql的容器</p><h4 id="运行mysql容器"><a href="#运行mysql容器" class="headerlink" title="运行mysql容器"></a>运行mysql容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">-d \</span><br><span class="line">--rm \</span><br><span class="line">--name wordpressdb \</span><br><span class="line">--env MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--env MYSQL_DATABASE=wordpress \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p><code>env</code>代表向容器中传入的环境变量 , 容器中的mysql会根据环境变量创建数据库以及设置root用户的密码</p><h4 id="添加mysqli扩展"><a href="#添加mysqli扩展" class="headerlink" title="添加mysqli扩展"></a>添加mysqli扩展</h4><p>PHP 的官方 image 不带有 mysqli 扩展，必须自己新建一个image</p><p>新建<code>Dockerfile</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM php:7.2-apache</span><br><span class="line">RUN docker-php-ext-install mysqli</span><br><span class="line">CMD apache2-foreground</span><br></pre></td></tr></table></figure></p><p>打包镜像时安装mysqli的扩展 , 运行容器时启动apache<br>之后构建image<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t php-with-mysql .</span><br></pre></td></tr></table></figure></p><h4 id="运行php-with-mysql"><a href="#运行php-with-mysql" class="headerlink" title="运行php-with-mysql"></a>运行php-with-mysql</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">-d \</span><br><span class="line">--rm \</span><br><span class="line">--volume <span class="string">"<span class="variable">$PWD</span>/"</span>:/var/www/html \</span><br><span class="line">--link wordpressdb:mysqlhost \</span><br><span class="line">php-with-mysql</span><br></pre></td></tr></table></figure><p>link是实现容器之间通信的一种机制 , 表示该容器要链接到<strong>wordpressdb</strong>容器 , 冒号表示该容器主机的名称是<strong>mysqlhost</strong><br>(之后配置数据库连接时 , 主机名称不是localhost , 而是<strong>mysqlhost</strong>)</p><p>由于wordpress在运行时需要写入配置文件( 也包括自身版本的更新 )<br>我们可以给当前目录添加写权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 ./</span><br></pre></td></tr></table></figure></p><p>之后再访问172.17.0.2 , 填写数据库配置信息即可完成</p><h3 id="使用wordpress官方镜像"><a href="#使用wordpress官方镜像" class="headerlink" title="使用wordpress官方镜像"></a>使用wordpress官方镜像</h3><p>首先仍然是要启动mysql的容器 , 参考上面的<strong>运行mysql容器</strong><br>然后使用wordpress的官方镜像构建容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">-d \</span><br><span class="line">--rm \</span><br><span class="line">--name wordpress \</span><br><span class="line">--env WORDPRESS_DB_PASSWORD=123456 \</span><br><span class="line">--link wordpressdb:mysqlhost \</span><br><span class="line">wordpress</span><br></pre></td></tr></table></figure></p><p>环境变量<code>WORDPRESS_DB_PASSWORD</code>是 MySQL 容器的根密码<br>运行之后的访问和初始化操作和前一种方式相同</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;站在 Docker 的角度，软件就是容器的组合：业务逻辑容器、数据库容器、储存容器、队列容器……Docker 使得软件可以拆分成若干个标准化容器，然后像搭积木一样组合起来。&lt;/p&gt;
&lt;p&gt;这正是微服务（microservices）的思想：软件把任务外包出去，让各种外部服务完成这些任务，软件本身只是底层服务的调度中心和组装层。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="https://sookie2010.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://sookie2010.github.io/tags/linux/"/>
    
      <category term="docker" scheme="https://sookie2010.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>3.2、Docker(2)-使用技巧</title>
    <link href="https://sookie2010.github.io/linux/3.2%E3%80%81Docker(2)-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://sookie2010.github.io/linux/3.2、Docker(2)-使用技巧/</id>
    <published>2018-02-09T14:38:32.000Z</published>
    <updated>2018-05-21T00:48:43.788Z</updated>
    
    <content type="html"><![CDATA[<h3 id="与宿主机共享网络"><a href="#与宿主机共享网络" class="headerlink" title="与宿主机共享网络"></a>与宿主机共享网络</h3><p>默认情况下 , 在宿主机可以根据容器暴露出的端口来访问容器中启动的服务<br>但是由于容器的隔离 , 在容器内部是无法访问宿主机的服务的<br>如果有这种需要 , 可以在启动容器的时候添加参数<code>--net=host</code></p><p>作用就是使容器和宿主机共用网络<br><a id="more"></a></p><h3 id="镜像的备份与恢复"><a href="#镜像的备份与恢复" class="headerlink" title="镜像的备份与恢复"></a>镜像的备份与恢复</h3><p>docker的一个重要目标就是方便实现迁移<br>对于一个镜像 , 也可以打包出来作为备份 , 或者迁移到其他机器上</p><p>对于镜像的导出与导入操作 , 使用的是<code>save</code>和<code>load</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line">docker save -o dump.tar [ImageId]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复</span></span><br><span class="line">docker load &lt; dump.tar</span><br></pre></td></tr></table></figure></p><blockquote><p>继承的镜像也会一同打包进去<br>再次导入之后 , 该镜像就不再作为一个子镜像存在了<br>比如该镜像继承jre镜像 , 那么打包之后的tar包当中直接包含jre镜像的内容</p></blockquote><h3 id="容器的导出与导入"><a href="#容器的导出与导入" class="headerlink" title="容器的导出与导入"></a>容器的导出与导入</h3><p>要将一个容器进行导出与导入 , 使用的是<code>export</code>和<code>import</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出容器</span></span><br><span class="line">docker <span class="built_in">export</span> [ContainerId] &gt; demo.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入容器</span></span><br><span class="line">docker import demo.tar [ImageName][:Tag]</span><br></pre></td></tr></table></figure></p><h3 id="容器内时区的错误"><a href="#容器内时区的错误" class="headerlink" title="容器内时区的错误"></a>容器内时区的错误</h3><p>如果容器当中的程序在执行中需要获取当前时间并进行格式化<br>若没有特别指定 , 通常会读取操作系统的时区设定<br>由于容器内是一个独立的环境 , 这个设定有可能不正确</p><p>如果出现这类错误( 比如程序获取当前时间写入到数据库 , 时间提前了8小时 )<br>可以在构建镜像的时候执行如下命令 , 来指定容器内的时区<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone</span><br></pre></td></tr></table></figure></p><p>也就是设定时区为东八区</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;与宿主机共享网络&quot;&gt;&lt;a href=&quot;#与宿主机共享网络&quot; class=&quot;headerlink&quot; title=&quot;与宿主机共享网络&quot;&gt;&lt;/a&gt;与宿主机共享网络&lt;/h3&gt;&lt;p&gt;默认情况下 , 在宿主机可以根据容器暴露出的端口来访问容器中启动的服务&lt;br&gt;但是由于容器的隔离 , 在容器内部是无法访问宿主机的服务的&lt;br&gt;如果有这种需要 , 可以在启动容器的时候添加参数&lt;code&gt;--net=host&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;作用就是使容器和宿主机共用网络&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="https://sookie2010.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://sookie2010.github.io/tags/linux/"/>
    
      <category term="docker" scheme="https://sookie2010.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>3.1、Docker(1)-初见</title>
    <link href="https://sookie2010.github.io/linux/3.1%E3%80%81Docker(1)-%E5%88%9D%E8%A7%81/"/>
    <id>https://sookie2010.github.io/linux/3.1、Docker(1)-初见/</id>
    <published>2018-02-08T14:38:32.000Z</published>
    <updated>2018-05-21T00:48:43.788Z</updated>
    
    <content type="html"><![CDATA[<p><strong>程序部署运维的痛点</strong><br>当今软件越发庞大复杂 , 在服务器部署运行一个软件之前通常需要完成:</p><ol><li>操作系统的设置</li><li>各种库和组件的安装</li></ol><p>只有他们都正确 , 软件才能正常运行<br>当需要迁移的时候 , 这些事情都要重来一遍<br>并且由于各种原因 , 还可能会产生不一样的问题 , 费时费力<br><a id="more"></a><br>于是就有了独立运行容器的需求 , 从根本上解决这个问题<br>让软件带环境安装<br>给软件一个独立的环境去运行 , 并且这个软件所有的依赖都在这个环境里面</p><p><strong>虚拟机</strong><br>虚拟机是一种针对上述问题的解决方案 , 在一个操作系统里面构造一个虚拟环境运行另一个操作系统<br>但是通常会有以下缺陷</p><ol><li><p>资源占用多<br>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p></li><li><p>冗余步骤多<br>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p></li><li><p>启动慢<br>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p></li></ol><p><strong>Docker</strong><br>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器<br>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行</p><p>ubuntu系统直接使用apt安装即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install docker.io</span><br></pre></td></tr></table></figure></p><h3 id="镜像-image"><a href="#镜像-image" class="headerlink" title="镜像(image)"></a>镜像(image)</h3><p>docker把程序及其依赖 , 打包在image文件里面 , 称之为镜像文件<br>它可以看做是生成容器的模板 , 一个镜像文件可以生成多个运行容器实例<br>使用<code>docker image COMMAND</code>可以实现对镜像的相关操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本机所有的镜像</span></span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定镜像</span></span><br><span class="line">docker image rm [ImageId]</span><br></pre></td></tr></table></figure><p><img src="/images/linux/查看所有镜像.png" alt="查看所有镜像"><br>每个镜像都有一个唯一ID , 是一串hash码<br>我们可以根据这个ID来对指定的镜像进行操作<br>当然也不需要必须写完整 , 只要能找到一个唯一的镜像就可以了<br>比如执行<code>docker image rm 56a</code>就可以删除掉express-demo这个镜像了<br>当然使用<code>docker image rm express-demo</code>也是可以的</p><blockquote><p>docker中的操作大都是这种模式</p></blockquote><h3 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h3><p>容器就是程序运行的独立虚拟环境了 , 容器由镜像生成<br>( 镜像可以认为是一种存储的结构 , 而容器才是实际运行的实例 )<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看运行中的容器</span></span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行指定的镜像</span></span><br><span class="line">docker container run [ImageId]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行指定的容器</span></span><br><span class="line">docker container start [ContainerId]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止指定的镜像</span></span><br><span class="line">docker container stop [ContainerId]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行终止指定的镜像</span></span><br><span class="line">docker container <span class="built_in">kill</span> [ContainerId]</span><br></pre></td></tr></table></figure></p><p>使用<code>run</code>每次都会生成一个新的容器文件 , 如果要复用指定的容器 , 可以使用<code>start</code></p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>这是一个官方提供的最简单的镜像 , 可以用来熟悉docker的基本用法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从官方仓库拉取镜像</span></span><br><span class="line">docker image pull hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行这个image</span></span><br><span class="line">docker container run hello-world</span><br></pre></td></tr></table></figure></p><blockquote><p><code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤</p></blockquote><p>这个镜像当中的程序就是在控制台输出一段内容 , 是docker的一些基本介绍</p><blockquote><p>image文件生成的容器实例, 本身也是一个文件<br>默认情况下即使容器停止运行 , 这个文件也还是在的 , 不会被删除<br>可以使用<code>docker container ls -all</code>来查看所有容器文件<br>使用<code>docker container rm [ContainerId]</code>来删除指定的容器文件</p></blockquote><h3 id="尝试制作自己的image并运行"><a href="#尝试制作自己的image并运行" class="headerlink" title="尝试制作自己的image并运行"></a>尝试制作自己的image并运行</h3><p>这里用一个简单的nodejs项目作为例子 , 尝试制作一个自己的image<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir express-demo</span><br><span class="line"><span class="built_in">cd</span> express-demo</span><br><span class="line">npm init</span><br><span class="line">npm install express --save</span><br></pre></td></tr></table></figure></p><p>index.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">7001</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.send(<span class="string">"&lt;h1&gt;Hello World&lt;/h1&gt;"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = app.listen(port, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"在%s端口执行监听"</span>, port)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h4><p>在此之前 , 我们也可以在项目目录里面加一个<code>.dockerignore</code><br>这个文件表示打包image的时候需要排除在外的内容( 很类似.gitignore )<br>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br></pre></td></tr></table></figure></p><p>创建Dockerfile文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:9.11</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install</span><br><span class="line">EXPOSE 7001</span><br></pre></td></tr></table></figure></p><ul><li><code>FORM node:9.11</code> 继承自官方的node镜像 , 冒号后面是标签(通常是版本号)</li><li><code>COPY . /app</code> 将当前目录下的所有文件(除了.dockerignore排除的)都拷贝到image文件的app目录下</li><li><code>WORKDIR /app</code> 工作路径为/app</li><li><code>RUN npm install</code> 在打包image的时候需要执行的 ( 所以这个nodejs项目的依赖包会被打包进image当中 )</li><li><code>EXPOSE 7001</code> 运行时暴露出的端口号</li></ul><h4 id="打包与运行"><a href="#打包与运行" class="headerlink" title="打包与运行"></a>打包与运行</h4><p>打包image<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t express-demo:1.0 .</span><br><span class="line"><span class="comment"># -t参数是指定该image的名字 , 冒号后面是标签(默认是latest)</span></span><br><span class="line"><span class="comment"># . 表示打包当前目录下的文件</span></span><br></pre></td></tr></table></figure></p><p>运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --rm -p 8000:7001 -it express-demo:1.0 /bin/bash</span><br></pre></td></tr></table></figure></p><ul><li><code>--rm</code> 容器停止运行时自动删除容器文件</li><li><code>-p</code> 表示端口映射 , 这里是将容器的7001端口映射到本地的8000端口</li><li><code>-it</code> 容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器</li><li><strong>express-demo:1.0</strong> image的名称和标签(当然直接用image的id也可以)</li><li><strong>/bin/bash</strong> 容器启动后第一个执行的命令 , 这里启动bash , 保证可以使用shell</li></ul><p>执行之后会进入到命令提示符<code>root@2604657cb46c:/app#</code><br>在这里我们就可以执行<strong>node index.js</strong>来运行程序了</p><p>运行之后在外部当然是要通过8000端口来访问</p><h4 id="自动化运行"><a href="#自动化运行" class="headerlink" title="自动化运行"></a>自动化运行</h4><p>上面的方式在启动容器之后还要手动运行程序 , 还是显得有些繁琐了<br>我们可以在Dockerfile里面加一个CMD的选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:9.11</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install</span><br><span class="line">EXPOSE 7001</span><br><span class="line">CMD node index.js</span><br></pre></td></tr></table></figure></p><p>区别于RUN , CMD是在容器启动的时候执行的 , 而RUN是在打包image的时候执行的</p><blockquote><p>当然 , 有了这个入口 , 就可以自由发挥了<br>比如程序启动比较繁琐 , 完全可以在image里面编写一个shell脚本<br>然后容器启动的时候运行这个脚本即可</p></blockquote><h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><p>查看指定容器的输出 , 即容器里面Shell的标准输出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs [ContainerId]</span><br></pre></td></tr></table></figure></p><p>进入一个正在运行的容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">exec</span> -it [ContainerID] /bin/bash</span><br></pre></td></tr></table></figure></p><p>之后就可以在容器的shell当中执行命令了</p><p>有时候我们需要把容器当中运行产生的文件拷贝出来<br>可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container cp [ContainerId]:[/app/run.log] /home/sookie</span><br></pre></td></tr></table></figure></p><p>上面的命令表示将指定容器的/app/run.log文件拷贝到本地的/home/sookie目录下</p><h4 id="使用国内镜像仓库"><a href="#使用国内镜像仓库" class="headerlink" title="使用国内镜像仓库"></a>使用国内镜像仓库</h4><p>出于众所周知的原因 , 官方仓库的速度比较慢<br>所以可以把官方镜像的下载地址改为国内的镜像仓库</p><p>Docker 官方中国区<br><a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a><br>网易<br><a href="http://hub-mirror.c.163.com" target="_blank" rel="noopener">http://hub-mirror.c.163.com</a><br>ustc<br><a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn</a></p><h5 id="方法1-registry-mirror参数"><a href="#方法1-registry-mirror参数" class="headerlink" title="方法1 registry-mirror参数"></a>方法1 registry-mirror参数</h5><p>直接设置 –registry-mirror 参数，仅对当前的命令有效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world --registry-mirror=https://docker.mirrors.ustc.edu.cn</span><br></pre></td></tr></table></figure></p><h5 id="方法2-修改-etc-default-docker"><a href="#方法2-修改-etc-default-docker" class="headerlink" title="方法2 修改/etc/default/docker"></a>方法2 修改/etc/default/docker</h5><p>加入 DOCKER_OPTS=”镜像地址”，可以有多个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=&quot;--registry-mirror=https://docker.mirrors.ustc.edu.cn&quot;</span><br></pre></td></tr></table></figure></p><h5 id="方法3-修改-etc-docker-daemon-json"><a href="#方法3-修改-etc-docker-daemon-json" class="headerlink" title="方法3 修改/etc/docker/daemon.json"></a>方法3 修改/etc/docker/daemon.json</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"registry-mirrors"</span>: [<span class="string">"https://docker.mirrors.ustc.edu.cn"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>新版的docker比较推荐方法3</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;程序部署运维的痛点&lt;/strong&gt;&lt;br&gt;当今软件越发庞大复杂 , 在服务器部署运行一个软件之前通常需要完成:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;操作系统的设置&lt;/li&gt;
&lt;li&gt;各种库和组件的安装&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;只有他们都正确 , 软件才能正常运行&lt;br&gt;当需要迁移的时候 , 这些事情都要重来一遍&lt;br&gt;并且由于各种原因 , 还可能会产生不一样的问题 , 费时费力&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="https://sookie2010.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://sookie2010.github.io/tags/linux/"/>
    
      <category term="docker" scheme="https://sookie2010.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>5.2、关联映射</title>
    <link href="https://sookie2010.github.io/MongoDB/5.2%E3%80%81%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84/"/>
    <id>https://sookie2010.github.io/MongoDB/5.2、关联映射/</id>
    <published>2018-01-27T11:37:03.000Z</published>
    <updated>2018-05-21T00:48:43.778Z</updated>
    
    <content type="html"><![CDATA[<p>在Maven项目中引入marphia的包<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mongodb.morphia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>morphia<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p><img src="/images/MongoDB/mapping1.png" alt="mapping"><br>maven会自动引入一些其他的依赖jar包 , 否则关联映射就无法正常执行</p><hr><h4 id="命令行执行"><a href="#命令行执行" class="headerlink" title="命令行执行"></a>命令行执行</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.user.insert(&#123;</span><br><span class="line">  username:<span class="string">"test_user"</span>,</span><br><span class="line">  role : &#123;</span><br><span class="line">    $ref:<span class="string">"role"</span>,</span><br><span class="line">    $id:ObjectId(<span class="string">"576d47b8cc7a1342538343fc"</span>),</span><br><span class="line">    $db:<span class="string">"model_db"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong> : 在NoSQL型数据库当中 , 并不鼓励使用类似于关系型数据库的外键关联<br>但是为了程序的查询方便 , 提供了这种程序驱动可以识别的表示形式<br>其实并没有外键关联的检查 , 与普通的文档没有任何区别</p></blockquote><h4 id="使用morphia的注解实现引用"><a href="#使用morphia的注解实现引用" class="headerlink" title="使用morphia的注解实现引用"></a>使用morphia的注解实现引用</h4><h5 id="多对一关联"><a href="#多对一关联" class="headerlink" title="多对一关联"></a>多对一关联</h5><p><code>@Reference</code>注解包含的属性</p><ul><li>concreteClass - 关联的目标类</li><li>idOnly - 只保存从表的数据ID ( 与关系型数据库的外键字段类似 )</li><li>ignoreMissing - 忽略不能解决的引用</li><li>lazy - 懒加载 , 默认是false ( 在双向关联情况下 , 如果双端都不是懒加载 , 会形成死循环 )</li><li>value - 在集合中存储的字段名 , 默认是类中的属性名</li></ul><p>角色表<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(value=<span class="string">"role"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> ObjectId id;</span><br><span class="line">  <span class="keyword">private</span> String roleName;</span><br><span class="line">  <span class="keyword">private</span> String remark;</span><br><span class="line"><span class="comment">//getter与setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用户表<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(value=<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> ObjectId id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> denger;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Reference</span>(value=<span class="string">"roleId"</span>,idOnly=<span class="keyword">true</span>)</span><br><span class="line">  <span class="keyword">private</span> Role role;</span><br><span class="line"><span class="comment">//getter与setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">"papapa"</span>);</span><br><span class="line"></span><br><span class="line">Role role = <span class="keyword">new</span> Role();</span><br><span class="line">role.setRoleName(<span class="string">"测试角色2"</span>);</span><br><span class="line"></span><br><span class="line">user.setRole(role);</span><br><span class="line">ds.save(role);<span class="comment">//ds -&gt; Datastore</span></span><br><span class="line">ds.save(user);</span><br></pre></td></tr></table></figure></p><p><img src="/images/MongoDB/mapping2.png" alt="mapping"></p><h5 id="一对多关联"><a href="#一对多关联" class="headerlink" title="一对多关联"></a>一对多关联</h5><p>用法与多对一也是类似的 , 数据库中会在 <strong>一</strong> 的那端以数组形式保存数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(value=<span class="string">"role"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> ObjectId id;</span><br><span class="line">  <span class="keyword">private</span> String roleName;</span><br><span class="line">  <span class="keyword">private</span> String remark;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Reference</span>(<span class="string">"user"</span>)</span><br><span class="line">  <span class="keyword">private</span> List&lt;User&gt; users;</span><br><span class="line"><span class="comment">//getter与setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Role role = <span class="keyword">new</span> Role();</span><br><span class="line">  role.setRoleName(<span class="string">"测试角色2"</span>);</span><br><span class="line">  User user1 = <span class="keyword">new</span> User();</span><br><span class="line">  user1.setUsername(<span class="string">"pppp"</span>);</span><br><span class="line">  </span><br><span class="line">  User user2 = <span class="keyword">new</span> User();</span><br><span class="line">  user2.setUsername(<span class="string">"oooo"</span>);</span><br><span class="line">  </span><br><span class="line">  List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">  users.add(user1);</span><br><span class="line">  users.add(user2);</span><br><span class="line">  userDao.save(user1);</span><br><span class="line">  userDao.save(user2);</span><br><span class="line">  </span><br><span class="line">  role.setUsers(users);</span><br><span class="line">  roleDao.save(role);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/MongoDB/mapping3.png" alt="mapping"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Maven项目中引入marphia的包&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.mongodb.morphia&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;morphia&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.2.0&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://sookie2010.github.io/categories/MongoDB/"/>
    
    
      <category term="数据库" scheme="https://sookie2010.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MongoDB" scheme="https://sookie2010.github.io/tags/MongoDB/"/>
    
  </entry>
  
</feed>
