<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>模块化编程(2)</title>
      <link href="/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B(2)/"/>
      <url>/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B(2)/</url>
      <content type="html"><![CDATA[<p>模块存在的价值是为了能够更方便地复用代码 , 更加有利于功能的封装<br>但是如果要实现的话 , 就必须要求每个人都按照同样的方式去编写模块<br>目前通行的JavaScript模块规范有两种 , 分别是<code>CommonJS</code>和<code>AMD</code><br><a id="more"></a></p><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>从node.js出现之后 , 将JavaScript用于服务器编程<br>同时也标志着JS的模块化编程正式诞生<br>在网页环境下 , 没有模块也不是特别大的问题 , 因为网页程序的复杂性和规模都相对有限 , 但是在服务器端就必须要有模块 , 否则服务器端程序就会难以扩展和维护</p><p>nodejs的模块系统 , 就是按照CommonJS规范实现的<br>这个规范当中 , 有一个全局方法 <code>require</code> , 用于加载模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mod1 = <span class="built_in">require</span>(<span class="string">"module1"</span>);</span><br><span class="line">mod1.biz();</span><br></pre></td></tr></table></figure><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>有了在服务端可用的模块化编程方式 , 大家很自然就想要在客户端也能实现的方式 , 并且最好能够兼容<br>这样同样的一个模块的代码 , 不用修改任何内容就可以同时应用于服务端和客户端</p><p>但是如果直接套用在nodejs当中的实现方式 , 就会存在线程阻塞的问题<br>也就是必须要等require方法执行完毕 , 加载运行这个模块的代码之后 , 后面的代码才会被执行<br>对于服务端来说 , 这并不是什么问题 , 因为代码都在本地 , 不可能出现长期阻塞的问题<br>但是对于客户端来说 , js文件需要发送http请求去获取 , 所以同步加载的方式就十分影响性能了</p><p>AMD ( Asynchronous Module Definition <code>异步模块定义</code> ) , 这种规范的要求是采用异步方式加载模块<br>形式如下 :<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">"module1"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">mod</span>) </span>&#123;</span><br><span class="line">  mod.biz();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>规范只是约定一种形式 , 具体要应用的话需要有对应的库来实现<br>这里通过<code>require.js</code>来介绍</p><h3 id="require-js"><a href="#require-js" class="headerlink" title="require.js"></a>require.js</h3><p><a href="http://www.requirejs.cn/" target="_blank" rel="noopener">require.js官网</a></p><p>require.js主要解决两个问题</p><ol><li>实现js文件的异步加载 , 避免网页失去响应</li><li>管理模块之间的依赖性 , 便于代码的编写和维护</li></ol><p>使用require.js需要指定一个主模块 , 以及在主模块中可以去引入若干个子模块 , 主模块相当于是程序执行的入口<br>( 如果没有子模块的话就不需要require.js了 )</p><p>目录结构<br><img src="/images/JavaScript/modules.png" alt="require demo"></p><h4 id="data-main入口点"><a href="#data-main入口点" class="headerlink" title="data-main入口点"></a>data-main入口点</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/require.js"</span> <span class="attr">data-main</span>=<span class="string">"js/main"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js目录下的main.js就是作为主模块 , 后面的.js可以省略</p><h4 id="子模块的编写方式"><a href="#子模块的编写方式" class="headerlink" title="子模块的编写方式"></a>子模块的编写方式</h4><p>require.js加载的模块 , 采用AMD规范 , 也就是说模块必须按照AMD的规范来写<br>模块必须采用特定的define函数来定义<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    biz : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"子模块的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这个函数返回的对象就是这个模块需要暴露出的对象</p><p>如果该模块需要依赖其他模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module2.js</span></span><br><span class="line">define([<span class="string">"module1"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">mod1</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">biz2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mod1.biz() + <span class="string">"ok"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    biz : biz2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="主模块的编写方式"><a href="#主模块的编写方式" class="headerlink" title="主模块的编写方式"></a>主模块的编写方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"modules/module1"</span>,<span class="string">"modules/module2"</span>], </span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">mod1,mod2</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//mod1和mod2分别是在子模块中暴露出的对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>require函数接受两个参数 , 第一个参数是子模块的相对路径和名称 ( 如果在同一个路径下可以不加路径 ) , <strong>必须是一个数组</strong><br>第二个参数是子模块加载完成之后执行的回调函数</p><font color="blueviolet">更加灵活的自定义加载</font><p>模块的引入采用的是子模块的js文件与主模块文件的相对位置<br>如果要加在的子模块较多 , 这么相对路径就需要加在每个子模块的前面<br>为了更清晰一些 , 我们可以采用下面的方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line"><span class="comment">//注意这里的baseUrl是相对于引入主模块的页面的路径</span></span><br><span class="line"><span class="comment">//页面是 /require_demo/test.html</span></span><br><span class="line"><span class="comment">//子模块位于 /require_demo/other/module3.js</span></span><br><span class="line">  baseUrl : <span class="string">"./other/"</span>,</span><br><span class="line">  paths : &#123;</span><br><span class="line">    mod3 : <span class="string">"module3"</span>,</span><br><span class="line">    mod4 : <span class="string">"module4"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//上面的代码相当于对子模块的路径创建了映射</span></span><br><span class="line"><span class="comment">//下面才是真正引入模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"mod3"</span>,<span class="string">"mod4"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">mod3, mod4</span>)</span>&#123;</span><br><span class="line">  mod3.biz3();</span><br><span class="line">  mod4.biz4();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面的写法其实就等价于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">"../other/module3"</span>,<span class="string">"../other/module4"</span>],</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">mod3, mod4</span>)</span>&#123;</span><br><span class="line">  mod3.biz3();</span><br><span class="line">  mod4.biz4();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>paths里面也可以直接使用完整的网络URL地址</p></blockquote><h4 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a>加载非规范的模块</h4><p>采用上面的方式去加载的子模块 , 模块当中必须按照AMD的规范去写<br>如果子模块本身并不符合这个要求<br>在不方便修改子模块的情况下 , 我们可以采用如下的方式去加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  shim : &#123;</span><br><span class="line">    underscore : &#123;</span><br><span class="line">      exports : <span class="string">"_"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  paths : &#123; <span class="comment">//这部分并没有什么差别</span></span><br><span class="line">    underscore : <span class="string">"./plugins/underscore"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"underscore"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">_</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//测试代码</span></span><br><span class="line">  _.each([<span class="number">1</span>,<span class="number">10</span>,<span class="number">20</span>],<span class="built_in">console</span>.log);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>未按照AMD规范编写的模块 , 通常采用的是暴露出一个变量放入到window当中作为全局变量 , 比如underscore这个库 , 暴露出的就是<code>_</code></p><h5 id="模块依赖性声明"><a href="#模块依赖性声明" class="headerlink" title="模块依赖性声明"></a>模块依赖性声明</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">shim : &#123;</span><br><span class="line">  <span class="string">"jquery.scroll"</span> : &#123;</span><br><span class="line">    deps : [<span class="string">"jquery"</span>],</span><br><span class="line">    exports : <span class="string">"jQuery.fn.scroll"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模块化编程(1)</title>
      <link href="/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B(1)/"/>
      <url>/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B(1)/</url>
      <content type="html"><![CDATA[<h4 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h4><blockquote><p>网页中<code>&lt;script&gt;</code>标签</p><ul><li>如果是src引入一个文件的形式 , 加载这个文件的过程默认是同步的 , 如果引入了多个文件 , 则按照声明的顺序进行加载运行 , 前面的文件尚未加载运行完毕 , 不会加载后面的文件<a id="more"></a></li><li>从src所指定的地址获取文件的动作是异步的 , 如果前面有未加载完成的脚本 , 那么该脚本即使已经获取到 , 也不会先加载运行</li><li>给script标签添加<code>async=&quot;async&quot;</code>属性 , 可以指定这个脚本的加载运行以异步方式执行</li><li>在IE当中 , 使用<code>defer</code>指定异步方式执行脚本</li></ul></blockquote><p>例如 :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/test/demo1.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/test/demo2.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果不加 defer async=”async” 的情况下 , demo1.js 和 demo2.js 会顺序加载运行 , 假如demo2.js当中有对demo1.js的依赖 , 那么这种情况下不会出现问题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/test/demo1.js"</span> <span class="attr">defer</span> <span class="attr">async</span>=<span class="string">"async"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/test/demo2.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果demo1.js由于文件庞大 网络不畅等原因加载缓慢 , 我们可以给demo1.js添加异步加载标识<br>这种情况下 , demo2.js将<strong>有可能</strong>先于demo1.js加载运行 , 如果存在依赖 , 将<strong>有可能</strong>报错</p><hr><h3 id="模块化的实现方式"><a href="#模块化的实现方式" class="headerlink" title="模块化的实现方式"></a>模块化的实现方式</h3><p>JS在很长一段时间内不是一种支持模块化编程的语言<br>虽然ES6正式支持了类和模块 , 在nodejs环境下的模块化编程没有问题<br>但是能够在浏览器环境中普遍使用还需要很长时间<br>所以需要采用其他的方法去模拟实现模块化</p><h4 id="原始写法"><a href="#原始写法" class="headerlink" title="原始写法"></a>原始写法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将若干个函数简单堆积在一起 , 可以认为是一个模块<br>但是这种模式是将这些函数对象作为全局变量<br>如果函数很多 , 会造成全局变量的污染<br>与其他模块也可能发生变量的命名冲突问题</p><h4 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = &#123;</span><br><span class="line">  _count : <span class="number">0</span>,</span><br><span class="line">  up : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    _count ++;</span><br><span class="line">  &#125;,</span><br><span class="line">  down : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    _count --;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种写法只讲一个对象作为全局变量 , 一定程度上避免了全局变量的污染<br>但是这种写法会暴露所有的模块成员 , 无法做到只有模块内部方法能够访问的局部变量</p><h4 id="立即执行函数写法"><a href="#立即执行函数写法" class="headerlink" title="立即执行函数写法"></a>立即执行函数写法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    up : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      _count ++;</span><br><span class="line">    &#125;,</span><br><span class="line">    down : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      _count --;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这种写法 , 把模块内需要保护的变量作为函数的局部变量 , 在外部无法直接去访问<br>可以算是相对科学的写法了 , 之后的几种都是对这种写法的改造和扩展</p><h4 id="放大模式"><a href="#放大模式" class="headerlink" title="放大模式"></a>放大模式</h4><p>如果一个模块需要分成几个部分写在不同的地方 , 或者说一个模块需要去继承另一个模块 , 就需要使用放大模式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>)</span>&#123;</span><br><span class="line">  mod.biz = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我是另外加入的方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(module1);</span><br></pre></td></tr></table></figure></p><h4 id="宽放大模式"><a href="#宽放大模式" class="headerlink" title="宽放大模式"></a>宽放大模式</h4><p>上面的放大模式显然需要保证模块加载的先后顺序<br>如果传入的module1是undefined , 肯定会报错<br>然而部署在外网的项目 , 如果严格限制了模块的加载顺序 , 很容易造成页面加载缓慢<br>为了适应这种情况 , 可以采用宽放大模式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>)</span>&#123;</span><br><span class="line">  mod.biz = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我是另外加入的方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure></p><p>module1模块的两部分都采取这种写法 , 加载的先后就无所谓了<br>先加载的会在空对象上添加方法</p><h4 id="输入全局变量"><a href="#输入全局变量" class="headerlink" title="输入全局变量"></a>输入全局变量</h4><p>一个模块最好能够是独立的 , 不与其他模块中的部分直接进行交互<br>但是如果在模块内需要其他模块产生的对象<br>可以显式地将这些对象输入到模块内部</p><p>比如需要用到jQuery的对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生成器函数</title>
      <link href="/JavaScript/Symbol/"/>
      <url>/JavaScript/Symbol/</url>
      <content type="html"><![CDATA[<p>在ES6标准当中 , 新引入了一种基本数据类型 , 就是<code>Symbol</code><br><a id="more"></a><br>在此之前的基本数据类型有</p><ul><li>undefined</li><li>null</li><li>object</li><li>number</li><li>boolean</li><li>string</li></ul><p>通常我们可以使用<code>typeof</code>来判断一个对象的类型<br>但是存在一些特例</p><ol><li>对于一个函数对象 , 对其执行typeof操作 , 获得的是<code>&quot;function&quot;</code></li><li>对于null , 对其执行typeof操作 , 获得的是<code>&quot;object&quot;</code></li></ol><hr><p>Symbol对象可以认为是一个<strong>唯一标识</strong><br>我们可以采用如下的方式来构造出一个Symbol对象</p><ul><li>Symbol() - 这种方式每次调用 , 返回的对象都不同</li><li>Symbol.for(string) - 这种方式会试图访问已经存在的Symbol对象 , 如果不存在则创建一个新的<br>Symbol.for(“aa”) == Symbol.for(“aa”)  会获得<strong>true</strong></li><li>使用预定义的Symbol对象 , 比如Symbol.iterator</li><li>使用typeof Symbol对象 , 返回”symbol”</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="构造一个对象当中的私有属性"><a href="#构造一个对象当中的私有属性" class="headerlink" title="构造一个对象当中的私有属性"></a>构造一个对象当中的私有属性</h4><p>JavaScript的对象属性默认是可以被外界访问和修改的<br>通常我们对于不希望被访问的变量 , 以下划线开头明明<br>但是这只是一种约定 , 并不具有强制作用<br>如果我们开发的第三方模块当中 , 需要有只提供给模块内方法访问的私有属性<br>那么就可以借助Symbol来实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [_x, _y] = [<span class="built_in">Symbol</span>(), <span class="built_in">Symbol</span>()];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[_x] = x;</span><br><span class="line">    <span class="keyword">this</span>[_y] = y;</span><br><span class="line">  &#125;</span><br><span class="line">  Point.prototype.length = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="keyword">this</span>[_x],</span><br><span class="line">    y = <span class="keyword">this</span>[_y];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(x * x + y * y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.length()); <span class="comment">//5</span></span><br></pre></td></tr></table></figure></p><p>在上面提到过 , 每次调用Symbol()返回的对象都是不同的<br>所以在自动执行的函数内部 , _x 和 _y其实是不同的对象<br>或者我们也可以用<code>Symbol(&quot;x&quot;)</code>和<code>Symbol(&quot;y&quot;)</code>来进行区分 , 这不是必须的</p><p>这种情况下 , 内部的两个属性就真正成为了私有属性 , 无法在外部访问到它的值<br>因为在外部再次调用Symbol()产生的是不同的对象</p><h4 id="避免命名冲突"><a href="#避免命名冲突" class="headerlink" title="避免命名冲突"></a>避免命名冲突</h4><p>对于相对复杂的模块 , 暴露出的对象内部的私有变量可能需要很多<br>如果这些私有变量没有被完全私有化<br>那么这个模块的兼容性和可扩展性就会很差<br>因为在扩展时十分容易出现命名的冲突问题</p><p>或者可以用一个十分冗长的字符串作为属性名 , 那么源代码的可读性就基本不存在了</p><p>使用Symbol可以解决这个问题 , 与上面的类似的<br>变量私有化 , 则不会产生同名的冲突</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>new关键字做了什么</title>
      <link href="/JavaScript/new%E5%85%B3%E9%94%AE%E5%AD%97%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/JavaScript/new%E5%85%B3%E9%94%AE%E5%AD%97%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<p>假设说现在要构造若干个”士兵”对象 , 每个士兵都有类型 攻击力 生命值 这些属性<br>同时有奔跑 攻击 防御 这些可以执行的动作 , 在代码中表现为方法<br><a id="more"></a><br>简单粗暴的方式可以这样做<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> soldiers = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> soldier = &#123;</span><br><span class="line">    type : <span class="string">"步兵"</span>,</span><br><span class="line">    id : i,</span><br><span class="line">    health : <span class="number">100</span>,</span><br><span class="line">    run : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"奔跑"</span>);&#125;,</span><br><span class="line">    attack : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"攻击"</span>);&#125;,</span><br><span class="line">    defense : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"防御"</span>);&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  soldiers.push(soldier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方式显然存在一个问题 , 就是浪费了大量的内存<br>因为每个士兵可以执行的行为都是一样的 , 这几个函数完全可以共用<br>这种方式却给每个对象创建了独立的函数<br>兵种也是一样的 , 只有id和生命值 , 每个士兵都要具备自己的值</p><p>可以给每个对象指定各自的原型对象 , 只要这些共用的方法写在原型对象当中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> soldiers = [];</span><br><span class="line"><span class="keyword">var</span> soldierProto = &#123;</span><br><span class="line">  type : <span class="string">"步兵"</span>,</span><br><span class="line">  run : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"奔跑"</span>)&#125;,</span><br><span class="line">  attack : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"攻击"</span>);&#125;,</span><br><span class="line">  defense : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"防御"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> soldier = &#123;</span><br><span class="line">    id : i,</span><br><span class="line">    health : <span class="number">100</span></span><br><span class="line">  &#125;;</span><br><span class="line">  solider.__proto__ = soldierProto;</span><br><span class="line">  soldiers.push(soldier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在把创建士兵的代码放在了两个地方 , 很不优雅<br>所以可以用一个函数把两者联系起来<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSoldier</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _soldier = &#123;&#125;; <span class="comment">//临时对象</span></span><br><span class="line">  _soldier.__proto__ = createSoldier[<span class="string">"原型"</span>];</span><br><span class="line">  _soldier.id = id;</span><br><span class="line">  _soldier.health = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> _soldier;</span><br><span class="line">&#125;</span><br><span class="line">createSoldier[<span class="string">"原型"</span>]= &#123;</span><br><span class="line">  type : <span class="string">"士兵"</span>,</span><br><span class="line">  attackNum : <span class="number">5</span>, <span class="comment">//攻击力</span></span><br><span class="line">  run : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"奔跑"</span>);&#125;,</span><br><span class="line">  attack : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"攻击"</span>);&#125;,</span><br><span class="line">  defense : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"防御"</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码在函数中添加了一个属性 , 叫做”原型”<br>主要做的就是把需要作为原型的对象保存在函数对象的一个属性当中 , 使调用这个函数的时候可以获取到这个原型对象<br>new关键字所做的事情 , 其实就相当于是上面代码里面我们自己手动实现的事情</p><ul><li>自动创建临时对象 ( 在函数内部使用this可以访问到这个临时对象 )</li><li>自动绑定该Function对象的原型 ( 统一叫做<code>prototype</code> )</li><li>自动return这个临时对象</li></ul><p>现在写一个可以用new去调用的纯粹的构造函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">soldier</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.health = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">soldier.prototype = &#123;</span><br><span class="line">  type : <span class="string">"士兵"</span>,</span><br><span class="line">  attackNum : <span class="number">5</span>, <span class="comment">//攻击力</span></span><br><span class="line">  run : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"奔跑"</span>);&#125;,</span><br><span class="line">  attack : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"攻击"</span>);&#125;,</span><br><span class="line">  defense : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"防御"</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外 , 为了记录 <strong>临时对象是由哪个函数创建的</strong> , 会在定义这个函数的时候 , 在函数的prototype属性 ( 是Object ) 上面自动添加一个<code>constructor</code>属性 , 比如 :<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Sookie"</span>;</span><br><span class="line">&#125;</span><br><span class="line">func.prototype.constructor === func; <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>所以如果像上面那样直接给函数的prototype属性赋值一个对象的话 , 这个constructor就没了<br>所以可以采取下面两种做法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 手工把这个属性加上</span></span><br><span class="line">soldier.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span> : soldier,</span><br><span class="line">  type : "士兵",</span><br><span class="line">  attackNum : 5, //攻击力</span><br><span class="line">  run : function()&#123;<span class="built_in">console</span>.log(<span class="string">"奔跑"</span>);&#125;,</span><br><span class="line">  attack : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"攻击"</span>);&#125;,</span><br><span class="line">  defense : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"防御"</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 不去覆盖原本的prototype属性对象, 而是直接在上面添加属性</span></span><br><span class="line">soldier.prototype.type = <span class="string">"士兵"</span>;</span><br><span class="line">soldier.prototype.attackNum = <span class="number">5</span>;</span><br><span class="line">soldier.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"奔跑"</span>);&#125;;</span><br><span class="line">soldier.prototype.attack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"攻击"</span>);&#125;;</span><br><span class="line">soldier.prototype.defense = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"防御"</span>);&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生成器函数</title>
      <link href="/JavaScript/%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0/"/>
      <url>/JavaScript/%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p><code>function *</code>声明可以用于定义一个生成器函数 , 它返回一个Generator对象<br><a id="more"></a><br>语法</p><pre>function * name([param[,param[,...param]]]){ statement }</pre><p>生成器是一种可以从中退出后重新进入的函数<br>函数内部的局部变量会在每次执行后被保存 , 下次进入可以继续使用</p><p>调用生成器函数并不会执行它的主体 , 而是返回对应的一个Generator对象<br>当这个对象的<code>next()</code>方法被调用时 , 生成器函数的主体会被执行至第一个<code>yield</code>表达式 , 该表达式定义了生成器本次生成的值<br>next()方法返回一个对象<br>包含<strong>value</strong>属性 , 是本次生成的值<br>以及<strong>done</strong>属性 , 表示生成器是否已经产出了最后一个值 ( 产出最后的值之后 , 调用next返回的对象当中value都是undefined )</p><blockquote><p>Generator对象中的方法</p><ul><li>Generator.prototype.next()<br>返回一个由yield表达式生成的值</li><li>Generator.prototype.return( [val] )<br>返回给定的值并结束生成器</li><li>Generator.prototype.throw( [msg] )<br>向生成器抛出一个错误</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">num</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(a &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    a++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = num();</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><hr><h4 id="yield"><a href="#yield" class="headerlink" title="yield *"></a>yield *</h4><p>可以将生成器中需要生成的值委派至另一个生成器<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">anotherGenerator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> i;</span><br><span class="line">  <span class="keyword">yield</span>* anotherGenerator(i);</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = generator(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p><blockquote><p>生成器函数在浏览器当中的兼容性不佳 , 更推荐在nodejs当中使用 , 而不是在页面脚本当中使用<br><img src="/images/JavaScript/generate_function1.png" alt="generate function"><br><img src="/images/JavaScript/generate_function2.png" alt="generate function"></p></blockquote>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>扩展运算符的用法</title>
      <link href="/JavaScript/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/JavaScript/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>ES6标准新加入的<code>扩展运算符(Spread Operator)</code> , 可以使JS代码变得更加简洁 , 编写起来更加灵活<br><a id="more"></a></p><h4 id="不使用apply去调用函数"><a href="#不使用apply去调用函数" class="headerlink" title="不使用apply去调用函数"></a>不使用apply去调用函数</h4><p>如果现在有一个数组 , 需要将它当中的每个元素逐个对应到一个函数的参数进行传入的话 , 在以往需要这样写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a,b,c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a+b+c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">10</span>,<span class="number">2</span>,<span class="number">60</span>];</span><br><span class="line">func.apply(<span class="literal">null</span>, args);</span><br></pre></td></tr></table></figure></p><p>如果使用扩展运算符 , 只需按照如下方式调用即可<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(...args);</span><br></pre></td></tr></table></figure></p><h4 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h4><p>以往合并数组的方式通常是使用<code>concat</code>方法<br>或者也可以遍历数组 , 逐个push或者unshift到另一个数组当中<br>现在有了扩展运算符 , 就可以运用更加灵活简洁的方式了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">10</span>,<span class="number">30</span>,<span class="string">"ab"</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="literal">true</span>,<span class="string">"pp"</span>];</span><br><span class="line"></span><br><span class="line">arr1.unshift(...arr2);</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure><p>或者也可以在数组内部进行合并<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">10</span>,<span class="number">20</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, ...arr1, <span class="number">100</span>];</span><br></pre></td></tr></table></figure></p><p>语法更简洁了 , 而且可以灵活控制位置</p><h4 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h4><p>其实与上面的数组内合并是类似的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr1];</span><br></pre></td></tr></table></figure></p><h4 id="将类数组转化为数组"><a href="#将类数组转化为数组" class="headerlink" title="将类数组转化为数组"></a>将类数组转化为数组</h4><p>在以前我们需要用<code>Array.prototype.slice</code>来讲类数组( 比如arguments )来转化为真正的数组对象<br>现在可以直接使用扩展运算符了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divArr = [...document.querySelectorAll(<span class="string">"div"</span>)];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"><span class="comment">//等同于[...arguments]</span></span><br><span class="line">  <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>所谓解构 , 其实就是分解数组或对象的结构 , 将其中的元素直接赋值给变量</p><h5 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h5><p>比如通过不定参数来获取数组后面的尾随元素<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,...b] = [<span class="string">'a2'</span>,<span class="string">'b2'</span>,<span class="string">'c2'</span>,<span class="string">'d2'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//a2</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//['b2','c2','d2']</span></span><br></pre></td></tr></table></figure></p><p>也可以在某些位置留空 , 跳过数组当中对应位置的元素<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,,b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>对于多维数组 , 也是同样适用的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [one,[[two],three]] = [<span class="number">1</span>, [[<span class="number">2</span>],<span class="number">3</span>]];</span><br></pre></td></tr></table></figure></p><p>数组结构同样可以适用于<strong>生成器</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line"><span class="built_in">console</span>.log(sixth);</span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><h5 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;name:&quot;Sookie&quot;, age:18&#125;;</span><br><span class="line">var &#123;name : nameA&#125; = obj;</span><br><span class="line">console.log(nameA); //Sookie</span><br></pre></td></tr></table></figure><p>当属性名与变量名一致的时候 , 也可以简写如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;name&#125; = obj;</span><br></pre></td></tr></table></figure></p><p>与数组类似 , 多层嵌套的对象结构同样可以使用类似的结构分别赋值给对应的变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> complicatedObj = &#123;</span><br><span class="line">      arrayProp: [</span><br><span class="line">        <span class="string">"Zapp"</span>,</span><br><span class="line">        &#123; <span class="attr">second</span>: <span class="string">"Brannigan"</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> &#123; <span class="attr">arrayProp</span>: [first, &#123; second &#125;] &#125; = complicatedObj;</span><br></pre></td></tr></table></figure></p><blockquote><p>当解构对象时 , 如果没有变量声明的标识符 ( var  const  let ) , 直接这样写会报错<br><code>{a} = {a:10}</code><br>因为JS解析器会把 { 开始的语句解析为一个块语句<br><code>({a} = {a:10})</code>这样写就是正确的</p></blockquote><p>我们可以给解构的结果添加一个默认值<br>如果解构的目标数组或者对象当中没有获取到对应的值 , 那么将使用这个默认值<br>( 不指定默认值将得到undefined )<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [missing=<span class="literal">true</span>] = [];</span><br><span class="line"><span class="keyword">var</span> &#123;msg=<span class="string">"success"</span>&#125; = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6的重要新特性</title>
      <link href="/JavaScript/ES6%E7%9A%84%E9%87%8D%E8%A6%81%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/JavaScript/ES6%E7%9A%84%E9%87%8D%E8%A6%81%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<ol><li><strong>函数的默认参数</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="function"><span class="keyword">function</span>(<span class="params">height=<span class="number">50</span>,color=<span class="string">"red"</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//some code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><p>在没有这种写法的时候<br>我们通常需要通过下面的方式来设置函数参数的默认值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="function"><span class="keyword">function</span>(<span class="params">height,color</span>) </span>&#123;</span><br><span class="line">  height = height || <span class="number">50</span>;</span><br><span class="line">  color = color || <span class="string">"red"</span>;</span><br><span class="line">  <span class="comment">//some code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是这种方式存在缺陷 , 就是当实参为0 或者 “”等这种会被判定为false的值 , 他们就会被默认值所替代<br>而包含参数默认值的函数则不会存在这个问题 </p><ol start="2"><li><strong>模板表达式</strong><br>以往如果需要在字符串中嵌入某个变量值 , 需要使用加号进行拼接<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> port = <span class="number">7001</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"the server is listening at "</span> + port + <span class="string">"!"</span>);</span><br></pre></td></tr></table></figure></li></ol><p>在ES6当中 , 使用<code>反引号</code>包裹的字符串 , 可以使用<code>${varName}</code>的形式来表示模板字符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> port = <span class="number">7001</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`the server is listening at <span class="subst">$&#123;port&#125;</span>!`</span>);</span><br></pre></td></tr></table></figure></p><p>用法类似JSP当中的 EL表达式</p><ol start="3"><li><strong>多行字符串</strong><br>以往要在代码中换行显示字符串 , 需要使用加好进行拼接 , 如果要使字符串当中实际包含换行 , 则需要使用转义字符<code>\n</code></li></ol><p>反引号当中的字符串可以直接进行换行 , 而不需要使用<code>\n</code>符号</p><ol start="4"><li><strong>拆包表达式</strong><br>如果要把一个JS对象当中的值赋给局部变量 , 以往通常需要这么做<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">  name : <span class="string">"Sookie"</span>,</span><br><span class="line">  age : <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = data.name;</span><br><span class="line"><span class="keyword">var</span> age = data.age;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`name : <span class="subst">$&#123;name&#125;</span>, age : <span class="subst">$&#123;age&#125;</span>`</span>);</span><br></pre></td></tr></table></figure></li></ol><p>在ES6当中 , 使用以下语句可以达到相同的效果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;name,age&#125; = data;</span><br></pre></td></tr></table></figure></p><p>对于数组的支持<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">  name : <span class="string">"Sookie"</span>,</span><br><span class="line">  age : <span class="number">18</span>,</span><br><span class="line">  skill : [<span class="string">"JavaScript"</span>,<span class="string">"Java"</span>,<span class="string">"MongoDB"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这里相当于产生了3个局部变量</span></span><br><span class="line"><span class="keyword">var</span> [sk1, sk2, sk3] = data.skill;</span><br><span class="line"><span class="built_in">console</span>.log(sk1, sk2, sk3);</span><br></pre></td></tr></table></figure></p><p>如果要跳过数组中某个位置的元素也是可以的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [sk1, , sk3] = data.skill;</span><br></pre></td></tr></table></figure></p><ol start="5"><li><strong>块级作用域的<code>let</code>和<code>const</code></strong><br>let可以认为是一个更新的var , 使用它定义的局部变量 , 作用域仅存在与当前的代码块( 包括复合语句 )<br>而由于变量的定义提升问题 , var是不能完全做到这一点的<br>例如 , 从习惯了写Java的程序员 , 通常习惯于下面这种写法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span> ; i++)&#123;</span><br><span class="line">  sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">//45</span></span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//10</span></span><br></pre></td></tr></table></figure></li></ol><p>但是变量 i 的作用域并不仅限于for循环的子句<br>如果使用如下方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span> ; i++)&#123;</span><br><span class="line">  sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">//45</span></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">//ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure></p><p>就把 i 的作用域限制在了代码块当中</p><p>对于使用<code>const</code>定义的变量 , 可以参照C语言中的const关键字 , 和Java当中的final关键字<br>作用仅仅是该引用的指向不可变 , 但是指向的对象本身是可变的</p><ol start="6"><li><strong>类与面向对象</strong><br>在ES5当中 , 要定义一个类, 只能是编写一个构造函数 , 这个函数与普通的函数没有本质区别 , 只是使用new关键字进行调用 , 它就可以构造一个对象<br>而<code>class</code>关键字 , 在ES6之前 , 只是作为一个没有意义的保留字存在的<br>现在 , 我们可以使用与Java十分相像的方式去写一个类<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;, data = []) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"Sookie"</span>;</span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">  showName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`the name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> model = <span class="keyword">new</span> BaseModel();</span><br><span class="line">model.showName();</span><br></pre></td></tr></table></figure></li></ol><p>constructor表示这个类的构造函数<br>需要注意的是 : 对于对象当中属性的赋值 , 必须要在构造函数当中完成 , 而不能像Java那样直接对类中的属性设定初始值</p><p>#####继承<br>继承的实现方式与Java也十分类似<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span> <span class="keyword">extends</span> <span class="title">BaseModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;, data = []) &#123;</span><br><span class="line">    <span class="comment">//如果要显式调用父类的构造方法, super必须放在第一条语句</span></span><br><span class="line">    <span class="keyword">super</span>(options, data);</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  showAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`the name is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> model = <span class="keyword">new</span> MyModel();</span><br><span class="line">model.showName();</span><br><span class="line">model.showAge();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Promise(2)</title>
      <link href="/JavaScript/Promise(2)/"/>
      <url>/JavaScript/Promise(2)/</url>
      <content type="html"><![CDATA[<p>如果只是执行一次单步回调 , 那么传统的回调函数执行的方式其实并没有什么问题</p><p>Promise的主要意义是在于解决多重回调的多层嵌套问题<br>如果回调的嵌套层级太多 , 会造成代码可读性很差 , 难以维护<br><a id="more"></a><br>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params">num, func</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num);</span><br><span class="line">  func(num);</span><br><span class="line">&#125;;</span><br><span class="line">test(<span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  test(<span class="number">2</span>, <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    test(<span class="number">3</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"回调成功"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>使用Promise可以将上述的代码改造成线性的模式 , 可读性增强 , 同时也更便于调试<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>让then方法的函数每次都是返回不同的Promise实例 , 再去指定这个实例的回调函数即可</p><p>并且对于Promise对象 , 它的回调执行是异步的<br>例如 :<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">"AA"</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"BB"</span>);</span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">BB</span></span><br><span class="line"><span class="comment">AA</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>对于异步操作实现的原理 , 可以参考JS的事件驱动模型<br>JS引擎会将回调函数的执行加入到事件队列当中<br>从而实现在单线程的条件下 , 代码的异步执行</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Promise(1)</title>
      <link href="/JavaScript/Promise(1)/"/>
      <url>/JavaScript/Promise(1)/</url>
      <content type="html"><![CDATA[<p>在JavaScript当中 , 不存在真正的多线程 , 从而导致所有需要异步执行的操作都需要使用回调函数实现<br><a id="more"></a><br>例如 : 使用定时器去执行一个回调函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.debug(<span class="string">"Time Out!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"before"</span>);</span><br><span class="line">setTimeout(callback,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"after"</span>);</span><br></pre></td></tr></table></figure></p><p>定时器会在1秒之后去执行callback这个回调函数<br>这就实现了一个简单的异步操作<br>异步操作会在将来的某个时间点触发一个函数调用<br>Ajax的异步请求也是一种异步操作</p><p>类似这种<strong>承诺将来会执行</strong>的对象 , 在ES6当中被统一规范为<code>Promise对象</code></p><p>这个对象的最大作用就是将执行代码和处理结果的回调函数进行了分离 , 从而在存在多重回调的情境当中 , 代码的可读性更强</p><p>一个简单的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        resolve(<span class="string">'success'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">'failed'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test);</span><br><span class="line"><span class="comment">//then传入的是resolve的实现</span></span><br><span class="line"><span class="comment">//catch传入的是reject的实现</span></span><br><span class="line">p1.then(<span class="built_in">console</span>.log).catch(<span class="built_in">console</span>.error);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">也可以用如下的方式, 实际效果同上</span></span><br><span class="line"><span class="comment">p1.then(console.log, console.log);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>Promise对象在创建的时候 , 传入的这个函数当中并不关心成功与失败具体的回调是什么 , 而只是关心何时去执行该回调函数</p><p>Promise对象有3种状态</p><ol><li><code>Fulfilled</code> 成功的状态</li><li><code>Rejected</code> 失败的状态</li><li><code>Pending</code> Promise 对象实例创建时候的初始状态</li></ol><p>可以由初始状态转换到成功状态 , 或者由初始状态转换到失败状态 , 并且不可逆<br>我们可以在初始化函数里面自己编写逻辑来确定何种情况下执行成功的回调函数( resolve ) 或者失败的函数( reject )<br>如果抛出错误而且没有进行捕获 , 则一定会执行失败的函数( reject )</p><p>如果对于某种状态 , 要执行多个回调函数<br>可以进行链式调用 , 也就是连缀多个<code>then</code>方法<br>前一个then方法中的返回值会作为下一个回调函数的参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        resolve(<span class="string">'success'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">'failed'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test);</span><br><span class="line">p1</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我是第一个回调函数:"</span> + msg);</span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我是第二个回调函数:"</span> + msg);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure></p><p>当然上面这种方式只能适用于多重回调函数中只有一个参数的情况<br>如果要传多个参数<br>必须使用数组的形式传递<br>比如参数中是<code>function([msg1, msg2])</code><br>前一个回调函数中<code>return [&quot;AA&quot;,&quot;BB&quot;]</code></p><hr><h4 id="Promise-all-和-Promise-race"><a href="#Promise-all-和-Promise-race" class="headerlink" title="Promise.all 和 Promise.race"></a>Promise.all 和 Promise.race</h4><p><code>Promise.all</code>方法可以接收一个Promise对象构成的数组作为参数 , 返回一个Promise对象<br>当数组中的这些Promise对象<strong>全部</strong>转换为成功状态的时候 , 这个对象才转换为成功状态 , 否则就转换为失败状态<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status = [<span class="literal">true</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(status[<span class="number">0</span>]) &#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="string">"failed"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(status[<span class="number">1</span>]) &#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="string">"failed"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test1);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test2);</span><br><span class="line">p1.then(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.log(<span class="string">"成功"</span> + msg))</span><br><span class="line">.catch(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.error(<span class="string">"失败"</span> + msg));</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.log(<span class="string">"成功"</span> + msg))</span><br><span class="line">.catch(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.error(<span class="string">"失败"</span> + msg));</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1,p2])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">msgs</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msgs <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//true</span></span><br><span class="line">  <span class="built_in">console</span>.log(msgs);<span class="comment">//[ 'success', 'success' ]</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//注意 : 这里的回调函数的参数就是所有Promise对象成功回调函数传入参数的数组</span></span><br><span class="line"><span class="comment">//(如果只有一个参数,则不构成数组)</span></span><br></pre></td></tr></table></figure></p><p><code>Promise.race</code>方法的用法与all类似 , 它返回的Promise对象是当数组中<strong>存在</strong>Promise对象转为成功状态的时候 , 它就转为成功状态 , 如果全是失败状态 , 它才是失败状态<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">status[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test1);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(test2);</span><br><span class="line">p3.then(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.log(<span class="string">"成功"</span> + msg))</span><br><span class="line">.catch(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.error(<span class="string">"失败"</span> + msg));</span><br><span class="line"></span><br><span class="line">p4.then(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.log(<span class="string">"成功"</span> + msg))</span><br><span class="line">.catch(<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.error(<span class="string">"失败"</span> + msg));</span><br><span class="line"><span class="built_in">Promise</span>.race([p3,p4])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">msgs</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//参数规则同Promise.all</span></span><br><span class="line">  <span class="built_in">console</span>.log(msgs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.3、shell(4)-使用技巧</title>
      <link href="/linux/2.3%E3%80%81shell(4)-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/linux/2.3%E3%80%81shell(4)-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h4 id="判断上一条命令执行是否成功"><a href="#判断上一条命令执行是否成功" class="headerlink" title="判断上一条命令执行是否成功"></a>判断上一条命令执行是否成功</h4><p><code>$?</code>变量的值是上一条命令执行的返回值<br>通过判断这个变量的值 , 可以知道上一条命令是否执行成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"执行成功"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"执行失败"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="逐行读取文件"><a href="#逐行读取文件" class="headerlink" title="逐行读取文件"></a>逐行读取文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> LINE</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$LINE</span> </span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.2、shell编程(3)-流程控制与函数</title>
      <link href="/linux/2.2%E3%80%81shell%E7%BC%96%E7%A8%8B(3)-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%87%BD%E6%95%B0/"/>
      <url>/linux/2.2%E3%80%81shell%E7%BC%96%E7%A8%8B(3)-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  command1</span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">  command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  command3</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>如果else没有语句执行<br>则不能留空 , 最好直接不写这个else<br><a id="more"></a><br>举例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ `ps ax | grep -c <span class="string">"ssh"</span>` -ge 1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"RUNNING"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># grep的-c参数代表对过滤后的行进行计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用test命令做判断</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> `ps ax | grep -c <span class="string">"ssh"</span>` -ge 1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"RUNNING"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=1 ; i&lt;=10 ; i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 注意使用(()), 里面的变量并不需要加$</span></span><br></pre></td></tr></table></figure><p><code>for (( ; ; ))</code> - 死循环</p><h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><p>bash支持对集合进行迭代的foreach类型语法<br>使用<code>for ... in ...</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># seq命令可以生成一个序列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 10`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样也是一个序列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代遍历一个数组</span></span><br><span class="line">arr=(<span class="string">"ab"</span> <span class="string">"cd"</span> <span class="string">"ef"</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable">$&#123;arr[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$item</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>如果一个命令返回的是一个集合 , 也可以执行循环迭代<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> `ls /usr/<span class="built_in">local</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$item</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>当然如果是找一个目录下的文件 , 也可以不用ls命令<br>for循环自带路径查找功能<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> /usr/<span class="built_in">local</span>/*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$item</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 注意路径不要加引号</span></span><br></pre></td></tr></table></figure></p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>while循环是在判断条件为false的时候结束循环<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cnt=1</span><br><span class="line"><span class="keyword">while</span> (( <span class="variable">$cnt</span>&lt;=5 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$cnt</span></span><br><span class="line">  <span class="built_in">let</span> <span class="string">"cnt++"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p><code>while :</code>或者<code>while true</code>表示死循环</p><h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h4><p>格式与while循环基本一致 , 只不过是当判断条件为true的时候结束循环<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cnt=1</span><br><span class="line">until (( <span class="variable">$cnt</span>&gt;=5 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$cnt</span></span><br><span class="line">  <span class="built_in">let</span> <span class="string">"cnt++"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><h4 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue"></a>break与continue</h4><p>表示跳出循环以及继续下一次循环 , 与其他语言当中类似</p><h3 id="多选择语句"><a href="#多选择语句" class="headerlink" title="多选择语句"></a>多选择语句</h3><p>类似其他语言当中的switch , bash当中使用case关键字<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"input a number:"</span></span><br><span class="line"><span class="comment"># read表示从终端读取用户输入内容</span></span><br><span class="line"><span class="built_in">read</span> num</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$num</span> <span class="keyword">in</span></span><br><span class="line">    1) <span class="built_in">echo</span> <span class="string">"数字1"</span></span><br><span class="line">    ;;</span><br><span class="line">    2) <span class="built_in">echo</span> <span class="string">"数字2"</span></span><br><span class="line">    ;;</span><br><span class="line">    3|4) <span class="built_in">echo</span> <span class="string">"3或者4"</span></span><br><span class="line">    ;;</span><br><span class="line">    ok) <span class="built_in">echo</span> <span class="string">"字符串ok"</span></span><br><span class="line">    ;;</span><br><span class="line">    *) <span class="built_in">echo</span> <span class="string">"其他内容"</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>shell当中可以自定义函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">myFunc</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"参数 <span class="variable">$1</span>,<span class="variable">$2</span>,<span class="variable">$3</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"所有参数:"</span></span><br><span class="line">  <span class="keyword">for</span> arg <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$arg</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line">myFunc <span class="string">"aa"</span> <span class="string">"bb"</span></span><br></pre></td></tr></table></figure></p><blockquote><p><strong>说明</strong> : </p><ol><li>与获取脚本的参数类似 , 使用<code>$序号</code>或者<code>${序号}</code>来获取<br>但是如果到了10 , 就必须写作<code>${10}</code> , 否则会与$1产生歧义</li><li><code>function</code> 关键字也可以省略</li></ol></blockquote><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>一个shell脚本当中可以引入另一个shell脚本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">. /home/sookie/test2.sh</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">source</span> /home/sookie/test2.sh</span><br></pre></td></tr></table></figure></p><p>被引入的文件并不需要可执行权限</p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.0、shell编程(1)-初见</title>
      <link href="/linux/2.0%E3%80%81shell%E7%BC%96%E7%A8%8B(1)-%E5%88%9D%E8%A7%81/"/>
      <url>/linux/2.0%E3%80%81shell%E7%BC%96%E7%A8%8B(1)-%E5%88%9D%E8%A7%81/</url>
      <content type="html"><![CDATA[<p><code>shell</code>俗称为<strong>壳</strong> , 是指提供使用者使用界面的软件<br>也叫做命令解析器<br>接收用户的命令 , 然后调用相应的应用程序<br>(接收命令的方式可以是命令行 , 也可以是图形界面)<br><a id="more"></a><br>在linux发展过程中 , 出现过很多的shell</p><ul><li><code>sh</code>(全称 Bourne Shell): 是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。<br>Bourne Shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell。</li><li><code>bash</code>（全称 Bourne Again Shell）: LinuxOS 默认的，它是 Bourne Shell 的扩展。<br>与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。</li><li><code>csh</code>(全称 C Shell): 是一种比 Bourne Shell更适合的变种 Shell，它的语法与 C 语言很相似。<br>Tcsh: 是 Linux 提供的 C Shell 的一个扩展版本。<br>Tcsh 包括命令行编辑，可编程单词补全，拼写校正，历史命令替换，作业控制和类似 C 语言的语法，他不仅和 Bash Shell 提示符兼容，而且还提供比 Bash Shell 更多的提示符参数。</li><li><code>ksh</code> (全称 Korn Shell): 集合了 C Shell 和 Bourne Shell 的优点并且和 Bourne Shell 完全兼容。</li><li><code>pdksh</code>: 是 Linux 系统提供的 ksh 的扩展。</li><li><code>pdksh</code> 支持人物控制，可以在命令行上挂起，后台执行，唤醒或终止程序。</li></ul><hr><ul><li><strong>交互式shell</strong> : 等待用户的命令 , 提交后就立即执行该命令</li><li><strong>非交互式shell</strong> : 不等待用户的输入 , 而是去读取写在文件中的命令代码 , 并且执行 , 这个文件就被称为shell脚本</li></ul><blockquote><p><strong>脚本</strong>其实就是短小的、用来让计算机自动化完成一系列工作的程序，这类程序可以用文本编辑器修改，不需要编译，通常是解释运行的。</p></blockquote><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>test.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World!"</span></span><br></pre></td></tr></table></figure></p><p>echo就是对传入的参数直接进行输出的程序<br>这个脚本的作用就是执行该命令<br><code>#!</code>是一个约定的标记 , 它告诉系统这个脚本要用什么解释器来执行</p><p>之后需要给这个文件加上可执行权限<br><code>chmod +x test.sh</code><br>然后就可以执行该脚本了<br><code>./test.sh</code></p><p>当然如果这样执行 , 是根据脚本内容中指定的解释器运行<br>如果没有指定 , 则使用系统默认的<br>我们也可以在运行时指定使用某个解释器<br>比如<code>sh test.sh</code></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>命名规则是可以包含 字母 数字 下划线 , 且以字母或者数字开头<br>使用变量则是在前面加<code>$</code>或者用<code>${}</code><br>( 当然如果在字符串内部使用 , 为了防止歧义, 必须用${} )<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">"sookie"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"my name is <span class="variable">$&#123;name&#125;</span>123"</span></span><br><span class="line"><span class="comment"># 大括号是为了帮助解释器识别变量名称的边界</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将该变量设为只读, 之后若再赋值就会报错</span></span><br><span class="line"><span class="built_in">readonly</span> name</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong> : 等号的两端不能加空格</p><h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>使用<code>unset 变量名称</code>可以删除对应的变量</p><blockquote><p>按照上面方式定义的变量实际上是这个shell脚本当中的<strong>局部变量</strong><br>在操作系统当中可以设置<strong>环境变量</strong> , 所有的shell脚本当中都可以直接使用</p></blockquote><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串的边界可以是单引号也可以是双引号 也可以无引号 , 但是实际应用当中有一些区别</p><ul><li><code>单引号</code>当中的内容都会原样输出 , 不可以使用转义字符 , 不可以使用字符串模板</li><li><code>双引号</code>当中的内容可以使用转义字符 , 也可以使用字符串模板</li><li><code>无引号</code>不可以使用转义字符 , 但是可以使用字符串模板<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">"sookie"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'my name is $&#123;name&#125;1'</span></span><br><span class="line"><span class="comment"># output: my name is $&#123;name&#125;1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"my name is <span class="variable">$&#123;name&#125;</span>1"</span></span><br><span class="line"><span class="comment"># output: my name is sookie1</span></span><br><span class="line"><span class="built_in">echo</span> my name is <span class="variable">$&#123;name&#125;</span>1</span><br><span class="line"><span class="comment"># output: my name is sookie1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><p>shell当中字符串的拼接不需要用加号<br>直接写在一起即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">"sookie"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'my name is '</span><span class="variable">$&#123;name&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取字符串长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#name&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#截取子串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;name:1:3&#125;</span> <span class="comment">#输出 ook</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将字符串内容当做命令执行</span></span><br><span class="line"><span class="built_in">echo</span> `ls /usr/<span class="built_in">local</span>`</span><br></pre></td></tr></table></figure></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>同大多数解释型语言一样 , 对于数组并没有严格的越界限制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数组定义, 元素之间用空白分割</span></span><br><span class="line">arr=(1 <span class="string">"aa"</span> 2.6)</span><br><span class="line"></span><br><span class="line"><span class="comment">#超出当前数组边界的下标形式赋值, 会将元素追加至末尾</span></span><br><span class="line">arr[6]=<span class="string">"bb"</span> <span class="comment">#当前数组当中有4个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取数组长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#arr[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#遍历数组</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable">$&#123;arr[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;item&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除数组元素</span></span><br><span class="line"><span class="built_in">unset</span> arr[1]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.1、shell编程(2)-从入门到重新入门</title>
      <link href="/linux/2.1%E3%80%81shell%E7%BC%96%E7%A8%8B(2)-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8/"/>
      <url>/linux/2.1%E3%80%81shell%E7%BC%96%E7%A8%8B(2)-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>在外部执行时可以给脚本传参<br>在脚本当中获取时 , <code>$0</code>是执行的文件路径<br><code>$1</code>代表第一个参数 , <code>$2</code>代表第二个参数 , 以此类推<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"当前文件:<span class="variable">$0</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第一个参数:<span class="variable">$1</span>"</span></span><br><span class="line"><span class="comment">#参数个数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"共传入<span class="variable">$#</span>个参数"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#遍历所有的参数</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$arg</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#脚本运行进程的ID</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PID:$$"</span></span><br></pre></td></tr></table></figure></p><p>执行脚本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./test.sh aa bb</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果参数内容包含空白, 要加引号才能作为一个参数传递</span></span><br><span class="line">./test.sh aa <span class="string">"bb cc"</span></span><br></pre></td></tr></table></figure></p><h4 id="变量的判断"><a href="#变量的判断" class="headerlink" title="变量的判断"></a>变量的判断</h4><p>对于shell脚本来说 , 传参通常是比较灵活的<br>所以经常需要判断是否传入了这个参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"包含第一个参数"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"未包含第一个参数"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>这是判断某个变量是否有值的方式<br>因为解释型语言的语法比较松散 , 对于变量先定义后使用没有严格要求<br>所以直接使用一个变量而不进行检查可能造成灾难性的后果</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>原生bash对数学运算的支持比较有限</p><h5 id="方法1-expression"><a href="#方法1-expression" class="headerlink" title="方法1 $((expression))"></a>方法1 <code>$((expression))</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num1=3</span><br><span class="line">num2=4</span><br><span class="line"><span class="built_in">echo</span> $((num1+num2))</span><br><span class="line"><span class="built_in">echo</span> $((num1**num2)) <span class="comment">#乘方</span></span><br></pre></td></tr></table></figure><p>变量的引用加不加$都可以 , 不能计算浮点数</p><h5 id="方法2-expression"><a href="#方法2-expression" class="headerlink" title="方法2 $[expression]"></a>方法2 <code>$[expression]</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1=3</span><br><span class="line">num2=4</span><br><span class="line"><span class="built_in">echo</span> $[num1+num2]</span><br></pre></td></tr></table></figure><p>变量的引用加不加$都可以 , 不能计算浮点数</p><h5 id="方法3-let关键字"><a href="#方法3-let关键字" class="headerlink" title="方法3 let关键字"></a>方法3 <code>let</code>关键字</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num1=3</span><br><span class="line">num2=4</span><br><span class="line"><span class="built_in">let</span> sum=<span class="variable">$num1</span>+<span class="variable">$num2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$sum</span></span><br></pre></td></tr></table></figure><p>变量的引用加不加$都可以 , 不能计算浮点数 , 加号两端不能有空格</p><h5 id="方法4-使用expr"><a href="#方法4-使用expr" class="headerlink" title="方法4 使用expr"></a>方法4 使用<code>expr</code></h5><p>这是一个内建的用于数学运算的命令<br>需要注意的是运算符两边必须要有空格<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">expr 2 + 6</span><br><span class="line">expr 4 - 9</span><br><span class="line"><span class="comment">#注意为了防止歧义 乘法要写 \* 而不能直接写 *</span></span><br><span class="line">expr 5 \* 4</span><br><span class="line"><span class="comment">#除法保留整数</span></span><br><span class="line">expr 9 / 2</span><br><span class="line"><span class="comment">#取余</span></span><br><span class="line">expr 9 % 2</span><br><span class="line"></span><br><span class="line"><span class="comment">#浮点数计算</span></span><br><span class="line">expr <span class="string">"3.9 + 1.8"</span>|bc</span><br><span class="line"><span class="comment">#scale表示保留到的小数位数</span></span><br><span class="line">expr <span class="string">"scale=3;1.2 * 8.73"</span>|bc</span><br></pre></td></tr></table></figure></p><h4 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h4><p>bash当中原生支持关系运算</p><p>比较是否相等<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"相等"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"不相等"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th>运算符</th><th>含义</th><th>其他表示方式</th><th>备注</th></tr></thead><tbody><tr><td>-eq</td><td>是否相等</td><td>==</td><td></td></tr><tr><td>-ne</td><td>是否不相等</td><td>!=</td><td></td></tr><tr><td>-gt</td><td>大于</td><td>&gt;</td><td></td></tr><tr><td>-lt</td><td>小于</td><td>&lt;</td><td></td></tr><tr><td>-ge</td><td>大于等于</td><td>>=</td><td>使用>=需要使用(( ))</td></tr><tr><td>-le</td><td>小于等于</td><td>&lt;=</td><td>使用&lt;=需要使用(( ))</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -ge <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"大于等于"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 等价于上面的写法, 注意用(( ))</span></span><br><span class="line"><span class="keyword">if</span> (( <span class="variable">$a</span> &gt;= <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"大于等于"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><blockquote><p>关系运算符只能用于整数 , 或者能够解析为整数的字符串</p></blockquote><h4 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h4><table><thead><tr><th>运算符</th><th>含义</th><th>其他表示方式</th></tr></thead><tbody><tr><td>!</td><td>非</td><td></td></tr><tr><td>-o</td><td>或</td><td>&#124;&#124;</td></tr><tr><td>-a</td><td>与</td><td>&amp;&amp;</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a小于10 并且 b大于20</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 10 -a <span class="variable">$b</span> -gt 20 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"yes"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"no"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 与上面的含义相同, 但是注意使用[[ ]]</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> -lt 10 &amp;&amp; <span class="variable">$b</span> -gt 20 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"yes"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"no"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong><br>推荐使用 <code>[[ ... ]]</code> 条件判断结构，而不是 <code>[ ... ]</code>，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、|| 操作符能够正常存在于 [[ ]] 条件判断结构中，但是如果出现在 [ ] 结构中的话，会报错。</p></blockquote><h4 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h4><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>=</td><td>两个字符串是否相同(区别于数字的比较)</td></tr><tr><td>!=</td><td>两个字符串是否不相同</td></tr><tr><td>-z</td><td>字符串长度为0返回true</td></tr><tr><td>-n</td><td>字符串长度不为0返回true</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"123"</span></span><br><span class="line">b=<span class="string">"456"</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> = <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"相同"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"不同"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 字符串本身也可以用作判断条件</span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="variable">$a</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"字符串为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>使用<code>-n</code>和<code>-z</code>的时候需要注意 , 需要在字符串变量引用上加双引号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$a</span>"</span>]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"OK"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>如果不加双引号 , 当a为空的时候 , 相当于执行<br><code>if [ -n ]</code> , 这个时候会把里面的<strong>-n</strong>当做一个普通字符串来处理 , 而不是运算符<br>自然每次都会是true , <strong>-z</strong> 同理</p><h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><p>一个字符串也可以表示一个文件(目录)的路径<br>使用这些方式可以获得这个文件的各种信息</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于0），不为空返回 true</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filepath=/usr/<span class="built_in">local</span>/test.txt</span><br><span class="line"><span class="keyword">if</span> [ -e filepath ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"文件存在"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"文件不存在"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>7.0、使用浏览器访问MongoDB</title>
      <link href="/MongoDB/7.0%E3%80%81%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEMongoDB/"/>
      <url>/MongoDB/7.0%E3%80%81%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEMongoDB/</url>
      <content type="html"><![CDATA[<p>MongoDB可以开启一个HTTP协议的端口提供REST服务 , 这个端口是数据库的服务端口加1000<br>比如数据库的服务端口是27017<br>那么开启REST服务之后 , 通过浏览器访问的端口就是28017<br><a id="more"></a><br>配置方式</p><ul><li><code>httpinterface</code> - 置为true表示开启HTTP协议端口</li><li><code>rest</code> - 置为true表示开启rest服务</li></ul><p>REST是mongoDB自带的一套API , 可以提供查询 , 但是不支持增删改操作 , 也不支持权限认证</p><p>配置完成之后重启服务 , 即可直接使用浏览器访问<br><img src="/images/MongoDB/browser.png" alt="browser"><br>在主页面可以查看到数据库的一些基本情况</p><hr><h4 id="执行查询操作"><a href="#执行查询操作" class="headerlink" title="执行查询操作"></a>执行查询操作</h4><p>列出databaseName数据库中的collectionName集合下的所有数据：<br><code>http://127.0.0.1:28017/databaseName/collectionName/</code><br>给上面的数据集添加一个limit参数限制返回10条<br><code>http://127.0.0.1:28017/databaseName/collectionName/?limit=-10</code><br>给上面的数据加上一个skip参数设定跳过5条记录<br><code>http://127.0.0.1:28017/databaseName/collectionName/?skip=5</code><br>同时加上limit限制和skip限制<br><code>http://127.0.0.1:28017/databaseName/collectionName/?skip=5&amp;limit=10</code><br>按条件{a:1}进行结果筛选（在关键字filter后面接上你的字段名）<br><code>http://127.0.0.1:28017/databaseName/collectionName/?filter_a=1</code><br>加条件的同时再加上limit限制返回条数<br><code>http://127.0.0.1:28017/databaseName/collectionName/?filter_a=1&amp;limit=-10</code><br>执行任意命令<br>如果要执行特定的命令，可以通过在admin.$cmd上面执行find命令，同样的你也可以在REST API里实现，如下，执行{listDatabase:1}命令：<br><code>http://localhost:28017/admin/$cmd/?filter_listDatabases=1&amp;limit=1</code><br>查询集合的记录个数：<code>http://host:port/db/$cmd/?filter_count=collection&amp;limit=1</code></p>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>6.1、快速搭建复制集</title>
      <link href="/MongoDB/6.1%E3%80%81%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%A4%8D%E5%88%B6%E9%9B%86/"/>
      <url>/MongoDB/6.1%E3%80%81%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%A4%8D%E5%88%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>在一个复制集当中 , 每个节点都需要具备独立的进程 , 所以要分别进行配置<br>这里需要用到几个重要的配置项<br><a id="more"></a></p><ul><li><code>replSet</code> - 复制集的名称 , 不同节点设置的复制集名称必须一致 , 才能保证这些节点被加入到同一个复制集当中</li><li><code>oplogSize</code> - 复制集的缓存大小 , 单位MB<br>( 不同的节点之间是通过oplog进行同步的 )</li></ul><p>当然 , 如果要在一台机器上模拟一个复制集 , 对于每个节点的实例需要配置不同的端口号</p><p>步骤</p><ol><li>编写配置文件 , 并启动多个实例</li><li>连接其中一个节点 , 执行配置<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">config = &#123;</span><br><span class="line">  _id:<span class="string">"TestReplSet"</span>,<span class="comment">//复制集的唯一标识</span></span><br><span class="line">  members:[</span><br><span class="line">  <span class="comment">//复制集当中的成员</span></span><br><span class="line">    &#123;<span class="attr">_id</span>:<span class="number">0</span>,<span class="attr">host</span>:<span class="string">"127.0.0.1:28001"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">_id</span>:<span class="number">1</span>,<span class="attr">host</span>:<span class="string">"127.0.0.1:28002"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">_id</span>:<span class="number">2</span>,<span class="attr">host</span>:<span class="string">"127.0.0.1:28003"</span>,</span><br><span class="line">    arbiterOnly:<span class="literal">true</span></span><br><span class="line">    <span class="comment">//置为仲裁节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里是相当于定义了一个名为config的全局变量<br><strong>其他的节点配置项</strong></p><blockquote><ul><li><code>priority</code> - 值为整数 ( 0~1000 ) , 默认是1 , 代表这个节点的权重 , 也就是成为主节点的机会 , 如果是0则永远不会成为主节点</li><li><code>hidden</code>  - 是否是隐藏节点 , true/false , 如果设置为true , 那么priority必须是0</li><li><code>vote</code> - 整数值 , 该节点是否具有投票权 , 值为0或1</li><li><code>slaveDelay</code> - 整数值 , 延迟时间复制数据 , 单位是秒 ( 对于一些误操作 , 可以利用延时挽回数据的损失 )</li></ul></blockquote><ol start="3"><li>执行复制集的初始化<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure></li></ol><p>稍等片刻即可完成复制集的搭建了</p>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>6.0、复制集</title>
      <link href="/MongoDB/6.0%E3%80%81%E5%A4%8D%E5%88%B6%E9%9B%86/"/>
      <url>/MongoDB/6.0%E3%80%81%E5%A4%8D%E5%88%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>复制集是由一组拥有相同数据集的mongod实例所组成的<code>集群</code><br><a id="more"></a><br>在这个复制集集群当中 , 各个节点可能有以下几种状态</p><ul><li><code>Primary</code> 主节点，一个复制集至多有一个节点处于Primary状态，只有主节点才对外提供读写服务。如果主节点挂掉，复制集将会投票选出一个备用节点成为新的主节点。</li><li><code>Secondary</code> 备用节点，复制集允许有多个备用节点，每个备用节点的数据与主节点的数据是完全同步的。</li><li><code>Recovering</code> 恢复中，当复制集中某台服务器挂掉或者掉线后数据无法同步，重新恢复服务后从其他成员复制数据，这时就处于恢复过程，数据同步后，该节点又回到备用状态。</li><li><code>Arbiter</code> 仲裁节点，该类节点可以不用单独存在，如果配置为仲裁节点，就主要负责在复本集中监控其他节点状态，投票选出主节点。该节点将不会用于存放数据。如果没有仲裁节点，那么投票工作将由所有节点共同进行。</li><li><code>Down</code> 无效节点，当服务器挂掉或掉线时就会处于该状态。</li></ul><p>复制集就是通过在备用节点上备份数据来提高数据库的可靠性<br>主节点会把所有的<strong>写操作</strong>记录到<code>oplog</code>当中<br>( 包括所有的增删改操作 )<br>备用节点通过oplog来进行数据的同步</p><blockquote><p>对于mysql的集群部署 , 拥有super权限的用户可以在备用节点执行写入操作 , mongoDB的备用节点是绝对不可以进行写操作的<br>而且mysql的集群可以拥有双主结构</p></blockquote><p>对于<strong>读操作</strong> , 默认情况下都是指向主节点的 , 虽然备用节点也在实时更新数据 , 但数据相对主节点来说也是有可能滞后的<br>如果对数据的时效性要求不是特别严格 , 也可以把读操作指向备用节点 , 从而分担主节点的压力</p><p>MongoDB复制集的特点</p><ul><li><strong>数据一致性</strong> - 主节点在一个集群中至多有一个 , 但并不是固定的 , 但可以设定节点的优先级 , 让一个性能更好的节点优先成为主节点</li><li><strong>大多数原则 ( 二分之一原则 )</strong> - 集群存活节点小于等于二分之一的时候 , 集群不可写 , 只可读<br>也就是说 , 能否选举出新的主节点 , 是由当前复制集成员的存活数量来决定的<br>即使之前的主节点正常工作 , 备用节点挂掉的过多 , 这个主节点也会自动降级为备用节点</li><li><strong>备用节点无法写入</strong> - 在备用节点写入数据有造成主键冲突的可能性</li><li><strong>自动容灾</strong> - 主节点挂掉以后 , 会自动从备用节点中选举出一个主节点</li></ul>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.3、Docker(3)-部署wordpress实践</title>
      <link href="/linux/3.3%E3%80%81Docker(3)-WordPress%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5/"/>
      <url>/linux/3.3%E3%80%81Docker(3)-WordPress%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<p>站在 Docker 的角度，软件就是容器的组合：业务逻辑容器、数据库容器、储存容器、队列容器……Docker 使得软件可以拆分成若干个标准化容器，然后像搭积木一样组合起来。</p><p>这正是微服务（microservices）的思想：软件把任务外包出去，让各种外部服务完成这些任务，软件本身只是底层服务的调度中心和组装层。<br><a id="more"></a><br><img src="/images/linux/20180505231057.png" alt="微服务"></p><p>微服务很适合用 Docker 容器实现，每个容器承载一个服务。一台计算机同时运行多个容器，从而就能很轻松地模拟出复杂的微服务架构。</p><p><img src="/images/linux/20180505231120.png" alt="应用解耦"></p><p>现在尝试实践搭建一个wordpress的服务<br>这是一个php编写的博客系统</p><p>运行需要依赖的环境有 : mysql  php  apache<br>当然也包括php的扩展包mysqli , 用于实现mysql数据库的连接</p><h3 id="自建wordpress容器"><a href="#自建wordpress容器" class="headerlink" title="自建wordpress容器"></a>自建wordpress容器</h3><h4 id="尝试启动一个php-apache容器"><a href="#尝试启动一个php-apache容器" class="headerlink" title="尝试启动一个php-apache容器"></a>尝试启动一个php-apache容器</h4><p>创建应用目录 php-demo , 然后进入该目录执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">-d \</span><br><span class="line">--rm \</span><br><span class="line">--name wordpress \</span><br><span class="line">--volume <span class="string">"<span class="variable">$PWD</span>/"</span>:/var/www/html \</span><br><span class="line">php:7.2-apache</span><br></pre></td></tr></table></figure></p><blockquote><p>linux当中 , 命令末尾的<code>\</code>代表换行继续输入命令 , 而不立即执行</p></blockquote><ul><li><code>-d</code> : 容器在后台运行 , 输出内容不会打印到终端(可以用docker logs [ContainerId]查看)</li><li><code>--rm</code> : 容器运行停止后 , 自动删除容器文件</li><li><code>--name</code> : 指定容器的名字</li><li><code>--volume</code> : 指定目录映射 , 这里表示把当前目录映射到容器内的/var/www/html目录<br>这个目录是apache服务器对外访问的默认目录<br>这样我们就可以直接在当前目录中添加php页面文件进行访问</li></ul><p>成功从远程仓库下载<strong>php:7.2-apache</strong>镜像并启动容器之后<br>会提示容器对外访问的IP地址 , 比如<strong>172.17.0.2</strong> , 可以直接访问这个地址</p><p>但是此时还没有在访问目录中添加php页面<br>可以写个测试页面index.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>此时再访问就可以看到php信息了</p><h4 id="安装wordpress"><a href="#安装wordpress" class="headerlink" title="安装wordpress"></a>安装wordpress</h4><p>删掉index.php<br>官网下载wordpress安装包 , 直接解压到该目录下<br>然后访问就可以看到wordpress的初始化页面了<br><img src="/images/linux/wordpress_init.png" alt="wordpress_init"><br>但是目前还没有mysql的容器</p><h4 id="运行mysql容器"><a href="#运行mysql容器" class="headerlink" title="运行mysql容器"></a>运行mysql容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">-d \</span><br><span class="line">--rm \</span><br><span class="line">--name wordpressdb \</span><br><span class="line">--env MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--env MYSQL_DATABASE=wordpress \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p><code>env</code>代表向容器中传入的环境变量 , 容器中的mysql会根据环境变量创建数据库以及设置root用户的密码</p><h4 id="添加mysqli扩展"><a href="#添加mysqli扩展" class="headerlink" title="添加mysqli扩展"></a>添加mysqli扩展</h4><p>PHP 的官方 image 不带有 mysqli 扩展，必须自己新建一个image</p><p>新建<code>Dockerfile</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM php:7.2-apache</span><br><span class="line">RUN docker-php-ext-install mysqli</span><br><span class="line">CMD apache2-foreground</span><br></pre></td></tr></table></figure></p><p>打包镜像时安装mysqli的扩展 , 运行容器时启动apache<br>之后构建image<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t php-with-mysql .</span><br></pre></td></tr></table></figure></p><h4 id="运行php-with-mysql"><a href="#运行php-with-mysql" class="headerlink" title="运行php-with-mysql"></a>运行php-with-mysql</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">-d \</span><br><span class="line">--rm \</span><br><span class="line">--volume <span class="string">"<span class="variable">$PWD</span>/"</span>:/var/www/html \</span><br><span class="line">--link wordpressdb:mysqlhost \</span><br><span class="line">php-with-mysql</span><br></pre></td></tr></table></figure><p>link是实现容器之间通信的一种机制 , 表示该容器要链接到<strong>wordpressdb</strong>容器 , 冒号表示该容器主机的名称是<strong>mysqlhost</strong><br>(之后配置数据库连接时 , 主机名称不是localhost , 而是<strong>mysqlhost</strong>)</p><p>由于wordpress在运行时需要写入配置文件( 也包括自身版本的更新 )<br>我们可以给当前目录添加写权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 ./</span><br></pre></td></tr></table></figure></p><p>之后再访问172.17.0.2 , 填写数据库配置信息即可完成</p><h3 id="使用wordpress官方镜像"><a href="#使用wordpress官方镜像" class="headerlink" title="使用wordpress官方镜像"></a>使用wordpress官方镜像</h3><p>首先仍然是要启动mysql的容器 , 参考上面的<strong>运行mysql容器</strong><br>然后使用wordpress的官方镜像构建容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">-d \</span><br><span class="line">--rm \</span><br><span class="line">--name wordpress \</span><br><span class="line">--env WORDPRESS_DB_PASSWORD=123456 \</span><br><span class="line">--link wordpressdb:mysqlhost \</span><br><span class="line">wordpress</span><br></pre></td></tr></table></figure></p><p>环境变量<code>WORDPRESS_DB_PASSWORD</code>是 MySQL 容器的根密码<br>运行之后的访问和初始化操作和前一种方式相同</p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.2、Docker(2)-使用技巧</title>
      <link href="/linux/3.2%E3%80%81Docker(2)-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/linux/3.2%E3%80%81Docker(2)-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h3 id="与宿主机共享网络"><a href="#与宿主机共享网络" class="headerlink" title="与宿主机共享网络"></a>与宿主机共享网络</h3><p>默认情况下 , 在宿主机可以根据容器暴露出的端口来访问容器中启动的服务<br>但是由于容器的隔离 , 在容器内部是无法访问宿主机的服务的<br>如果有这种需要 , 可以在启动容器的时候添加参数<code>--net=host</code></p><p>作用就是使容器和宿主机共用网络<br><a id="more"></a></p><h3 id="镜像的备份与恢复"><a href="#镜像的备份与恢复" class="headerlink" title="镜像的备份与恢复"></a>镜像的备份与恢复</h3><p>docker的一个重要目标就是方便实现迁移<br>对于一个镜像 , 也可以打包出来作为备份 , 或者迁移到其他机器上</p><p>对于镜像的导出与导入操作 , 使用的是<code>save</code>和<code>load</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line">docker save -o dump.tar [ImageId]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复</span></span><br><span class="line">docker load &lt; dump.tar</span><br></pre></td></tr></table></figure></p><blockquote><p>继承的镜像也会一同打包进去<br>再次导入之后 , 该镜像就不再作为一个子镜像存在了<br>比如该镜像继承jre镜像 , 那么打包之后的tar包当中直接包含jre镜像的内容</p></blockquote><h3 id="容器的导出与导入"><a href="#容器的导出与导入" class="headerlink" title="容器的导出与导入"></a>容器的导出与导入</h3><p>要将一个容器进行导出与导入 , 使用的是<code>export</code>和<code>import</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出容器</span></span><br><span class="line">docker <span class="built_in">export</span> [ContainerId] &gt; demo.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入容器</span></span><br><span class="line">docker import demo.tar [ImageName][:Tag]</span><br></pre></td></tr></table></figure></p><h3 id="容器内时区的错误"><a href="#容器内时区的错误" class="headerlink" title="容器内时区的错误"></a>容器内时区的错误</h3><p>如果容器当中的程序在执行中需要获取当前时间并进行格式化<br>若没有特别指定 , 通常会读取操作系统的时区设定<br>由于容器内是一个独立的环境 , 这个设定有可能不正确</p><p>如果出现这类错误( 比如程序获取当前时间写入到数据库 , 时间提前了8小时 )<br>可以在构建镜像的时候执行如下命令 , 来指定容器内的时区<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone</span><br></pre></td></tr></table></figure></p><p>也就是设定时区为东八区</p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.1、Docker(1)-初见</title>
      <link href="/linux/3.1%E3%80%81Docker(1)-%E5%88%9D%E8%A7%81/"/>
      <url>/linux/3.1%E3%80%81Docker(1)-%E5%88%9D%E8%A7%81/</url>
      <content type="html"><![CDATA[<p><strong>程序部署运维的痛点</strong><br>当今软件越发庞大复杂 , 在服务器部署运行一个软件之前通常需要完成:</p><ol><li>操作系统的设置</li><li>各种库和组件的安装</li></ol><p>只有他们都正确 , 软件才能正常运行<br>当需要迁移的时候 , 这些事情都要重来一遍<br>并且由于各种原因 , 还可能会产生不一样的问题 , 费时费力<br><a id="more"></a><br>于是就有了独立运行容器的需求 , 从根本上解决这个问题<br>让软件带环境安装<br>给软件一个独立的环境去运行 , 并且这个软件所有的依赖都在这个环境里面</p><p><strong>虚拟机</strong><br>虚拟机是一种针对上述问题的解决方案 , 在一个操作系统里面构造一个虚拟环境运行另一个操作系统<br>但是通常会有以下缺陷</p><ol><li><p>资源占用多<br>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p></li><li><p>冗余步骤多<br>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p></li><li><p>启动慢<br>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p></li></ol><p><strong>Docker</strong><br>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器<br>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行</p><p>ubuntu系统直接使用apt安装即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install docker.io</span><br></pre></td></tr></table></figure></p><h3 id="镜像-image"><a href="#镜像-image" class="headerlink" title="镜像(image)"></a>镜像(image)</h3><p>docker把程序及其依赖 , 打包在image文件里面 , 称之为镜像文件<br>它可以看做是生成容器的模板 , 一个镜像文件可以生成多个运行容器实例<br>使用<code>docker image COMMAND</code>可以实现对镜像的相关操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本机所有的镜像</span></span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定镜像</span></span><br><span class="line">docker image rm [ImageId]</span><br></pre></td></tr></table></figure><p><img src="/images/linux/查看所有镜像.png" alt="查看所有镜像"><br>每个镜像都有一个唯一ID , 是一串hash码<br>我们可以根据这个ID来对指定的镜像进行操作<br>当然也不需要必须写完整 , 只要能找到一个唯一的镜像就可以了<br>比如执行<code>docker image rm 56a</code>就可以删除掉express-demo这个镜像了<br>当然使用<code>docker image rm express-demo</code>也是可以的</p><blockquote><p>docker中的操作大都是这种模式</p></blockquote><h3 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h3><p>容器就是程序运行的独立虚拟环境了 , 容器由镜像生成<br>( 镜像可以认为是一种存储的结构 , 而容器才是实际运行的实例 )<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看运行中的容器</span></span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行指定的镜像</span></span><br><span class="line">docker container run [ImageId]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行指定的容器</span></span><br><span class="line">docker container start [ContainerId]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止指定的镜像</span></span><br><span class="line">docker container stop [ContainerId]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行终止指定的镜像</span></span><br><span class="line">docker container <span class="built_in">kill</span> [ContainerId]</span><br></pre></td></tr></table></figure></p><p>使用<code>run</code>每次都会生成一个新的容器文件 , 如果要复用指定的容器 , 可以使用<code>start</code></p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>这是一个官方提供的最简单的镜像 , 可以用来熟悉docker的基本用法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从官方仓库拉取镜像</span></span><br><span class="line">docker image pull hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行这个image</span></span><br><span class="line">docker container run hello-world</span><br></pre></td></tr></table></figure></p><blockquote><p><code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤</p></blockquote><p>这个镜像当中的程序就是在控制台输出一段内容 , 是docker的一些基本介绍</p><blockquote><p>image文件生成的容器实例, 本身也是一个文件<br>默认情况下即使容器停止运行 , 这个文件也还是在的 , 不会被删除<br>可以使用<code>docker container ls -all</code>来查看所有容器文件<br>使用<code>docker container rm [ContainerId]</code>来删除指定的容器文件</p></blockquote><h3 id="尝试制作自己的image并运行"><a href="#尝试制作自己的image并运行" class="headerlink" title="尝试制作自己的image并运行"></a>尝试制作自己的image并运行</h3><p>这里用一个简单的nodejs项目作为例子 , 尝试制作一个自己的image<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir express-demo</span><br><span class="line"><span class="built_in">cd</span> express-demo</span><br><span class="line">npm init</span><br><span class="line">npm install express --save</span><br></pre></td></tr></table></figure></p><p>index.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">7001</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.send(<span class="string">"&lt;h1&gt;Hello World&lt;/h1&gt;"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = app.listen(port, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"在%s端口执行监听"</span>, port)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h4><p>在此之前 , 我们也可以在项目目录里面加一个<code>.dockerignore</code><br>这个文件表示打包image的时候需要排除在外的内容( 很类似.gitignore )<br>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br></pre></td></tr></table></figure></p><p>创建Dockerfile文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:9.11</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install</span><br><span class="line">EXPOSE 7001</span><br></pre></td></tr></table></figure></p><ul><li><code>FORM node:9.11</code> 继承自官方的node镜像 , 冒号后面是标签(通常是版本号)</li><li><code>COPY . /app</code> 将当前目录下的所有文件(除了.dockerignore排除的)都拷贝到image文件的app目录下</li><li><code>WORKDIR /app</code> 工作路径为/app</li><li><code>RUN npm install</code> 在打包image的时候需要执行的 ( 所以这个nodejs项目的依赖包会被打包进image当中 )</li><li><code>EXPOSE 7001</code> 运行时暴露出的端口号</li></ul><h4 id="打包与运行"><a href="#打包与运行" class="headerlink" title="打包与运行"></a>打包与运行</h4><p>打包image<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t express-demo:1.0 .</span><br><span class="line"><span class="comment"># -t参数是指定该image的名字 , 冒号后面是标签(默认是latest)</span></span><br><span class="line"><span class="comment"># . 表示打包当前目录下的文件</span></span><br></pre></td></tr></table></figure></p><p>运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --rm -p 8000:7001 -it express-demo:1.0 /bin/bash</span><br></pre></td></tr></table></figure></p><ul><li><code>--rm</code> 容器停止运行时自动删除容器文件</li><li><code>-p</code> 表示端口映射 , 这里是将容器的7001端口映射到本地的8000端口</li><li><code>-it</code> 容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器</li><li><strong>express-demo:1.0</strong> image的名称和标签(当然直接用image的id也可以)</li><li><strong>/bin/bash</strong> 容器启动后第一个执行的命令 , 这里启动bash , 保证可以使用shell</li></ul><p>执行之后会进入到命令提示符<code>root@2604657cb46c:/app#</code><br>在这里我们就可以执行<strong>node index.js</strong>来运行程序了</p><p>运行之后在外部当然是要通过8000端口来访问</p><h4 id="自动化运行"><a href="#自动化运行" class="headerlink" title="自动化运行"></a>自动化运行</h4><p>上面的方式在启动容器之后还要手动运行程序 , 还是显得有些繁琐了<br>我们可以在Dockerfile里面加一个CMD的选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:9.11</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install</span><br><span class="line">EXPOSE 7001</span><br><span class="line">CMD node index.js</span><br></pre></td></tr></table></figure></p><p>区别于RUN , CMD是在容器启动的时候执行的 , 而RUN是在打包image的时候执行的</p><blockquote><p>当然 , 有了这个入口 , 就可以自由发挥了<br>比如程序启动比较繁琐 , 完全可以在image里面编写一个shell脚本<br>然后容器启动的时候运行这个脚本即可</p></blockquote><h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><p>查看指定容器的输出 , 即容器里面Shell的标准输出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs [ContainerId]</span><br></pre></td></tr></table></figure></p><p>进入一个正在运行的容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">exec</span> -it [ContainerID] /bin/bash</span><br></pre></td></tr></table></figure></p><p>之后就可以在容器的shell当中执行命令了</p><p>有时候我们需要把容器当中运行产生的文件拷贝出来<br>可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container cp [ContainerId]:[/app/run.log] /home/sookie</span><br></pre></td></tr></table></figure></p><p>上面的命令表示将指定容器的/app/run.log文件拷贝到本地的/home/sookie目录下</p><h4 id="使用国内镜像仓库"><a href="#使用国内镜像仓库" class="headerlink" title="使用国内镜像仓库"></a>使用国内镜像仓库</h4><p>出于众所周知的原因 , 官方仓库的速度比较慢<br>所以可以把官方镜像的下载地址改为国内的镜像仓库</p><p>Docker 官方中国区<br><a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a><br>网易<br><a href="http://hub-mirror.c.163.com" target="_blank" rel="noopener">http://hub-mirror.c.163.com</a><br>ustc<br><a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn</a></p><h5 id="方法1-registry-mirror参数"><a href="#方法1-registry-mirror参数" class="headerlink" title="方法1 registry-mirror参数"></a>方法1 registry-mirror参数</h5><p>直接设置 –registry-mirror 参数，仅对当前的命令有效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world --registry-mirror=https://docker.mirrors.ustc.edu.cn</span><br></pre></td></tr></table></figure></p><h5 id="方法2-修改-etc-default-docker"><a href="#方法2-修改-etc-default-docker" class="headerlink" title="方法2 修改/etc/default/docker"></a>方法2 修改/etc/default/docker</h5><p>加入 DOCKER_OPTS=”镜像地址”，可以有多个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=&quot;--registry-mirror=https://docker.mirrors.ustc.edu.cn&quot;</span><br></pre></td></tr></table></figure></p><h5 id="方法3-修改-etc-docker-daemon-json"><a href="#方法3-修改-etc-docker-daemon-json" class="headerlink" title="方法3 修改/etc/docker/daemon.json"></a>方法3 修改/etc/docker/daemon.json</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"registry-mirrors"</span>: [<span class="string">"https://docker.mirrors.ustc.edu.cn"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>新版的docker比较推荐方法3</p></blockquote>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5.2、关联映射</title>
      <link href="/MongoDB/5.2%E3%80%81%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84/"/>
      <url>/MongoDB/5.2%E3%80%81%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84/</url>
      <content type="html"><![CDATA[<p>在Maven项目中引入marphia的包<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mongodb.morphia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>morphia<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p><img src="/images/MongoDB/mapping1.png" alt="mapping"><br>maven会自动引入一些其他的依赖jar包 , 否则关联映射就无法正常执行</p><hr><h4 id="命令行执行"><a href="#命令行执行" class="headerlink" title="命令行执行"></a>命令行执行</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.user.insert(&#123;</span><br><span class="line">  username:<span class="string">"test_user"</span>,</span><br><span class="line">  role : &#123;</span><br><span class="line">    $ref:<span class="string">"role"</span>,</span><br><span class="line">    $id:ObjectId(<span class="string">"576d47b8cc7a1342538343fc"</span>),</span><br><span class="line">    $db:<span class="string">"model_db"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong> : 在NoSQL型数据库当中 , 并不鼓励使用类似于关系型数据库的外键关联<br>但是为了程序的查询方便 , 提供了这种程序驱动可以识别的表示形式<br>其实并没有外键关联的检查 , 与普通的文档没有任何区别</p></blockquote><h4 id="使用morphia的注解实现引用"><a href="#使用morphia的注解实现引用" class="headerlink" title="使用morphia的注解实现引用"></a>使用morphia的注解实现引用</h4><h5 id="多对一关联"><a href="#多对一关联" class="headerlink" title="多对一关联"></a>多对一关联</h5><p><code>@Reference</code>注解包含的属性</p><ul><li>concreteClass - 关联的目标类</li><li>idOnly - 只保存从表的数据ID ( 与关系型数据库的外键字段类似 )</li><li>ignoreMissing - 忽略不能解决的引用</li><li>lazy - 懒加载 , 默认是false ( 在双向关联情况下 , 如果双端都不是懒加载 , 会形成死循环 )</li><li>value - 在集合中存储的字段名 , 默认是类中的属性名</li></ul><p>角色表<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(value=<span class="string">"role"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> ObjectId id;</span><br><span class="line">  <span class="keyword">private</span> String roleName;</span><br><span class="line">  <span class="keyword">private</span> String remark;</span><br><span class="line"><span class="comment">//getter与setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用户表<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(value=<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> ObjectId id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> denger;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Reference</span>(value=<span class="string">"roleId"</span>,idOnly=<span class="keyword">true</span>)</span><br><span class="line">  <span class="keyword">private</span> Role role;</span><br><span class="line"><span class="comment">//getter与setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">"papapa"</span>);</span><br><span class="line"></span><br><span class="line">Role role = <span class="keyword">new</span> Role();</span><br><span class="line">role.setRoleName(<span class="string">"测试角色2"</span>);</span><br><span class="line"></span><br><span class="line">user.setRole(role);</span><br><span class="line">ds.save(role);<span class="comment">//ds -&gt; Datastore</span></span><br><span class="line">ds.save(user);</span><br></pre></td></tr></table></figure></p><p><img src="/images/MongoDB/mapping2.png" alt="mapping"></p><h5 id="一对多关联"><a href="#一对多关联" class="headerlink" title="一对多关联"></a>一对多关联</h5><p>用法与多对一也是类似的 , 数据库中会在 <strong>一</strong> 的那端以数组形式保存数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(value=<span class="string">"role"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> ObjectId id;</span><br><span class="line">  <span class="keyword">private</span> String roleName;</span><br><span class="line">  <span class="keyword">private</span> String remark;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Reference</span>(<span class="string">"user"</span>)</span><br><span class="line">  <span class="keyword">private</span> List&lt;User&gt; users;</span><br><span class="line"><span class="comment">//getter与setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Role role = <span class="keyword">new</span> Role();</span><br><span class="line">  role.setRoleName(<span class="string">"测试角色2"</span>);</span><br><span class="line">  User user1 = <span class="keyword">new</span> User();</span><br><span class="line">  user1.setUsername(<span class="string">"pppp"</span>);</span><br><span class="line">  </span><br><span class="line">  User user2 = <span class="keyword">new</span> User();</span><br><span class="line">  user2.setUsername(<span class="string">"oooo"</span>);</span><br><span class="line">  </span><br><span class="line">  List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">  users.add(user1);</span><br><span class="line">  users.add(user2);</span><br><span class="line">  userDao.save(user1);</span><br><span class="line">  userDao.save(user2);</span><br><span class="line">  </span><br><span class="line">  role.setUsers(users);</span><br><span class="line">  roleDao.save(role);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/MongoDB/mapping3.png" alt="mapping"></p>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5.1、morphia</title>
      <link href="/MongoDB/5.1%E3%80%81morphia/"/>
      <url>/MongoDB/5.1%E3%80%81morphia/</url>
      <content type="html"><![CDATA[<p><code>Morphia</code> 是一个轻量级的类型安全的 Java 类库，用来将在 MongoDB 和 Java 对象之间进行映射<br>对MongoDB的API进行了一些封装 , 类似hibernate<br><a id="more"></a><br><a href="http://mvnrepository.com/artifact/org.mongodb.morphia/morphia" target="_blank" rel="noopener">maven仓库jar包</a></p><hr><p>由于使用MongoDB的原生jar包无法对实体类执行映射操作<br>如果有一个实体类的对象 , 比如要手工转化为Document对象才可以保存到数据库<br>同样 , 查询获得的结果也是Document对象 , 而不是实体类对象 , 使用相对不便</p><ol><li><strong>创建实体类 , 并添加注解</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(value=<span class="string">"t_person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String address;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//getter与setter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可以在@Entry注解的value属性指定该实体类对应的集合名称<br>如果不指定 , 就默认为这个类的名称</p><ol start="2"><li><strong>使用junit进行单元测试</strong><br>首先编写测试类的基类 , 需要进行连接的初始化和执行完毕后的连接关闭<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitTestBase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Mongo mongo;</span><br><span class="line">  <span class="keyword">protected</span> Morphia morphia;</span><br><span class="line">  <span class="keyword">protected</span> Datastore ds;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">27017</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_NAME = <span class="string">"demo"</span>;</span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mongo = <span class="keyword">new</span> MongoClient(HOST, PORT);</span><br><span class="line">    morphia = <span class="keyword">new</span> Morphia();</span><br><span class="line">    ds = morphia.createDatastore(mongo, DB_NAME);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@After</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">desotry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mongo.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>如果需要用户认证 , 直接对MongoClientt对象执行操作即可<br>方式参考前一篇笔记</p><ol start="3"><li><strong>增删改查操作</strong><br>通常的增删改查方法如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongodbTest</span> <span class="keyword">extends</span> <span class="title">UnitTestBase</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">"Molly"</span>, <span class="string">"excuse me?"</span>, <span class="number">20</span>);</span><br><span class="line">    ds.save(person);</span><br><span class="line">    <span class="comment">// 注意:在执行save操作的时候, 如果对应的集合不存在, 则自动创建该集合</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    person.setId(<span class="number">1002</span>);</span><br><span class="line">    <span class="comment">//删除操作是根据主键来删除, 实体类中已经用@Id设定了主键</span></span><br><span class="line">    ds.delete(person);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    person.setId(<span class="number">1002</span>);</span><br><span class="line">    UpdateOperations&lt;Person&gt; ops = ds.createUpdateOperations(Person.class);</span><br><span class="line">    ops.set(<span class="string">"name"</span>, <span class="string">"Polly"</span>);</span><br><span class="line">    ops.set(<span class="string">"address"</span>, <span class="string">"000"</span>);</span><br><span class="line">    <span class="comment">//第一个参数是过滤条件, 第二个参数是需要修改的属性和值的集合</span></span><br><span class="line">    ds.update(person, ops);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * update方法是修改所有符合条件的数据</span></span><br><span class="line"><span class="comment">     * 如果只需要修改符合条件的第一条数据, 可以使用</span></span><br><span class="line"><span class="comment">     * ds.updateFirst(query, ops)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Query&lt;Person&gt; result = ds.find(Person.class, <span class="string">"name"</span>, <span class="string">"Molly"</span>);</span><br><span class="line">    <span class="comment">//第二个与第三个参数是查询的条件</span></span><br><span class="line">    <span class="keyword">for</span>(Person per : result) &#123;</span><br><span class="line">      System.out.println(per);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在查询当中, 如果集合中的文档有额外的字段, 会被忽略</span></span><br><span class="line"><span class="comment">     * 实体类中有而文档中没有的字段</span></span><br><span class="line"><span class="comment">     * 查询结果的对象中对应属性就是null或者基本数据类型的默认值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>以上的增删改查方法都有多种重载形式 , 在这里就不一一举例了<br>具体的可以查看morphia源代码</p><hr><p>上述方式是使用注解添加类的映射<br>如果不用注解 , 也可以手动把某些类加载到morphia当中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将若干个类加入到映射</span></span><br><span class="line">morphia.map(Person.class);</span><br><span class="line"><span class="comment">//将某个包中的所有类添加到映射</span></span><br><span class="line">morphia.mapPackage(<span class="string">"com.entry"</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5.0、Java操作MongoDB数据库</title>
      <link href="/MongoDB/5.0%E3%80%81Java%E6%93%8D%E4%BD%9CMongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/MongoDB/5.0%E3%80%81Java%E6%93%8D%E4%BD%9CMongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>所需要的<a href="http://mvnrepository.com/artifact/org.mongodb/mongo-java-driver" target="_blank" rel="noopener">驱动jar包</a></p><a id="more"></a><h4 id="一-连接MongoDB"><a href="#一-连接MongoDB" class="headerlink" title="(一) 连接MongoDB"></a>(一) 连接MongoDB</h4><p>一个<code>MongoClient</code>的实例代表一个客户端连接<br>从中可以获取到需要使用的数据库<code>MongoDatabase</code>对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MongoClient client = <span class="keyword">new</span> MongoClient(<span class="string">"localhost"</span>,<span class="number">27017</span>);</span><br><span class="line">MongoDatabase db = client.getDatabase(<span class="string">"demo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用完毕后, 需要关闭客户端连接</span></span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure></p><p>MongoClient是<strong>线程安全</strong>的，可以在多程程环境中共享同一个MongoClient。通常来说，一个应用程序中，只需要生成一个全局的MongoClient实例</p><h4 id="二-认证"><a href="#二-认证" class="headerlink" title="(二) 认证"></a>(二) 认证</h4><p>上述方式是在数据库没有添加用户认证的情况下实现的连接<br>认证信息用<code>MongoCredential</code>对象表示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ServerAddress address = <span class="keyword">new</span> ServerAddress(<span class="string">"localhost"</span>, <span class="number">27017</span>);</span><br><span class="line"><span class="comment">// 参数分别是 用户名 所在数据库 密码(char数组形式)</span></span><br><span class="line">MongoCredential credential = MongoCredential.createCredential(<span class="string">"sookie"</span>, <span class="string">"demo"</span>, <span class="string">"123456"</span>.toCharArray());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于构造函数接受一个List对象, 所以需要进行一次包装</span></span><br><span class="line">MongoClient client = <span class="keyword">new</span> MongoClient(address, Arrays.asList(credential));</span><br><span class="line"></span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure></p><h4 id="三-获取一个集合"><a href="#三-获取一个集合" class="headerlink" title="(三) 获取一个集合"></a>(三) 获取一个集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MongoDatabase db = client.getDatabase(<span class="string">"demo"</span>);</span><br><span class="line"><span class="comment">//获取指定名称的集合</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = db.getCollection(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure><p>在集合对象上就可以直接进行增删改查的操作</p><h4 id="四-数据对象"><a href="#四-数据对象" class="headerlink" title="(四) 数据对象"></a>(四) 数据对象</h4><p>或者也可以称为文档 , 本身是一个JSON<br>使用<code>Document</code>对象来表示<br>任何需要JSON的地方都通用这个对象( 包括数据的查询结果 )</p><h4 id="五-插入与删除"><a href="#五-插入与删除" class="headerlink" title="(五) 插入与删除"></a>(五) 插入与删除</h4><p>Document中的静态方法parse可以将JSON字符串转化为Document对象 , 用于插入方法的参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"Sookie"</span>,<span class="number">18</span>);</span><br><span class="line">Document doc = Document.parse(JSON.toJSONString(person));</span><br><span class="line">collection.insertOne(doc);</span><br></pre></td></tr></table></figure></p><p>insert相关的方法也可以接受Map对象等作为参数 , 具体的参考源码</p><p>删除使用<code>deleteOne</code>和<code>deleteMany</code>方法<br>前者表示删除符合条件的一条数据 , 后者表示删除符合条件的多条数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bson filter = <span class="keyword">new</span> BasicDBObject(<span class="string">"age"</span>,<span class="number">18</span>);</span><br><span class="line">collection.deleteMany(filter);</span><br></pre></td></tr></table></figure><blockquote><p><code>Bson</code>是一个接口 , <code>BasicDBObject</code>是这个接口的一个实现类 , 可以作为查询条件</p></blockquote><h4 id="六-查询"><a href="#六-查询" class="headerlink" title="(六) 查询"></a>(六) 查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行查询操作, 方法名称与终端所用的指令类似</span></span><br><span class="line">FindIterable&lt;Document&gt; result = collection.find();</span><br><span class="line"><span class="keyword">for</span> (Document doc : result) &#123;</span><br><span class="line">  System.out.println(doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>find函数也有Bson作为参数的重载形式 , 查询条件的创建方式同上面的删除操作<br>包含$操作符的查询条件同样可以使用BasicDBObject创建</p>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>crontab-定时任务</title>
      <link href="/linux/crontab-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/linux/crontab-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>linux下创建定时任务通常使用<code>crontab</code>命令<br>使用<code>cron表达式</code>来指定执行的定时规则<br>使用shell脚本编写需要执行的内容</p><blockquote><p>脚本中涉及的文件路径是要写 <strong>绝对路径</strong><br><a id="more"></a></p></blockquote><p>执行<code>crontab -e</code>编辑当前用户crontab服务文件</p><h4 id="cron语法"><a href="#cron语法" class="headerlink" title="cron语法"></a>cron语法</h4><p>crontab的定时任务只能精确到分钟 , 而无法精确到秒<br>所以cron表达式只有5个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分     小时     日      月     星期     命令</span><br><span class="line">0-59   0-23   1-31   1-12     0-6     command</span><br></pre></td></tr></table></figure></p><p>0表示周日(也可以用英文来表示，sun表示星期天，mon表示星期一)<br>一般一行对应一个任务</p><ul><li><code>*</code>代表任意值</li><li><code>/</code>代表 <strong>每</strong></li><li><code>-</code>代表连续的时间段(从xx到xx)</li><li><code>,</code>代表不连续的时间点(xx和xx)</li></ul><p>常见的用法举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5  * * * * command    指定每小时的第5分钟执行一次</span><br><span class="line">30 5 * * * command    指定每天的 5:30 执行</span><br><span class="line">30 7 8 * * command    指定每月8号的7：30分执行</span><br><span class="line">30 5 8 6 * command    指定每年的6月8日5：30执行</span><br><span class="line">30 6 * * 0 command    指定每星期日的6:30执行</span><br><span class="line">30 3 10,20 * * command    每月10号及20号的3：30执行</span><br><span class="line">25 8-11 * * * command    每天8-11点的第25分钟执行</span><br><span class="line">*/15 * * * * command    每15分钟执行一次 [即每个小时的第0 15 30 45 60分钟执行]</span><br><span class="line">30 6 */10 * * command    每个月中，每隔10天6:30执行一次 [即每月的1、11、21、31日的6：30执行]</span><br></pre></td></tr></table></figure></p><h4 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h4><ul><li><code>crontab -l</code> - 列出某个用户cron服务的详细内容</li><li><code>crontab -u &lt;username&gt;</code> - 设定某个用户的cron服务，一般root用户在执行这个命令的时候需要此参数  </li><li><code>crontab -r</code> - 删除某个用户的cron服务</li></ul><h4 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h4><p>cron的主配置文件是<code>/etc/crontab</code><br><img src="/images/linux/crontab_config.jpg" alt="crontab config"><br>在这个文件里面也可以配置定时任务的执行规则</p><p>这里这个PATH并不会在实际的脚本运行当中生效<br>如果脚本单独运行没问题 , 但是在定时任务当中出现命令找不到的情况</p><p>比如是在<code>/etc/profile</code>当中配置的环境变量<br>可以用下面的方式指定定时任务规则<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * . /etc/profile; <span class="built_in">command</span></span><br></pre></td></tr></table></figure></p><h4 id="服务相关的操作"><a href="#服务相关的操作" class="headerlink" title="服务相关的操作"></a>服务相关的操作</h4><ul><li><code>serivce crond start</code> - 启动</li><li><code>serivce crond stop</code> - 停止</li><li><code>service crond restart</code> - 重启</li><li><code>service crond status</code> - 查看运行情况</li></ul>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>expect-交互式命令行自动化执行</title>
      <link href="/linux/expect-%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%A7%E8%A1%8C/"/>
      <url>/linux/expect-%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%A7%E8%A1%8C/</url>
      <content type="html"><![CDATA[<p>linux当中存在很多交互式的命令行<br>简单来说就是执行过程中需要等待用户的输入 , 获得输入内容后继续执行<br>这种情况下我们可以借助<code>expect</code>来实现自动化执行这些命令</p><blockquote><p>直接重定向输入流多数情况下是不行的<br>因为它会将需要输入的内容一次性全部输入 , 而无法做到多次的交互</p></blockquote><a id="more"></a><p>expect本身是一个shell脚本的解释器 , 与bash属于同一类东西<br>所以我们可以在脚本开头添加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br></pre></td></tr></table></figure></p><p>来指定使用该解释器来执行这个脚本 , 运行脚本直接<code>./test.sh</code>即可<br>当然也可以执行<code>expect test.sh</code></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install expect.x86_64</span><br></pre></td></tr></table></figure><h4 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h4><p>使用<code>npm init</code>初始化项目的时候<br>需要多次输入项目的相关基本信息 , 这里就用它来做示例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br><span class="line"><span class="built_in">set</span> timeout -1</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /root/pro_test</span><br><span class="line">spawn /usr/<span class="built_in">local</span>/nodejs/bin/npm init</span><br><span class="line">expect <span class="string">"package name:*"</span></span><br><span class="line">send <span class="string">"\n"</span></span><br><span class="line">expect <span class="string">"version:*"</span></span><br><span class="line">send <span class="string">"\n"</span></span><br><span class="line">expect <span class="string">"description:*"</span></span><br><span class="line">send <span class="string">"这里是项目的描述信息\n"</span></span><br><span class="line">expect <span class="string">"entry point:*"</span></span><br><span class="line">send <span class="string">"main.js\n"</span></span><br><span class="line">expect <span class="string">"test command:*"</span></span><br><span class="line">send <span class="string">"\n"</span></span><br><span class="line">expect <span class="string">"git repository:*"</span></span><br><span class="line">send <span class="string">"\n"</span></span><br><span class="line">expect <span class="string">"keywords:*"</span></span><br><span class="line">send <span class="string">"key1 key2\n"</span></span><br><span class="line">expect <span class="string">"author:*"</span></span><br><span class="line">send <span class="string">"Sookie\n"</span></span><br><span class="line">expect <span class="string">"license:*"</span></span><br><span class="line">send <span class="string">"MIT\n"</span></span><br><span class="line">expect <span class="string">"Is this ok?*"</span></span><br><span class="line">send <span class="string">"yes\n"</span></span><br><span class="line"></span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure></p><p>说明:</p><ul><li><code>spawn</code>和<code>send</code>命令是只有在expect解释器当中才有的 , 所以该脚本必须用expect解释执行</li><li><code>spawn</code>表示启动一个新的进程</li><li><code>expect &quot;xxx&quot;</code>表示识别的进程输出( 可以使用通配符 )</li><li>注意在输入内容的末尾加<code>\n</code></li></ul><h4 id="interact"><a href="#interact" class="headerlink" title="interact"></a>interact</h4><p>如果我们需要让用户在适当的时候手动干预这个过程<br>就需要执行<code>interact</code><br>例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spawn ftp ftp.test.com</span><br><span class="line">expect <span class="string">"Name"</span></span><br><span class="line">send <span class="string">"user\n"</span></span><br><span class="line">expect <span class="string">"Password:"</span></span><br><span class="line">send <span class="string">"123456\n"</span></span><br><span class="line">interact</span><br></pre></td></tr></table></figure></p><p>下载完ftp文件时，仍然可以停留在ftp命令行状态，以便手动的执行后续命令</p><h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>执行<code>set timeout</code>可以设置等待进行输出信息的超时时间<br>单位是秒 , 默认是10秒<br>如果超过了这个时间还未能匹配到输出内容 , 则会跳过这个expect语句继续向下执行<br>-1则表示没有超时时间 , 也就是未匹配到输出内容会一直等待</p><h4 id="多分支模式"><a href="#多分支模式" class="headerlink" title="多分支模式"></a>多分支模式</h4><p>有时候程序的输出可能有多种分支路线<br>所以我们的自动化脚本也不能简单地进行单线匹配<br>expect还支持多分支模式语法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">expect &#123;</span><br><span class="line">  <span class="string">"hi"</span> &#123; send <span class="string">"You said hi\n"</span> &#125;</span><br><span class="line">  <span class="string">"hello"</span> &#123; </span><br><span class="line">    send <span class="string">"Hello yourself\n"</span></span><br><span class="line">    expect &#123;</span><br><span class="line">      <span class="string">"Nice to meet you"</span> &#123; send <span class="string">"Nice to meet you too!"</span> &#125;</span><br><span class="line">      <span class="string">"How is it going"</span> &#123; send <span class="string">"It's good, thank you."</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"bye"</span> &#123; send <span class="string">"See you\n"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>opencv编译安装</title>
      <link href="/linux/opencv%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"/>
      <url>/linux/opencv%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<h3 id="依赖库安装"><a href="#依赖库安装" class="headerlink" title="依赖库安装"></a>依赖库安装</h3><h4 id="ubuntu系统"><a href="#ubuntu系统" class="headerlink" title="ubuntu系统"></a>ubuntu系统</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-essential</span><br><span class="line">apt-get install cmake libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">apt-get install python-dev python-numpy libtbb2 libtbb-dev  libjasper-dev libdc1394-22-dev</span><br></pre></td></tr></table></figure><p>(上面大部分的库ubuntu都自带的 , 安装有问题就跳过)<br>如果需要用java开发<br>则需要安装ant<br>apt-get install ant<br><a id="more"></a></p><h4 id="centos系统"><a href="#centos系统" class="headerlink" title="centos系统"></a>centos系统</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum install gcc gcc-c++  </span><br><span class="line">yum install cmake  </span><br><span class="line">yum install python-devel numpy  </span><br><span class="line">yum install gtk2-devel  </span><br><span class="line">yum install libdc1394-devel  </span><br><span class="line">yum install libv4l-devel  </span><br><span class="line">yum install gstreamer-plugins-base-devel</span><br></pre></td></tr></table></figure><p>如果需要用java开发<br>则需要安装ant<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ant</span><br></pre></td></tr></table></figure></p><p>创建install-ffmpeg.sh<br>授权chmod +x install-ffmpeg.sh<br>并执行./install-ffmpeg.sh<br>内容如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm –import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7 </span><br><span class="line">yum repolist </span><br><span class="line">sudo rpm –import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro </span><br><span class="line">sudo rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el7.nux.noarch.rpm </span><br><span class="line">yum repolist </span><br><span class="line">yum update -y </span><br><span class="line">yum install -y ffmpeg </span><br><span class="line">ffmpeg -version</span><br></pre></td></tr></table></figure></p><p>yum install ffmpeg-devel</p><h3 id="编译与安装"><a href="#编译与安装" class="headerlink" title="编译与安装"></a>编译与安装</h3><blockquote><p>注意 : 上面在安装ant的过程 , 会自动安装<code>openjdk-jre</code><br>但是此时只有jre , 没有jdk , 要编译出java程序可用的jar包和原生库 , 必须有jdk才行<br>通过apt安装openjdk的jdk可以 , 下载oracle的jdk也可以 , 不过后者需要手动加入到环境变量</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">mkdir install</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/root/opencv-3.4.1/install -DBUILD_TESTS=OFF ..</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><blockquote><p>如果ANT和JNI都有值的话就没问题 , JNI没有值的话可能是因为没装jdk , 或者没有加入环境变量PATH当中<br>编译也不会报错 , 只不过编译后不会生成jar包和opencv_java341.so的原生库<br>CMAKE_INSTALL_PREFIX表示安装的目标位置</p></blockquote><p>如果执行过程中<br><code>ippicv_2017u3_lnx_intel64_general_20170822.tgz</code><br>下载过慢或失败<br>可以手动下载这个包放到.cache/ippicv目录下<br>文件名需要加上md5 ( 可以使用md5sum命令得到 )<br>也就是<br>4e0352ce96473837b1d671ce87f17359-ippicv_2017u3_lnx_intel64_general_20170822.tgz</p><h3 id="java调用C-C-模块"><a href="#java调用C-C-模块" class="headerlink" title="java调用C/C++模块"></a>java调用C/C++模块</h3><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><p>程序运行前需要添加环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/native</span><br></pre></td></tr></table></figure></p><p>(就是编译后的安装目录里面lib(或者是lib64)当中所有.so文件 以及libopencv_java341.so 都放在该目录下)<br>之后创建并执行如下shell脚本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">native_folder=/usr/<span class="built_in">local</span>/native</span><br><span class="line"><span class="keyword">for</span> so_file <span class="keyword">in</span> <span class="variable">$&#123;native_folder&#125;</span>/*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  file_name=`basename <span class="variable">$&#123;so_file&#125;</span>`</span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$&#123;file_name&#125;</span> = <span class="string">"libopencv_java341.so"</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">continue</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  `ln -s <span class="variable">$&#123;so_file&#125;</span> <span class="variable">$&#123;so_file&#125;</span>.3.4`</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"已创建软连接<span class="variable">$&#123;so_file&#125;</span>.3.4"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>native_folder就是放置.so文件的目录 , 根据实际情况而定</p><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>需要把<code>opencv_java341.dll</code>文件放到<code>%JAVA_HOME%/jre/bin</code>里面</p><h3 id="maven本地安装jar包"><a href="#maven本地安装jar包" class="headerlink" title="maven本地安装jar包"></a>maven本地安装jar包</h3><p>要在maven项目当中引入这个jar包使用 , 并且保证打包过程正确加入这个jar包<br>可以手动安装到本地maven仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=opencv-341.jar -DgroupId=org.opencv -DartifactId=opencv -Dversion=3.4.1 -Dpackaging=jar</span><br></pre></td></tr></table></figure></p><p>当然也可以选择不安装到本地仓库<br>而是直接放进项目里面 , 比如说放在了项目里的lib目录下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.opencv<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opencv<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;pom.basedir&#125;/lib/opencv-341.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lamdba表达式(2)-Stream</title>
      <link href="/Java/Lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F(2)-Stream/"/>
      <url>/Java/Lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F(2)-Stream/</url>
      <content type="html"><![CDATA[<p>有了Lamdba表达式 , Java就具有了进行函数式编程的条件<br>但是作为彻底的面向对象语言 , 并不支持函数的独立存在<br>所以JDK1.8添加了<code>Stream</code>以及一些相关的接口<br><a id="more"></a><br>Stream的特点可以概括如下</p><ol><li>Stream是元素的序列 , 看起来有点类似Iterator</li><li>可以支持顺序和并行聚合的操作</li></ol><p>可以把Stream看成一个高级版本的Iterator<br>Iterator只能逐个对元素进行遍历 , 然后执行某些操作<br>对于Stream , 只需要给出对元素进行处理的回调函数<br>就可以对这个元素序列进行一些操作</p><blockquote><p>可以参考underscore对数组或者对象进行处理的一些方法<br>编程方式上十分类似</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; nums = Lists.newArrayList(<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="keyword">null</span>,<span class="number">56</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = nums.stream();</span><br><span class="line"><span class="comment">//过滤掉序列中的null值 并获得剩余元素的数量</span></span><br><span class="line"><span class="keyword">long</span> count = stream.filter(num -&gt; num!=<span class="keyword">null</span>).count();</span><br><span class="line">System.out.println(count);<span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>Lists是<code>Guava</code>当中的一个工具类 , 这里用它来产生一个List对象</p><blockquote><p>Stream当中的很多<strong>非聚合</strong>方法 , 都是返回Stream对象 , 可以进行连缀<br>但是<strong>注意</strong> : 每次调用后的结果 , 都是产生一个新的Stream对象 , 而不再是原Stream对象<br>此时如果再对原对象进行任何操作 , 都会抛出异常</p></blockquote><h4 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h4><p>有两种方式可以创建一个Stream对象</p><ol><li>通过Stream接口当中的静态工厂方法</li><li>通过Collection接口的默认方法<code>stream()</code> , 上面的例子用的就是这种方式</li></ol><p><strong>Stream接口中的静态工厂方法</strong></p><ul><li><p><code>of方法</code> - 有两个重载形式 , 一个是接收单一值 , 一个是接收多个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; intStream = Stream.of(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">Stream&lt;String&gt; strStream = Stream.of(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>generate方法</code> - 获得一个生成器<br>这个方法产生的Stream是一个<strong>惰性序列</strong> , 也就是它并不保存这个序列中所有的内容 , 每次需要获取的时候 , 再去生成<br>通过这种方式 , 可以节约大量的内存 , 也可以获得一个无限长的序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; randomNums = Stream.generate(()-&gt;(<span class="keyword">int</span>)(Math.random()*<span class="number">1000</span>));</span><br><span class="line">randomNums.limit(<span class="number">20</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用的非聚合操作"><a href="#常用的非聚合操作" class="headerlink" title="常用的非聚合操作"></a>常用的非聚合操作</h4><ul><li><code>distinct</code> - 去除序列中的重复元素 ( 依赖元素的equals方法 )</li><li><code>filter</code> - 对于实参函数执行结果为false的 , 从序列中去除</li><li><code>map</code> - 对于元素逐个使用实参函数进行处理 , 并将返回值组装成一个新的序列</li><li><code>peek</code> - 克隆原Stream产生一个新的Stream , 并提供一个消费函数 , 当新Stream中的每个元素被消费的时候都会调用该函数</li><li><code>limit</code> - 截取前若干个元素</li><li><code>skip</code> - 丢弃前若干个元素</li><li><code>sorted</code> - 对序列中的元素进行排序 ( 可以指定Comparator )</li></ul><h4 id="常用的聚合操作"><a href="#常用的聚合操作" class="headerlink" title="常用的聚合操作"></a>常用的聚合操作</h4><p><strong>聚合操作</strong>（也称为折叠）接受一个元素序列为输入，反复使用某个合并操作，把序列中的元素合并成一个汇总的结果。</p><ul><li><code>collect</code> - 将所有的元素放入到一个Collection容器当中 ( 属于可变聚合 )</li><li><code>reduce</code> - 将前两个元素使用指定函数进行聚合 , 将结果与第三个元素进行聚合 , 依次进行下去</li><li><code>count</code> - 获得序列中元素的数量</li></ul><hr><p>Stream当中的方法大部分都可以根据名称猜出意思<br>就不一一介绍了 , 详细内容参阅JDK源码</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Lamdba表达式(1)</title>
      <link href="/Java/Lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F(1)/"/>
      <url>/Java/Lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F(1)/</url>
      <content type="html"><![CDATA[<p><code>Lamdba表达式</code>是Java8的一项重要的新特性<br>它是基于匿名内部类演化出的一种更加抽象的语法形式<br>由编译器去推断并包装为常规的代码<br><a id="more"></a><br>官方的解释为</p><blockquote><p>一个不用被绑定到一个标识符上，并且可能被调用的函数</p></blockquote><p>可以理解为是 一段带有输入参数的可执行语句块<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">//在List当中加入若干元素</span></span><br><span class="line">Collections.sort(names, (o1,o2)-&gt;o1.compareTo(o2));</span><br></pre></td></tr></table></figure></p><p>上述代码中用到的Lamdba表达式其实就是相当于构建了一个实现了Comparator接口的匿名内部类<br>等价于以下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>也许下面的代码能更好地体现Lamdba表达式就是匿名类的另外一种写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Demo d = ()-&gt;&#123;<span class="keyword">return</span> <span class="string">"aa"</span>;&#125;;</span><br><span class="line">    d.func();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="Lamdba表达式语法"><a href="#Lamdba表达式语法" class="headerlink" title="Lamdba表达式语法"></a>Lamdba表达式语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(Type1 param1, Type2 params,...,TypeN paramN) -&gt; &#123;</span><br><span class="line">  <span class="comment">//若干语句...</span></span><br><span class="line">  <span class="keyword">return</span> 表达式;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一般语法 , 也就是最完整的一种语法<br>但是通常用到Lamdba表达式的时候 , 都是方法中的语句并不复杂 , 逻辑简单的情况<br>否则会造成代码可读性很差<br>所以Lamdba就有很多种简化版 , 实际用的也多是简化版</p><ol><li><p>编译器可以根据上下文推断参数的类型 , 大多数情况下参数类型可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(param1, params,...,paramN) -&gt; &#123;</span><br><span class="line">  <span class="comment">//若干语句...</span></span><br><span class="line">  <span class="keyword">return</span> 表达式;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当参数只有一个 , 可以省略小括号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">param -&gt; &#123;</span><br><span class="line">  <span class="comment">//若干语句...</span></span><br><span class="line">  <span class="keyword">return</span> 表达式;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当方法中只包含一条语句 , 可以省略大括号 return 和 最后的分号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param -&gt; 表达式</span><br></pre></td></tr></table></figure></li></ol><hr><p>其他要点</p><ul><li>与匿名类中的方法一样 , Lamdba可以访问其所在的外部类的成员 , 也可以访问其所在方法中的局部变量</li><li>Lamdba表达式中的this指向的并不是这个匿名类对象 , 而是指向其外部类对象<br>所以如果是在一个静态方法中 , 则不能使用this</li></ul><hr><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p><code>方法引用</code>可以在某些条件成立的情况下 , 更加简化Lamdba表达式的声明 , 格式有以下3种</p><ul><li><strong>对象名称 :: 非静态方法</strong></li><li><strong>类名称 :: 静态方法</strong></li><li><strong>类名称 :: 非静态方法</strong></li></ul><p>前两种方式类似<br>例如<code>System.out::println</code><br>等价于<code>x-&gt;System.out.println(x);</code></p><p>最后一种方式 , 相当于把Lamdba表达式的第一个参数当做该方法的目标对象<br>例如<code>String::toLowerCase</code><br>等价于<code>x-&gt;x.toLowerCase();</code></p><h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><p>语法是</p><ul><li><strong>类名 :: new</strong></li></ul><p>例如 <code>BigDecimal::new</code><br>等价于<code>x-&gt;new BigDecimal(x)</code></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>4.0、安全验证</title>
      <link href="/MongoDB/4.0%E3%80%81%E5%AE%89%E5%85%A8%E9%AA%8C%E8%AF%81/"/>
      <url>/MongoDB/4.0%E3%80%81%E5%AE%89%E5%85%A8%E9%AA%8C%E8%AF%81/</url>
      <content type="html"><![CDATA[<p>mongoDB在默认情况下是没有开启权限认证的 , 也就是不需要用户名密码就可以连接数据库<br><a id="more"></a></p><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&lt;userinfo&gt;)</span><br></pre></td></tr></table></figure><p>其中userinfo是一个json数据 , 包含下列属性</p><ul><li>user - 用户名</li><li>pwd - 密码</li><li>customData - 任意的自定义内容</li><li>roles : [{ role : &lt;角色类型&gt;, db : &lt;数据库名称&gt; } , … ]<br>一个用户可以对应多个角色 , 所以是一个数组结构</li></ul><p>mongoDB当中内置的角色类型有：</p><ul><li>数据库用户角色：read、readWrite;<br>允许用户 读/读写 指定的数据库</li><li>数据库管理角色：dbAdmin、dbOwner；<br>允许在指定数据库中执行管理函数 , 如索引增删 查看统计等</li><li>用户管理角色：userAdmin<br>允许向system.users集合写入数据, 可以在指定数据库增删用户</li><li>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；</li><li>备份恢复角色：backup、restore；</li><li>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase<br>可以在所有数据库中进行 读/读写/用户管理</li><li>超级用户角色：root</li><li>内部角色：__system</li></ul><p>举例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123;</span><br><span class="line">  user:<span class="string">"sookie"</span>,</span><br><span class="line">  pwd:<span class="string">"123456"</span>,</span><br><span class="line">  customData:&#123;<span class="attr">info</span>:<span class="string">"this is my first user"</span>&#125;,</span><br><span class="line">  roles:[</span><br><span class="line">    &#123;<span class="attr">role</span>:<span class="string">"userAdmin"</span>,<span class="attr">db</span>:<span class="string">"admin"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">role</span>:<span class="string">"read"</span>,<span class="attr">db</span>:<span class="string">"demo"</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="开启权限认证"><a href="#开启权限认证" class="headerlink" title="开启权限认证"></a>开启权限认证</h4><p>在配置文件中添加 ( 关于配置见前一节的内容 )<br><code>auth=true</code><br>重启服务即可开启数据库的权限认证</p><h4 id="认证用户"><a href="#认证用户" class="headerlink" title="认证用户"></a>认证用户</h4><p>连接到mongoDB数据库以后 , 由于开启了权限认证<br>如果不进行用户认证 , 是没有任何权限的<br><img src="/images/MongoDB/auth.png" alt="auth"></p><p>进行认证的步骤如下</p><p>切换到用户所在的数据库 , 比如刚才创建的用户在demo数据库下具有”read”权限<br>就执行<code>use demo</code><br>执行<code>db.auth(&quot;用户名&quot;,&quot;密码&quot;)</code></p><blockquote><p><strong>注意</strong> 帐号是跟着库走的，所以在指定库里授权，必须也在指定库里验证(auth)</p></blockquote><p>认证完成后 , 当前用户就可以执行权限所允许的操作了</p><hr><p>附 : 在Robomongo当中使用指定用户访问数据库的方法<br><img src="/images/MongoDB/auth_robomongo.png" alt="auth"></p>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo站点实现站内搜索</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/Hexo%E7%AB%99%E7%82%B9%E5%AE%9E%E7%8E%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/Hexo%E7%AB%99%E7%82%B9%E5%AE%9E%E7%8E%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/</url>
      <content type="html"><![CDATA[<p>在hexo博客中 , 可以添加站内文章搜索的支持<br>但是需要生成所有文章的索引<br>安装hexo官方提供的插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>默认只索引post , 要索引所有文章 , 需要在_config.yml当中配置<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">all</span></span><br></pre></td></tr></table></figure></p><p>之后访问<code>/search.xml</code>就可以获取到文章的索引了<br>大致是如下结构<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">search</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS布局(4)-grid<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/文章URL地址/"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>/文章URL地址/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">content</span> <span class="attr">type</span>=<span class="string">"html"</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">    &lt;p&gt;这里是文章内容&lt;/p&gt;</span><br><span class="line">    ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">categories</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span>&gt;</span>分类1<span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">categories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tags</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tag</span>&gt;</span>标签1<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tag</span>&gt;</span>标签2<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tags</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">search</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>其中的一个entry是一篇文章的信息<br>可以在JS当中使用ajax获取到这段XML文本 , 然后进行解析处理 , 从而做出站内搜索的功能<br>需要注意的是content部分是html文本 , 在处理当中需要把html标签去除</p><p>以下是借助Vue实现的自动渲染搜索结果列表的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> articleDatas = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> resultDiv = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#search-box"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    queryText: <span class="literal">null</span>, <span class="comment">//搜索的关键字文本</span></span><br><span class="line">    searchResult: [] <span class="comment">//搜索结果</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    axios(&#123; <span class="comment">//调用ajax获取文章索引信息</span></span><br><span class="line">      url: <span class="string">"/search.xml"</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> xmlDoms = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">window</span>.DOMParser) &#123;</span><br><span class="line">        <span class="keyword">var</span> parser = <span class="keyword">new</span> DOMParser()</span><br><span class="line">        xmlDoms = parser.parseFromString(response.data, <span class="string">"application/xml"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// IE浏览器</span></span><br><span class="line">        <span class="keyword">var</span> xmlDoc = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLDOM"</span>);</span><br><span class="line">        xmlDoc.async = <span class="literal">false</span>;</span><br><span class="line">        xmlDoms = xmlDoc.loadXML(response.data);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//找出所有文章的标题 正文 URL</span></span><br><span class="line">      articleDatas = <span class="built_in">Array</span>.prototype.map.call(xmlDoms.getElementsByTagName(<span class="string">"entry"</span>), <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          title: item.getElementsByTagName(<span class="string">"title"</span>)[<span class="number">0</span>].innerHTML,</span><br><span class="line">          content: item.getElementsByTagName(<span class="string">"content"</span>)[<span class="number">0</span>].innerHTML,</span><br><span class="line">          url: item.getElementsByTagName(<span class="string">"url"</span>)[<span class="number">0</span>].innerHTML,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      resultDiv = <span class="built_in">document</span>.getElementById(<span class="string">"search-result-box"</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    queryText: <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.searchResult.length = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 控制搜索结果框的显示与隐藏</span></span><br><span class="line">      <span class="keyword">if</span>(newVal &amp;&amp; newVal.trim() &amp;&amp; articleDatas) &#123;</span><br><span class="line">        resultDiv.style.display = <span class="string">"block"</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resultDiv.style.display = <span class="string">"none"</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//多关键字分别匹配</span></span><br><span class="line">      <span class="keyword">var</span> keywords = newVal.trim().toLowerCase().split(<span class="regexp">/[\s\-]+/</span>);</span><br><span class="line">      <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">      articleDatas.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">article</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> isMatch = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">var</span> title = article.title.trim().toLowerCase();</span><br><span class="line">        <span class="keyword">var</span> content = article.content.trim().replace(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>,<span class="string">""</span>).toLowerCase();</span><br><span class="line">        <span class="keyword">var</span> index_title = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">var</span> index_content = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">var</span> first_occur = <span class="number">-1</span>; <span class="comment">//关键字在正文当中第一次出现的位置</span></span><br><span class="line">        <span class="keyword">if</span>(title &amp;&amp; content) &#123;</span><br><span class="line">          keywords.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">keyword, i</span>) </span>&#123;</span><br><span class="line">            index_title = title.indexOf(keyword);</span><br><span class="line">            index_content = content.indexOf(keyword);</span><br><span class="line">            <span class="keyword">if</span>( index_title &lt; <span class="number">0</span> &amp;&amp; index_content &lt; <span class="number">0</span> )&#123;</span><br><span class="line">              isMatch = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (index_content &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                index_content = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                first_occur = index_content;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isMatch) &#123;</span><br><span class="line">          <span class="keyword">var</span> resultItem = &#123;&#125;;</span><br><span class="line">          resultItem.url = article.url;</span><br><span class="line">          resultItem.title = article.title;</span><br><span class="line">          <span class="keyword">if</span> (first_occur &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 截取关键字前后的一段文字</span></span><br><span class="line">            <span class="keyword">var</span> start = first_occur - <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">var</span> end = first_occur + <span class="number">15</span>;</span><br><span class="line">            <span class="keyword">if</span>(start &lt; <span class="number">0</span>)&#123;</span><br><span class="line">              start = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(start == <span class="number">0</span>)&#123;</span><br><span class="line">              end = <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end &gt; content.length)&#123;</span><br><span class="line">              end = content.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> matchContent = content.substring(start, end); </span><br><span class="line">            <span class="comment">// 高亮关键字</span></span><br><span class="line">            keywords.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">keyword</span>)</span>&#123;</span><br><span class="line">              <span class="keyword">var</span> keywordReg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(keyword, <span class="string">"gi"</span>);</span><br><span class="line">              matchContent = matchContent.replace(keywordReg, <span class="string">"&lt;strong class=\"search-keyword\"&gt;"</span>+keyword+<span class="string">"&lt;/strong&gt;"</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">            resultItem.matchContent = matchContent</span><br><span class="line">          &#125;</span><br><span class="line">          _this.searchResult.push(resultItem)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>这里借助axios实现ajax请求 , 当然也可以用别的 , 或者使用原生的写法<br>然后在页面的适当位置中编写搜索input与搜索结果框的html<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"search-box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"icon"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-search"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-box"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"search-input"</span> <span class="attr">v-model</span>=<span class="string">"queryText"</span> <span class="attr">placeholder</span>=<span class="string">"站内搜索"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 搜索结果区 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"search-result-box"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"search-result-list"</span> <span class="attr">v-if</span>=<span class="string">"searchResult.length"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(article,index) in searchResult"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">'article.url'</span> <span class="attr">class</span>=<span class="string">'search-result-title'</span> <span class="attr">target</span>=<span class="string">'_blank'</span>&gt;</span>&#123;&#123;article.title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"search-result"</span> <span class="attr">v-html</span>=<span class="string">"article.matchContent"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 无匹配时显示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"search-result"</span> <span class="attr">v-else</span>&gt;</span>没有搜索到任何结果<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>之后编写相应的样式就可以了</p>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo搭建个人博客</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<blockquote><p>Hexo 是一个快速、简洁且高效的博客框架，需要nodejs环境运行<br>使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可生成静态网页。</p></blockquote><a id="more"></a><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>由于hexo是使用JavaScript编写<br>所以首先需要nodejs环境 , 可以在官网下载运行包, 或者下载源代码在linux下编译</p><h3 id="安装脚手架工具与初始化"><a href="#安装脚手架工具与初始化" class="headerlink" title="安装脚手架工具与初始化"></a>安装脚手架工具与初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init my_blog</span><br></pre></td></tr></table></figure><p>这是hexo官方提供的脚手架工具 , 可以实现快速生成一个博客模板<br>其中的<code>_config.yml</code>是博客的基础配置文件</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>服务默认在4000端口启动 , 如果要修改启动端口 , 需要在<code>config.yml</code>当中添加<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">6603</span></span><br><span class="line"><span class="attr">  compress:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  header:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>启动服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><p><img src="/images/前端杂烩/hexo_server.png" alt="hexo server"><br>之后就可以用浏览器访问了</p><h3 id="编写文章"><a href="#编写文章" class="headerlink" title="编写文章"></a>编写文章</h3><p>Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径</p><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td>post</td><td>source/_posts</td></tr><tr><td>page</td><td>source</td></tr><tr><td>draft</td><td>source/_drafts</td></tr></tbody></table><p>博客目录初始化完成之后 , 其中的source就是文章目录<br>我们可以直接在其中创建文件 , <code>_posts</code>里面就是正式提交的文章<br>实际访问的路径可以在_config.yml当中的<code>permalink</code>定义<br>可以有下列值</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>:title</td><td>标题（小写，空格将会被替换为短杠）</td></tr><tr><td>:year</td><td>建立的年份，比如， 2015</td></tr><tr><td>:month</td><td>建立的月份（有前导零），比如， 04</td></tr><tr><td>:i_month</td><td>建立的月份（无前导零），比如， 4</td></tr><tr><td>:day</td><td>建立的日期（有前导零），比如， 07</td></tr><tr><td>:i_day</td><td>建立的日期（无前导零），比如， 7</td></tr></tbody></table><p>创建一篇新文章<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line"><span class="comment">#比如</span></span><br><span class="line">hexo new post 测试文章</span><br></pre></td></tr></table></figure></p><p>执行之后会自动在_posts下面创建一个新文件<code>测试文章.md</code></p><blockquote><p>这里的操作只是创建一个文件 , 我们当然也可以手动创建文件</p></blockquote><p>这里实际是使用<code>scaffolds</code>里面的<code>post.md</code>模板来创建文件的<br>我们可以修改这个模板的内容 , 或者创建自定义的布局模板</p><h4 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h4><p>可以在source当中创建一个目录作为自定义的目录<br>比如创建一个about目录 , 其中写一个<code>index.md</code>文件<br>实际访问的路径就是<code>http://localhost:4000/about/</code></p><h4 id="图片引用"><a href="#图片引用" class="headerlink" title="图片引用"></a>图片引用</h4><p>可以把图片直接放在source下面的某个目录当中<br>比如有图片<code>source/image/test.png</code><br>就可以在md文件中这样引用<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">test</span>](<span class="link">/images/test.png</span>)</span><br></pre></td></tr></table></figure></p><p>在实际访问的时候就能产生正确的图片访问路径</p><h4 id="标签与分类"><a href="#标签与分类" class="headerlink" title="标签与分类"></a>标签与分类</h4><p>在每篇文章开头的描述信息当中 , 除了标题 日期之外 , 可以指定该文章的分类和标签 ( 注意开头不能有空行 )<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">测试文章</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-5</span><span class="bullet">-9</span> <span class="number">09</span><span class="string">:43:01</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">标签1</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">标签2</span></span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">分类1</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">子分类</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p><p>hexo不支持多个同级分类 , 分类当中若有多项会被处理成子分类</p><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>hexo支持自定义主题 , 官方有很多开源的主题<br>可以直接放在<code>themes</code>目录下<br>然后在_config.yml当中修改<code>theme</code>为对应的名称即可</p>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.3、索引构建情况分析</title>
      <link href="/MongoDB/3.3%E3%80%81%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90/"/>
      <url>/MongoDB/3.3%E3%80%81%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>索引本身可以提高查询的效率<br>但是数据库要维护索引 , 需要额外的磁盘空间占用 , 并且写入的性能也会下降<br><a id="more"></a><br>要评判数据库当中的索引构建情况<br>常用的有下列4种方式</p><ol><li>mongostat工具</li><li>profile集合</li><li>mongoDB自身的日志</li><li>explain分析</li></ol><h4 id="mongostat"><a href="#mongostat" class="headerlink" title="mongostat"></a>mongostat</h4><p>这是mongoDB自带的一个工具 , 可以查看mongoDB的运行状态</p><blockquote><p>在mongoDB的安装目录\bin当中 , 有一个名为mongostat.exe的程序 , 将bin路径加入到环境变量之后 , 就可以直接在控制台运行该程序</p></blockquote><p>使用方式<br><code>mongostat -h &lt;IP地址&gt;:&lt;端口号&gt;</code><br>例如<br>mongostat -h 127.0.0.1:27017</p><p>这是一个针对mongoDB的综合监控程序<br>每秒根据各项指标进行采样<br>其中常用的各项指标的含义 ( 均是以每秒为单位 )</p><ul><li>inserts - 写入数据的次数</li><li>query - 查询数据的次数</li><li>update - 更新数据的次数</li><li>delete - 删除数据的次数</li><li>getmore - 当查询的数据量较大时 , 为了防止内存溢出 , 并不会一次返回所有的数据 , 而是分批返回 , 获取下一批的数据执行的是getmore</li><li>command - 执行命令的数量</li><li>flushed - 将内存中的数据写入到硬盘的次数</li><li>vsize - 虚拟内存使用量，单位MB</li><li>res - 物理内存使用量，单位MB</li><li>faults/s - 访问失败数（只有Linux有），数据被交换出物理内存，放到swap。不要超过100，否则就是机器内存太小，造成频繁swap写入。此时要升级内存或者扩展</li><li>ids miss - 查询没有命中索引的比例 ( 如果太高的话可能是创建了不合理的索引或者索引的数量不够 , 是一个潜在隐患 , 数据量过大就可能出现性能问题 )</li><li>qr | qw - 读队列/写队列 , 如果值较高的话就代表读写的负载比较高 , 可能出现性能问题</li><li>ar | aw - 当前活跃的客户端的数量</li><li>conn - 连接数量</li></ul><h4 id="profile集合"><a href="#profile集合" class="headerlink" title="profile集合"></a>profile集合</h4><p>在mongoDB当中存在一个记录读写操作日志的集合<br>使用<code>db.getProfilingLevel()</code>可以获得当前的记录级别</p><ul><li>0 关闭 , 不做任何记录</li><li>1 开启 , 有慢查询的时候记录</li><li>2 开启 , 记录所有内容</li></ul><p>默认是0 , 可以使用<code>db.setProfilingLevel(1)</code>开启慢查询的记录<br>从而通过分析这个集合当中的数据<br>有针对性的通过创建所以解决慢查询的问题</p><p>也可以在配置文件中配置<code>profile=1</code>来进行默认开启<br><code>slowms</code>参数表示慢查询的毫秒数 , 查询所用的时间超过这个值的就是慢查询 , 默认是100</p><blockquote><p>由于向profile当中写入数据本身也是占用性能的 , 尤其是这个集合当中内容较多的情况下<br>所以这种方式的应用场景通常是在开发和测试阶段</p></blockquote><h4 id="mongoDB的日志"><a href="#mongoDB的日志" class="headerlink" title="mongoDB的日志"></a>mongoDB的日志</h4><p>在1.1的mongoDB安装配置步骤当中 , 第三步是创建windows服务以方便使用<br>并且配置了数据库所在路径和日志所在路径<br>这个服务实际是执行了mongod命令来启动数据库<br>并且传递了dbpath和logpath两个参数用来指定数据的存储位置和日志的写入路径</p><p>我们也可以在本地创建一个配置文件( 通常是conf格式 )来配置这些参数 , 从而方便进行配置的修改<br><code>mongod --config &quot;配置文件路径&quot; --install --serviceName &quot;MongoDB&quot;</code><br>配置文件内容的写法与.properties文件相同<br>其中常用的配置项有</p><ul><li>dbpath - 数据目录</li><li>port - 服务器监听的端口 , 默认是27017</li><li>fork - (true/false) 是否以守护进程方式运行</li><li>logpath - 日志输出路径</li><li>verbose - (v~vvvvv) 日志信息冗余级别 , v越多详细度越高</li><li>bind_ip - 绑定的IP地址 , 绑定以后只能通过该IP与数据库连接 ( 多个IP用逗号分隔 )</li><li>maxConns - 最大连接数</li></ul><h4 id="explain分析"><a href="#explain分析" class="headerlink" title="explain分析"></a>explain分析</h4><p>用法 : <strong>在find函数的返回结果上调用explain()</strong><br>这个函数会返回这次查询的相关信息用于分析</p>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.2.1、GeoJSON</title>
      <link href="/MongoDB/3.2.1%E3%80%81GeoJSON/"/>
      <url>/MongoDB/3.2.1%E3%80%81GeoJSON/</url>
      <content type="html"><![CDATA[<p>GeoJSON是一种对各种地理数据结构进行编码的格式。GeoJSON对象可以表示几何、特征或者特征集合。GeoJSON支持下面几何类型：点、线、面、多点、多线、多面和几何集合。GeoJSON里的特征包含一个几何对象和其他属性，特征集合表示一系列特征。<br><a id="more"></a><br>特点</p><ul><li>GeoJSON对象可能有任何数目成员（名/值对）。</li><li>GeoJSON对象必须由一个名字为<code>type</code>的成员。这个成员的值是由GeoJSON对象的类型所确定的字符串。</li><li>type成员的值必须是下面之一：<strong>“Point”, “MultiPoint”, “LineString”, “MultiLineString”, “Polygon”,    “MultiPolygon”,   “GeometryCollection”, “Feature”, 或者 “FeatureCollection”</strong>。这儿type成员值必须如这儿所示。</li><li>GeoJSON对象可能有一个可选的”crs”成员，它的值必须是一个坐标参考系统的对象。</li><li>GeoJSON对象可能有一个”bbox”成员，它的值必须是边界框数组</li></ul><blockquote><p><code>几何</code>是一种GeoJSON对象( 相当于是一个子集 )，这时type成员的值是下面字符串之一：<strong>“Point”, “MultiPoint”, “LineString”, “MultiLineString”,  “Polygon”, “MultiPolygon”, 或者”GeometryCollection”</strong>。</p></blockquote><blockquote><p>除了“GeometryCollection”外的其他任何类型的GeoJSON几何对象必须包含一个名字为<code>coordinates</code>的成员。coordinates成员的值总是数组。这个数组里的元素的结构由几何类型来确定。</p></blockquote><p><code>位置</code>是基本的几何结构。几何对象的”coordinates”成员由一个位置（这儿是几何点）、位置数组（线或者几何多点），位置数组的数组（面、多线）或者位置的多维数组（多面）组成。</p><h4 id="几何的类型"><a href="#几何的类型" class="headerlink" title="几何的类型"></a>几何的类型</h4><ul><li><p>点 ( Point )<br>“coordinates”成员必须是一个单独的位置。</p></li><li><p>多点 ( MultiPoint )<br>“coordinates”成员必须是位置数组。</p></li><li><p>线 ( LineString )<br>“coordinates”成员必须是两个或者多个位置的数组。</p></li><li><p>多线 ( MultiLineString )<br>“coordinates”成员必须是一个线坐标数组的数组。</p></li><li><p>面 ( Polygon )<br>“coordinates”成员必须是一个线性环坐标数组的数组。对拥有多个环的的面来说，第一个环必须是外部环，其他的必须是内部环或者孔。</p></li><li><p>多面 ( MultiPlygon )<br>“coordinates”成员必须是面坐标数组的数组。</p></li><li><p>几何集合 ( GeometryCollection )<br>它表示几何对象的集合。<br>几何集合必须有一个名字为<code>geometries</code>的成员。与”geometries”相对应的值是一个数组。这个数组中的每个元素都是一个GeoJSON几何对象。</p></li></ul>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1.1、linux常用命令与技巧(1)</title>
      <link href="/linux/1.1%E3%80%81linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8A%80%E5%B7%A7(1)/"/>
      <url>/linux/1.1%E3%80%81linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8A%80%E5%B7%A7(1)/</url>
      <content type="html"><![CDATA[<h3 id="md5sum与sha1sum"><a href="#md5sum与sha1sum" class="headerlink" title="md5sum与sha1sum"></a>md5sum与sha1sum</h3><p>用于使用hash算法生成文件的摘要信息 , 常用于文件完整性的校验<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成a.txt的md5摘要信息</span></span><br><span class="line">md5sum a.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成当前目录下所有文件的sha1摘要信息</span></span><br><span class="line">sha1sum ./*</span><br></pre></td></tr></table></figure></p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>显示在终端中执行过的所有命令的历史记录<br>(按↑方向键快速找到执行过的命令也是利用的这个记录)<br>如果使用<code>history -c</code>可以清空这个列表</p><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>这个命令是用来改变文件拥有者和所在的组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown &lt;用户名&gt;:&lt;组&gt; &lt;文件名&gt;</span><br></pre></td></tr></table></figure></p><p>可以改变文件的所有权</p><h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p>就是calendar(日历) , 可以用来显示当前月份或者任意年份中的某一月<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前月份日历</span><br><span class="line">cal</span><br><span class="line"></span><br><span class="line"># 显示2018年2月的日历</span><br><span class="line">cal 2 2018</span><br><span class="line"></span><br><span class="line"># 显示2018年全年日历</span><br><span class="line">cal -y 2018</span><br></pre></td></tr></table></figure></p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>代表了连结 , 通常也可以用它输出单个文件的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出a.txt的内容(带行号)</span></span><br><span class="line">cat -n a.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将a.txt b.txt的内容连结输出</span></span><br><span class="line">cat a.txt b.txt</span><br></pre></td></tr></table></figure></p><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>对于程序的输出 , 我们通常不能一直看着终端 , 而且终端也只能保留最近的内容<br>除了程序本身可以有对于日志的处理之外<br>我们也可以将程序向终端的输出重定向到指定的文件里面<br>使用<code>&gt;</code>和<code>&gt;&gt;</code>可以实现重定向<br>前者表示始终覆盖目标文件 , 后者表示如果目标文件存在则执行追加操作 , 不会覆盖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行java程序并将输出写入到当前目录的output.txt文件当中</span></span><br><span class="line">java -jar demo.jar &gt; ./output.txt</span><br></pre></td></tr></table></figure></p><p>当然有些程序会在终端打印大量无意义的内容<br>我们如果想把这些输出直接丢弃<br>可以使用<code>/dev/null</code>作为目标位置<br>这是个并不存在的虚拟位置 , 定向到这里相当于是把输出内容直接丢弃 , 避免占用磁盘空间<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"><span class="comment"># 1表示标准输出 2表示标准错误输出</span></span><br><span class="line"><span class="comment"># 2&gt;&amp;1表示将标准错误输出重定向到标准输出, 这样两者都会被丢弃</span></span><br></pre></td></tr></table></figure></p><h4 id="与cat的配合使用"><a href="#与cat的配合使用" class="headerlink" title="与cat的配合使用"></a>与cat的配合使用</h4><p>cat既然表示连结 , 那么与输出重定向配合使用 , 就可以实现对于压缩分卷的结合了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意分卷的顺序</span></span><br><span class="line">cat data.z01 data.z02 data.zip &gt; xdata.zip</span><br><span class="line"><span class="comment"># 将分卷结合成一个文件之后就可以执行解压了</span></span><br><span class="line">unzip xdata.zip</span><br></pre></td></tr></table></figure></p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>全称是Global Regular Expression Print, 全局正则表达式输出<br>这个命令的作用是执行全文检索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在a.txt当中搜索str1字符串</span><br><span class="line">grep &quot;str1&quot; a.txt</span><br><span class="line"></span><br><span class="line"># 在当前目录下递归检索所有文件搜索str1字符串</span><br><span class="line">grep -r &quot;str1&quot; ./</span><br></pre></td></tr></table></figure></p><p>当然不限于固定的字符串, 也可以使用正则表达式</p><h4 id="管道符”-”"><a href="#管道符”-”" class="headerlink" title="管道符”|”"></a>管道符”|”</h4><p>格式 : 命令A|命令B<br>作用是将命令A的输出结果作为命令B的操作对象<br>比如结合<code>grep</code>可以对繁杂的输出结果进行过滤<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询当前运行的进程, 并过滤包含tomcat关键字的行</span></span><br><span class="line">ps ax | grep tomcat</span><br></pre></td></tr></table></figure></p><p>比如<code>wc -l</code>可以用来统计行数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 统计当前目录下总共有多少文件</span><br><span class="line">ls -l | wc -l</span><br></pre></td></tr></table></figure></p><p>因为<code>ls -l</code>的输出是逐行输出当前目录下每个文件的详细信息 , 所以统计出的行数实际上就是文件数量了</p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Maven(6)-可运行jar打包</title>
      <link href="/Java/Maven(6)-%E5%8F%AF%E8%BF%90%E8%A1%8Cjar%E6%89%93%E5%8C%85/"/>
      <url>/Java/Maven(6)-%E5%8F%AF%E8%BF%90%E8%A1%8Cjar%E6%89%93%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>要让jar包是可运行的<br>也就是可以执行<code>java -jar demo.jar</code>来直接运行<br>需要满足两个条件</p><ol><li>依赖的其他jar包也被一同打包进去</li><li>jar包当中具备清单文件 , 指定运行的主类<a id="more"></a>在maven项目当中 , 可以借助<code>maven-shade-plugin</code>来实现</li></ol><p>pom.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.main.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里的<code>mainClass</code>需要指定运行的主类是哪个<br>之后执行<code>mvn clean package</code>打包出的jar包 , 就是直接可运行的jar包了</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象编程</title>
      <link href="/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>面向对象的两个基本概念</p><ol><li><strong>类</strong> : 是对象的类型模板 , 是一种抽象 , 并不表示实体</li><li><strong>实例</strong> : 是根据类创建的对象 , 表示某个具体的事物<a id="more"></a>类和实例是大多数面向对象编程语言的基本概念。</li></ol><p>不过，在JavaScript中，这个概念需要改一改。JavaScript不区分类和实例的概念，而是通过<code>原型（prototype）</code>来实现面向对象编程。</p><p>既然没有类的概念 , 我们就需要用某个对象来模拟一个类了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name : <span class="string">"Unnamed"</span>,</span><br><span class="line">  run : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"is running..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//现在我们可以把person来当做一个原型对象, 来创建一个具体的"人"</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">  name : <span class="string">"小明"</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.__proto__ = person;</span><br></pre></td></tr></table></figure></p><p>JavaScript当中的原型链 , 既可以模拟由类创建实例的关系<br>也可以模拟继承的关系<br>原型对象本身也可以有原型对象 , 从而构成<code>原型链</code><br>默认原型对象是<code>Object</code><br>当然在运行中也可以随时改变某个对象的原型对象</p><blockquote><p>以上代码主要用于表示原型链的实际关系 , 实际编程当中最好不要直接去修改对象的<code>__proto__</code><br><code>Object.create()</code>方法可以传入一个原型对象 , 用来构造出一个新对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = <span class="built_in">Object</span>.create(person);</span><br><span class="line">xiaoming.name = <span class="string">"小明"</span>;</span><br><span class="line"><span class="comment">//验证原型对象</span></span><br><span class="line">xiaoming.__proto__ === person; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>当我们访问某个对象的属性时 , 例如<code>obj.xxx</code><br>js引擎会先在该对象上查找该属性 , 如果没找到 , 就会到原型对象上去找 , 也就是顺着原型链一直向上回溯 , 直到<code>Object.prototype</code>对象 ,  如果还没有 , 那么就是undefined</p><p>除此之外 , 也可以使用<code>构造函数</code>来创建对象<br>构造函数本身和普通的函数没什么区别 , 只是用<strong>new</strong>关键字来调用 , 就会返回一个需要构建的对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"sookie"</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student();</span><br><span class="line">stu.say();</span><br></pre></td></tr></table></figure></p><p>如果按照普通函数的调用方式执行调用 , 其中的this就表示window对象<br>那么其中代码的效果就是定义了几个全局属性<br>如果使用 new 来调用该函数 , 那么它绑定的this就指向新创建的对象<br>并默认返回this ( 不需要写return )</p><p>使用这种方式创建的对象还从原型上获得了一个 constructor 属性<br>指向这个构造函数本身<br><img src="/images/JavaScript/OOP1.png" alt="constructor"></p><p>—&gt; 另外这个对象中有一个 say 属性 , 它是一个函数<br>在这种情况下 , 这个函数是属于stu对象的 , 并不属于该对象的原型<br>如果使用原型创建了多个对象 , 其中就会有很多重复的函数<br>所以可以把这个函数放入到Student的prototype当中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"sookie"</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="built_in">console</span>.log(stu1.say == stu2.say)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/OOP2.png" alt="prototype"></p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.2、地理位置索引</title>
      <link href="/MongoDB/3.2%E3%80%81%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E7%B4%A2%E5%BC%95/"/>
      <url>/MongoDB/3.2%E3%80%81%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<p>概念 : 将一些点的位置存储在MongoDB当中<br>创建索引后 , 可以按照位置来查找其他点<br><a id="more"></a></p><p>子分类</p><ol><li>2D索引 , 用于存储和查找平面上的点</li><li>2Dsphere索引 , 用于存储和查找球面上的点</li></ol><p>查找方式</p><ol><li>查找距离某个点一定距离内的点</li><li>查找包含在某区域内的点</li></ol><h4 id="2D索引"><a href="#2D索引" class="headerlink" title="2D索引"></a>2D索引</h4><p>位置使用经纬度两个值构成的数组来表示<br>取值范围 : 经度 [-180 , 180] , 纬度 [-90 , 90]</p><h5 id="添加2d索引"><a href="#添加2d索引" class="headerlink" title="添加2d索引"></a>添加2d索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.ensureIndex( &#123; 字段名 : &quot;2d&quot; &#125; )</span><br></pre></td></tr></table></figure><p>添加该索引之后 , 向该集合当中插入的数据 , 如果该字段不符合经纬度的要求 , 就会报错</p><h5 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h5><p><code>$near</code> 查询距离某个点距离最近的点 , 并且从近到远排列 , 默认至多返回100条数据</p><p>如果一个集合当中已有了如下的数据 , 并且已添加2d索引<br><img src="/images/MongoDB/location_index1.png" alt="location index"><br>执行查询<br><code>.find({w:{$near:[50,50]}})</code><br>获得的结果如下<br><img src="/images/MongoDB/location_index2.png" alt="location index"><br>如果要查询检索的范围<br>可以用$maxDistance 和 $minDistance操作符<br>表示最远距离和最近距离 , 不在这个范围内的点将会被过滤掉<br><img src="/images/MongoDB/location_index3.png" alt="location index"></p><blockquote><p>也可以使用<code>db.runCommand</code>方法 , 这个方法可以有更加详细的参数和返回结果<br>比如 <strong>db.runCommand({getNear:”test”,near:[5,5],manDistance:20,num:3}</strong><br>返回的结果可以获得符合要求的点与指定点的距离 , 以及平均距离等数据</p></blockquote><h5 id="geoWithin查询某个形状内的点"><a href="#geoWithin查询某个形状内的点" class="headerlink" title="$geoWithin查询某个形状内的点"></a><code>$geoWithin</code>查询某个形状内的点</h5><ol><li><code>$box:[ [x1, y1] , [x2 , y2] ]</code> 表示矩形 , 参数分别表示左下坐标和右上坐标</li><li><code>$center :[[x1,y1] , r]</code> 表示圆形 , 参数是圆心和半径</li><li><code>$polygon : [[x1,y1],[x2,y2] ...]</code> 表示多边形 , 参数为多边形每个顶点的坐标</li></ol><p>例如 <strong>.find({w:{$geoWithin:{$box:[[1,1],[50,50]]}}})</strong><br>其他两种方式用法同理</p><h4 id="2Dsphere索引"><a href="#2Dsphere索引" class="headerlink" title="2Dsphere索引"></a>2Dsphere索引</h4><p>球面地理位置索引<br>创建方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.ensureIndex(&#123;w:&quot;2dsphere&quot;&#125;)</span><br></pre></td></tr></table></figure></p><p>但是在这个索引对应的字段当中<br>数据就要使用GeoJSON来表示<br>格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;type:&quot;&quot;,coordinates:[&lt;coorinates&gt;]&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>关于GeoJSON的详细规范 , 参考下一篇笔记</p></blockquote><h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><p>举例 : 查询一个多边形当中的所有位置<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; w:</span><br><span class="line">  &#123; $geoWithin :</span><br><span class="line">    &#123; $geometry :</span><br><span class="line">      &#123;</span><br><span class="line">      type : "Polygon" ,</span><br><span class="line">      coordinates : [[[0,0],[3,6],[6,1],[0,0]]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>$geoIntersects</code>区域交叉 , 查询与多边形相交的所有的点和形状</li><li><code>$near</code>临近 , 与2D索引类似</li></ul>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.1、全文索引</title>
      <link href="/MongoDB/3.1%E3%80%81%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95/"/>
      <url>/MongoDB/3.1%E3%80%81%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<p><code>全文索引</code>是目前搜索引擎的关键技术<br>对于在大量的大文本当中搜索一个关键词<br>如果没有全文索引 , 只能是使用正则匹配进行遍历<br>效率十分低下<br><a id="more"></a><br>所以在这样的矛盾之下出现了全文索引技术 , 也称为<code>倒排文档技术</code></p><p>无论是对于庞大的互联网数据的爬取还是应用的站内搜索功能 , 全文索引都是能极大提高性能的一种技术</p><p>在mongoDB当中 , 全文索引是对字符串或字符串数组来创建全文索引</p><h4 id="创建全文索引"><a href="#创建全文索引" class="headerlink" title="创建全文索引"></a>创建全文索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.ensureIndex(&#123;key_1:&quot;text&quot;...)</span><br></pre></td></tr></table></figure><p>与普通的单键索引或者符合索引有区别的是<br>json当中的值是一个 <strong>固定字符串”text”</strong> , 而不是整数<br>上述写法是对某个或者某几个字段创建全文索引<br>但是取决于mongoDB存储数据的特点<br>每个集合当中的数据可以有完全不同的结构<br>所以通常用如下得到方式对该集合当中所有的字符串或字符串数组字段添加全文索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.ensureIndex(&#123;&quot;$**&quot;:&quot;text&quot;&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>每个集合当中只能创建一个全文索引</p></blockquote><h4 id="使用全文索引进行查询"><a href="#使用全文索引进行查询" class="headerlink" title="使用全文索引进行查询"></a>使用全文索引进行查询</h4><ul><li><code>find({$text:{$search:&quot;aa&quot;}})</code> - 普通单关键字匹配</li><li><code>find({$text:{$search:&quot;aa bb&quot;}})</code> - 多关键字匹配 ( 不同关键字之间是或的逻辑关系 )</li><li><code>find({$text:{$search:&quot;\&quot;aa\&quot; \&quot;bb\&quot;&quot;}})</code> - 多关键字匹配 ( 不同关键字之间是与的逻辑关系 )</li><li><code>find({$text:{$search:&quot;aa bb -cc&quot;}})</code> - 添加屏蔽的关键字</li></ul><blockquote><p><strong>注意</strong> : 上述的全文索引的搜索方式是根据英文单词进行匹配的 , 也就是按照空白( 包括空格 换行 制表符等 )分割的字符串 , 如果关键词是单词的一部分 , 或者是中文内容 , 这种方式就无法检索到需要的数据</p></blockquote><h4 id="相似度查询"><a href="#相似度查询" class="headerlink" title="相似度查询"></a>相似度查询</h4><p><code>$meta</code>操作符 { score : {$meta : “textScore”} }<br>( 注意textScore是固定的操作符标识 , 代表相似度值 )<br>写在查询条件后面可以返回结果的相似度</p><p>例如 在一个添加了全文索引的集合当中有下列数据<br><img src="/images/MongoDB/full_text_search1.png" alt="full text search"></p><p>执行下面的查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.find(&#123;$text:&#123;$search:&quot;aa&quot;&#125;&#125;,&#123;score:&#123;$meta:&quot;textScore&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>结果如下<br><img src="/images/MongoDB/full_text_search2.png" alt="full text search"></p><blockquote><p>目前新版的mongoDB执行全文索引的查询后的结果默认就是按照相似度降序排列的</p></blockquote><p>添加全文索引会导致集合的写入性能下降 , 因为所有的字符串都要拆分 , 存储到不同的地方</p>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3.0、索引</title>
      <link href="/MongoDB/3.0%E3%80%81%E7%B4%A2%E5%BC%95/"/>
      <url>/MongoDB/3.0%E3%80%81%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<p>索引是对数据库表中一列或多列的值进行排序的一种结构，进行排序以后 , 数据的检索效率就会极大提高 , 因为不需要遍历所有的数据 , 所以使用索引可快速访问数据库表中的特定信息。<br><a id="more"></a></p><h4 id="查看集合当中的索引"><a href="#查看集合当中的索引" class="headerlink" title="查看集合当中的索引"></a>查看集合当中的索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.getIndexes()</span><br></pre></td></tr></table></figure><p>每个集合当中都包含一个默认创建的索引 , 就是主键id的索引 , 名称是 _id_<br><img src="/images/MongoDB/getIndexes.png" alt="getIndexes"></p><h4 id="mongoDB当中的索引类型"><a href="#mongoDB当中的索引类型" class="headerlink" title="mongoDB当中的索引类型"></a>mongoDB当中的索引类型</h4><ul><li><code>_id索引</code> : 在集合被创建的时候自动添加的索引 , 不能删除 ( 也是一种单键索引 )</li><li><code>单键索引</code> : 针对单个字段创建的索引</li><li><code>多键索引</code> : 在数组元素上建立的索引 , 会对数组的每个元素添加索引</li><li><code>复合索引</code> : 针对多个字段创建的索引</li><li><code>过期索引</code> : 在一定时间后会过期的索引 , 索引过期后 , 相应的数据会被删除<br>适合存储一些登陆信息 日志等数据</li><li><code>全文索引</code></li><li><code>地理位置索引</code></li></ul><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.ensureIndex( &#123;索引字段名1: 1 , 索引字段名2 : 1 ...&#125; , [索引属性] )</span><br></pre></td></tr></table></figure><p>索引类型1表示按照升序方式存储索引 , -1表示降序<br>有多个索引字段时 , 该索引就是一个复合索引<br>索引属性的可选参数 , 后面有具体的介绍</p><h5 id="创建过期索引"><a href="#创建过期索引" class="headerlink" title="创建过期索引"></a>创建过期索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.ensureIndex( &#123;索引字段名 :1 ...&#125; , &#123;expireAfterSeconds : 过期的秒数&#125; )</span><br></pre></td></tr></table></figure><p>注意 : </p><ol><li>过期索引对应的字段必须是Date类型 或者 Date的数组 , 否则不会被自动删除<br>-&gt; 可以使用 .insert( {time : new Date()} ) 来获取当前的日期时间</li><li>如果是Date的数组 , 只要有其中任意一个到了过期时间 , 该数据就会被删除</li><li>过期索引不可以是复合索引</li><li>删除的执行是由后台的一个60s执行一次的定时任务完成 , 所以删除的时间是不精确的</li></ol><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.dropIndex(&quot;索引名称&quot;)</span><br></pre></td></tr></table></figure><p>注意是索引名称 , 而不是索引所对应的字段</p><hr><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><strong>在执行查询时强制使用索引</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.find( 查询条件 ).hint( 索引名称 )</span><br></pre></td></tr></table></figure></p><p><strong>索引当中的其他几个重要的属性</strong></p><ul><li><code>name</code> - 索引的名称 , 不指定的话可以由系统自动生成</li><li><code>unique</code> - (true/false) 索引的唯一性 , 相当于为添加该索引的某个或多个字段添加了唯一约束 , 不能插入重复的两条数据 (默认false)</li><li><code>sparse</code> - (true/false) 稀疏性 默认false , 为某个字段添加索引之后 , 由于非关系型数据库的特点 , 某条数据可能并不包含该字段的键值对数据 , 如果在非稀疏的模式下 , 也会为该数据创建索引 , 如果不希望如此 , 可以把sparse置为true . 有助于减少磁盘占用 , 提高写入性能</li></ul><p>注意 : 鉴于稀疏索引本身的这种特性 , 如果我们强制使用稀疏索引去查找不存在某个字段的数据 , 就会出现问题 , 因为这些数据不存在于稀疏索引当中<br>例如 “m_1”是一个针对m字段的稀疏索引<br>执行 db.test.find({m : {$exists:false }}).hint(“m_1”)<br>即使有符合条件的数据 , 也不可能返回任何结果</p>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.1、数据查询</title>
      <link href="/MongoDB/2.1%E3%80%81%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"/>
      <url>/MongoDB/2.1%E3%80%81%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</url>
      <content type="html"><![CDATA[<h4 id="db-集合名称-find-查询条件-查询的字段"><a href="#db-集合名称-find-查询条件-查询的字段" class="headerlink" title="db.集合名称.find([查询条件],[查询的字段])"></a><code>db.集合名称.find([查询条件],[查询的字段])</code></h4><ul><li>查询条件是JSON格式的数据<br>省略表示查询该集合当中的全部数据</li><li>查询的字段也是用JSON格式表示 ,字段值是非零表示包含该字段 , 0则表示排除该字段 ( 但两种方式不能同时用 )<a id="more"></a>比如 {x : 1} 表示只查询主键_id和字段x的内容<br>主键_id是默认被包含的 , 如果要排除可以写 { _id : 0 }<blockquote><p><code>db.集合名称.findOne()</code> 表示只返回查询结果的第一条数据</p></blockquote><h4 id="模糊查询条件"><a href="#模糊查询条件" class="headerlink" title="模糊查询条件"></a>模糊查询条件</h4>直接使用普通的json是作为精确条件<br>也可以使用某个范围作为模糊条件<br>例如<br><code>{age:{$gt:22}}</code><br>是查找age字段大于22的数据<br>( 也可以应用于字符串 )</li></ul><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>$gt</td><td>大于</td></tr><tr><td>$lt</td><td>小于</td></tr><tr><td>$gte</td><td>大于等于</td></tr><tr><td>$lte</td><td>小于等于</td></tr></tbody></table><p>字符串的模糊匹配使用类似JavaScript当中正则表达式的方式<br>比如<code>/mongodb/</code>表示包含”mongodb”子串<br>相当于 <code>...where xx like &#39;%mongodb%&#39;</code><br><code>/^mongodb/</code>表示以”mongodb”开头</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul><li><strong>逻辑与 $and: </strong>一个json中写的多个键值对本身就表示and<br>也可以用<code>{$and:[{a:1},{b:2}]}</code>表示<code>... where a=1 and b=2</code></li><li><strong>逻辑或 $or: </strong> <code>{$or:[{a:1},{b:2}]}</code><br>表示 <code>... where a=1 or b=2</code></li><li><strong>某个字段 存在/不存在 $exists : </strong><code>{a:{$exists:true}}</code>表示存在a字段的数据 <h4 id="对查询结果的处理"><a href="#对查询结果的处理" class="headerlink" title="对查询结果的处理"></a>对查询结果的处理</h4>以下都是在<code>db.集合名称.find(查询条件)</code>获得的查询结果的基础上执行的函数</li></ul><p><strong>结果计数</strong><br><code>.count()</code><br>对查询结果执行count函数 , 可以统计查询结果的数量</p><p><strong>分页查询</strong><br><code>.skip(num).limit(num)</code><br>skip表示跳过前面的若干条数据 , limit是返回数据的最大数量</p><p><strong>结果排序</strong><br><code>.sort(排序条件)</code><br>排序条件是json的形式 { 字段名 : 1 } 或者  { 字段名 : -1 }<br>前者表示升序 , 后者表示降序 , 不能用其他的数字</p>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.0、数据库基本操作</title>
      <link href="/MongoDB/2.0%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/MongoDB/2.0%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>mongoDB当中也存在数据库和表的划分<br>但是这里的一个表可以看做是一个集合<br>里面可以容纳各种结构的数据x<br>每一条数据的结构可以各不相同<br><a id="more"></a></p><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><ul><li><code>show dbs</code> 查看数据库列表</li><li><code>show collections</code> 显示当前数据库当中的集合( 类似于关系型数据库中的表 )</li><li><code>show users</code> 显示用户</li><li><code>use 数据库名称</code> 切换数据库</li><li><code>db.createCollection(&#39;集合名称&#39;)</code> 创建集合<br>mongoDB没有创建数据库的命令<br>可以直接使用use 数据库名称 切换数据库 , 然后创建任意一个集合 , 这个数据库就会自动创建</li><li><code>db.dropDatabase()</code> 删除当前正在使用的数据库</li><li><code>db.集合名称.drop()</code> 删除当前数据库的指定集合</li></ul><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>首先切换到需要使用的数据库 , 然后执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.&lt;集合名称&gt;.insert(数据)</span><br></pre></td></tr></table></figure></p><p>这里的数据是json结构<br>执行插入数据过后<br>数据当中会自动生成一个主键_id属性 , 全局唯一</p><p><img src="/images/MongoDB/insert.png" alt="insert"><br>这个属性值也可以在插入数据的时候指定</p><p>执行的命令当中也可以使用流程控制的语法<br>比如<code>for(i=0;i&lt;20;i++)db.集合名称.insert({&quot;x&quot;:i})</code><br>( 属性名也可以不加双引号 , 因为它一定是字符串 , 下同 )</p><p>修改数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.update(筛选条件,新数据,[是否新增],[是否批量更新])</span><br></pre></td></tr></table></figure></p><ul><li>筛选条件和新数据都是json形式的 , 是必填参数</li><li>第三个参数是可选的 , 当筛选条件没有匹配到任何数据的时候 , 是否将新数据插入到集合当中 , 默认是false<br>如果省略第三个参数 , 或者传入false , 那么当筛选条件没有匹配到数据<br>该函数不会有任何效果</li><li>第四个参数是可选的 , 表示当该筛选条件匹配到多条数据时 , 是否更新全部 , 默认为false ( 目的是为了防止批量覆盖数据的误操作 ) , 当该参数使用true的时候 , 必须使用$set操作符进行部分数据的更新操作 , 具体方式下面有介绍<br>例如<br><strong>db.demo.update( {x:1}, {x:99} )</strong></li></ul><blockquote><p>直接使用上述方式会覆盖整条数据的内容<br>如果要修改数据的部分内容<br>比如有如下数据 : { “x”:10 , “y”:10 , “z”:10 }<br>可以使用$set操作符<br>例如 db.demo.update( {x:10}, {$set : {y:20} } )<br>这样只会修改y的值 , x和z的值都不变</p></blockquote><h3 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.remove(筛选条件)</span><br></pre></td></tr></table></figure><p>为了防止误操作 , 筛选条件是必填的</p>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1.1、MongoDB的安装与配置</title>
      <link href="/MongoDB/1.1%E3%80%81MongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/MongoDB/1.1%E3%80%81MongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<ol><li><p><strong>安装mongoDB的安装包</strong><br>直接在官网下载即可</p></li><li><p><strong>创建数据库目录与日志目录</strong></p><a id="more"></a><p>例如在D盘创建目录<br><strong>D:/mongoDB/data/db</strong>作为数据库存储目录<br><strong>D:/mongoDB/data/log</strong>作为数据库日志的存储目录</p></li><li><p><strong>添加windows service</strong></p></li></ol><p>在控制台执行以下命令<br>(1) 定位到自己的mongodb的安装目录\bin<br>例如 <strong>cd C:\Program Files\mongodb\bin</strong><br>(2) 创建服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath &quot;D:/mongoDB/data/db&quot; --logpath &quot;D:/mongoDB/data/log/mongdb.log&quot; --install --serviceName &quot;MongoDB&quot;</span><br></pre></td></tr></table></figure></p><p>其中包含的两个路径是在上一步中创建的数据库目录和日志目录(日志目录需要加上文件的名称)</p><ol start="4"><li><strong>启动MongoDB服务</strong></li></ol><p><img src="/images/MongoDB/mongodb_server.png" alt="mongodb_server"></p><ol start="5"><li><strong>尝试访问<code>http://localhost:27017/</code></strong></li></ol><p>如果可以正常访问 , 代表mongoDB的安装配置成功</p><ol start="6"><li><strong>连接数据库</strong></li></ol><p>直接执行安装目录下bin当中的mongo.exe文件<br>C:\Program Files\MongoDB\Server\3.2\bin\mongo.exe<br>在控制台访问数据库 , 执行help可以查看指令列表</p><ol start="7"><li><strong>可视化工具</strong></li></ol><p>可以试用robomongo作为可视化工具</p>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1.0、NoSQL</title>
      <link href="/MongoDB/1.0%E3%80%81NoSQL/"/>
      <url>/MongoDB/1.0%E3%80%81NoSQL/</url>
      <content type="html"><![CDATA[<p>NoSQL ( Not Only SQL ) , 泛指<code>非关系型数据库</code><br>传统的关系型数据库在超大规模和高并发的纯动态网站已经显得力不从心 , 暴露了很多难以克服的问题<br>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战 , 尤其是大数据应用难题<br><a id="more"></a></p><blockquote><p>NoSQL数据库的共同特征</p><ul><li><code>不需要预定义模式</code><br>不需要事先定义数据模式，预定义表结构。数据中的每条记录都可能有不同的属性和格式。当插入数据时，并不需要预先定义它们的模式。</li><li><code>无共享架构</code><br>相对于将所有数据存储的存储区域网络中的全共享架构。NoSQL往往将数据划分后存储在各个本地服务器上。因为从本地磁盘读取数据的性能往往好于通过网络传输读取数据的性能，从而提高了系统的性能。</li><li><code>弹性可扩展</code><br>可以在系统运行的时候，动态增加或者删除结点。不需要停机维护，数据可以自动迁移。</li><li><code>分区</code><br>相对于将数据存放于同一个节点，NoSQL数据库需要将数据进行分区，将记录分散在多个节点上面。并且通常分区的同时还要做复制。这样既提高了并行性能，又能保证没有单点失效的问题。</li><li><code>异步复制</code><br>和RAID存储系统不同的是，NoSQL中的复制，往往是基于日志的异步复制。这样，数据就可以尽快地写入一个节点，而不会被网络传输引起迟延。缺点是并不总是能保证一致性，这样的方式在出现故障的时候，可能会丢失少量的数据。</li><li><code>BASE</code><br>相对于事务严格的ACID特性，NoSQL数据库保证的是BASE特性。BASE是最终一致性和软事务。</li></ul></blockquote><hr><h4 id="mongoDB的优点"><a href="#mongoDB的优点" class="headerlink" title="mongoDB的优点"></a>mongoDB的优点</h4><ol><li><code>无数据结构的限制</code> , 没有表结构的概念 , 每条记录可以有完全不同的结构 . 业务开发方便快捷<br>而关系型数据库则必须要首先定义表结构 , 当数据结构发生变化通常需要修改表结构 , 添加字段等</li><li><code>完全的索引支持</code> 键值索引 , 单键索引 , 多键索引 , 数组索引 , 全文索引 , 地理位置索引(2D)</li><li><code>安全性与可扩展性</code> 复制集保证数据安全 , 分片扩展数据规模</li><li><code>良好的支持</code> 完善的文档支持与驱动支持</li></ol>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git(4)-远程仓库</title>
      <link href="/git/Git(4)-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/git/Git(4)-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>在多人的协作开发当中 , 我们需要一个公共的远程库 , 每个人都可以从远程库把项目clone到自己的电脑上进行开发 , 之后把自己编写的代码推送到远程库<br>完全可以自己搭建一台运行的Git服务器 , 或者利用GitHub这种公共的Git托管服务<br><a id="more"></a><br>这里用<a href="https://gitlab.com/" target="_blank" rel="noopener">GitLab</a>来进行测试</p><h4 id="创建SSH-key"><a href="#创建SSH-key" class="headerlink" title="创建SSH key"></a>创建SSH key</h4><p>由于本地和远程仓库之间的传输是通过SSH加密的 ( 这个取决于Git托管服务本身的架构 , 如果不是的话可以跳过这个步骤 )<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"email地址"</span></span><br></pre></td></tr></table></figure></p><p>执行完成后在本地的用户主目录里面找到<code>.ssh</code>目录 , 里面有<code>id_rsa</code>和 <code>id_rsa.public</code><br>前一个是密钥 , 后一个是公钥<br>把公钥的内容添加到自己账号的SSH keys的设置当中<br><img src="/images/git/gitlab_ssh.png" alt="gitlab ssh"><br>Title是自己看的  随便写即可</p><h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p>在GitLab上创建一个名为git_learn的远程库<br>我的账号对应的SSH链接就是<a href="mailto:`git@gitlab.com" target="_blank" rel="noopener">`git@gitlab.com</a>:sookie/git_learn.git`<br>在本地的git仓库里面执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加远程库</span></span><br><span class="line">git remote add origin git@gitlab.com:sookie/git_learn.git</span><br></pre></td></tr></table></figure></p><p>origin是本地仓库中给这个远程库起的名字<br>一个本地仓库可以对应多个远程库</p><p>然后就可以把本地库的所有内容推送到远程库上<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#把master分支推送到名为origin的远程库</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><p>第一次推送的时候需要加<code>-u</code>参数<br>之后只需要执行<code>git push origin master</code>即可</p><h4 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h4><p>如果需要从一个远程库克隆出一个本地库<br>需要使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@gitlab.com:sookie/git_learn.git</span><br></pre></td></tr></table></figure></p><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p><blockquote><p>对于远程库的地址 , 还有<code>https://gitlab.com/sookie/git_learn.git</code>这样的地址<br>这是由于Git支持多种协议<br>如果服务器只开放了http端口 ,  那么就不能使用ssh协议而只能用https<br>原生的git协议速度比较快</p></blockquote>]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git(3)-分支</title>
      <link href="/git/Git(3)-%E5%88%86%E6%94%AF/"/>
      <url>/git/Git(3)-%E5%88%86%E6%94%AF/</url>
      <content type="html"><![CDATA[<h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><p>在git当中 , 对于每次提交 , git都把他们串成一条时间线<br>这条时间线就是一个分支 , 默认只有master这一条主分支<br>HEAD相当于是一个指针 , 指向的是当前操作的分支<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建分支dev</span></span><br><span class="line">git branch dev</span><br><span class="line"></span><br><span class="line"><span class="comment">#切换到分支dev</span></span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line">git checkout -b dev <span class="comment">#相当于同时执行上面两条命令</span></span><br><span class="line"><span class="comment">#创建并切换到该分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并分支dev到当前分支</span></span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除分支dev</span></span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure></p><p>通常在参与一个多人开发的项目时 , 需要创建一个分支进行开发 , 完成后把这个分支合并到主分支<br><img src="/images/git/git_merge.png" alt="git merge"><br>这里代表合并成功</p><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>如果不同的分支当中对同一个文件进行了修改 , 那么就会产生冲突 , 导致无法直接合并<br><img src="/images/git/分支冲突.png" alt="分支冲突"><br>这里提示的信息是03.txt文件在合并时产生了冲突<br>查看03.txt文件可以发现<br><img src="/images/git/冲突代码.png" alt="冲突代码"></p><p>这时候就需要手动去解决冲突<br>修改03.txt文件之后<br>在master分支当中执行 ( 此时因为处于处理分支合并冲突的过程当中 , 所以并不能切换分支 )<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add 03.txt</span><br><span class="line">git commit -a -m <span class="string">"resolve conflict 03"</span></span><br></pre></td></tr></table></figure></p><p>此时 , 这次的分支合并才算完成<br>子分支当中的修改内容并没有受到影响</p>]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git(2)-基础操作</title>
      <link href="/git/Git(2)-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>/git/Git(2)-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="版本库的基础操作"><a href="#版本库的基础操作" class="headerlink" title="版本库的基础操作"></a>版本库的基础操作</h3><p>版本库也可以称为<code>仓库</code>, 也就是一个目录 , 这个目录里面的所有文件都被Git管理起来 , 每个文件的修改 删除等 , Git都能追踪<br><a id="more"></a></p><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定位到需要创建仓库的目录下执行</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure><p>执行以后就把这个目录变为git可以管理的仓库<br>该目录下就会多了一个<strong>.git</strong>目录 , 这个目录是git用来追踪管理版本的 , 勿手动修改</p><h4 id="添加文件到版本库"><a href="#添加文件到版本库" class="headerlink" title="添加文件到版本库"></a>添加文件到版本库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加全部暂存区和历史区不存在的或者有更改的.c文件</span></span><br><span class="line">git add *.c</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加全部暂存区和历史区不存在或者有更改的文件</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加指定文件到版本库</span></span><br><span class="line">git add test.c</span><br></pre></td></tr></table></figure><p>使用<code>git status</code>可以查看当前版本库的状态<br>例如<br><img src="/images/git/git_status.png" alt="git status"><br>这个版本库当中有01.txt是已经添加到版本库但是没有提交的新文件 ( 该文件当前的状态就是<code>staged - 已暂存</code> )<br>使用<code>git rm --cached 01.txt</code>可以从暂存库当中移除01.txt , 相当于是add的逆操作<br>02.txt是没有添加到版本库的文件</p><h4 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h4><p>提交操作针对的是暂存区当中的文件 ( 或者说是已暂存状态的文件 )<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#提交暂存区所有的内容到版本库</span></span><br><span class="line">git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment">#提交暂存区中指定的文件到版本库</span></span><br><span class="line">git commit 01.txt</span><br></pre></td></tr></table></figure></p><blockquote><p>提交时可以直接使用-m参数来添加提交的注释<br>例如 <code>git commit -a -m &quot;我是注释&quot;</code><br>如果未添加 , 提交时则会自动调用vi编辑器来编辑提交注释信息<br>也可以修改core.edit来设定喜欢的编辑器</p></blockquote><p>如果提交01.txt完毕以后 , 再次修改了01.txt<br><img src="/images/git/git_modified.png" alt="modified"><br>此时该文件的状态就是<code>modified - 已修改</code><br>使用<code>git add</code>可以将其添加到暂存区</p><h4 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h4><p><code>git diff</code>命令用于比较指定文件的差异<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看所有有变动的文件</span></span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看指定文件的变动</span></span><br><span class="line">git diff 01.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看暂存区中文件的变动</span></span><br><span class="line">git diff --staged</span><br></pre></td></tr></table></figure></p><p><img src="/images/git/git_diff.png" alt="git diff"></p><h4 id="查看提交历史记录"><a href="#查看提交历史记录" class="headerlink" title="查看提交历史记录"></a>查看提交历史记录</h4><p>使用<code>git log</code>可以按照提交时间列出所有的提交<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#仅显示最近x次的提交 git log -x</span></span><br><span class="line">git <span class="built_in">log</span> -2 <span class="comment">#查看最近2次的提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#简略显示每次提交的内容变动</span></span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --pretty对展示内容进行格式化</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline <span class="comment">#在一行内仅显示每次提交的hash码与注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#自定义格式化</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">"%h - %an,%ar : %s"</span></span><br></pre></td></tr></table></figure></p><p>format当中的占位符含义</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>%H</td><td>提交对象（commit）的完整哈希字串</td></tr><tr><td>%h</td><td>提交对象的简短哈希字串</td></tr><tr><td>%T</td><td>树对象（tree）的完整哈希字串</td></tr><tr><td>%t</td><td>树对象的简短哈希字串</td></tr><tr><td>%P</td><td>父对象（parent）的完整哈希字串</td></tr><tr><td>%p</td><td>父对象的简短哈希字串</td></tr><tr><td>%an</td><td>作者（author）的名字</td></tr><tr><td>%ae</td><td>作者的电子邮件地址</td></tr><tr><td>%ad</td><td>作者修订日期（可以用 –date= 选项定制格式）</td></tr><tr><td>%ar</td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td>%cn</td><td>提交者(committer)的名字</td></tr><tr><td>%ce</td><td>提交者的电子邮件地址</td></tr><tr><td>%cd</td><td>提交日期</td></tr><tr><td>%cr</td><td>提交日期，按多久以前的方式显示</td></tr><tr><td>%s</td><td>提交说明</td></tr></tbody></table><h4 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h4><h5 id="重新提交"><a href="#重新提交" class="headerlink" title="重新提交"></a>重新提交</h5><p>如果执行<code>git commit</code>之后发现了漏掉了一个文件 , 再进行一次提交又显得多余<br>这时候可以使用<strong>amend</strong>进行重新提交<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure></p><h5 id="取消暂存"><a href="#取消暂存" class="headerlink" title="取消暂存"></a>取消暂存</h5><p>执行了git add 之后 , 如果要进行撤销<br>( 与git rm作用类似 )<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD 03.txt</span><br></pre></td></tr></table></figure></p><p>但是reset还可以对已提交的内容进行版本的回退<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#回退当上一个版本</span></span><br><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></p><blockquote><p>如果要回退当上上个版本就是HEAD^^<br>也可以使用简便写法<code>git reset --hard HEAD~100</code>表示回退到100个版本之前</p></blockquote><p>此时执行了回退 , 我们发现最后一次提交所做的修改已经没有了<br>如果还想找回来 , 可以执行<code>git reflog</code>来查看操作记录 , 找到最后一次提交的版本号<br><img src="/images/git/git_reflog.png" alt="git reflog"><br>执行以后发现是8725f93<br>于是执行<code>git reset --hard 8725F93</code><br>即可再次恢复到最新版本</p><h5 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h5><p>当文件被修改 , 但还没有git add到暂存区 ( 或者从暂存区当中撤销回到工作区也一样 )<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure></p><blockquote><p>注意 : 该操作会导致修改彻底丢失 , 无法恢复</p></blockquote>]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git(1)-初见</title>
      <link href="/git/Git(1)-%E5%88%9D%E8%A7%81/"/>
      <url>/git/Git(1)-%E5%88%9D%E8%A7%81/</url>
      <content type="html"><![CDATA[<p>Git是分布式版本控制系统，与SVN类似的集中化版本控制系统相比，集中化版本控制系统虽然能够令多个团队成员一起协作开发，但有时如果中央服务器宕机的话，谁也无法在宕机期间提交更新和协同开发。甚至有时，中央服务器磁盘故障，恰巧又没有做备份或备份没及时，那就可能有丢失数据的风险。<br><a id="more"></a><br>但Git是分布式的版本控制系统，客户端不只是提取最新版本的快照，而且将整个代码仓库镜像复制下来。如果任何协同工作用的服务器发生故障了，也可以用任何一个代码仓库来恢复。而且在协作服务器宕机期间，你也可以提交代码到本地仓库，当协作服务器正常工作后，你再将本地仓库同步到远程仓库。</p><h4 id="Git的优势"><a href="#Git的优势" class="headerlink" title="Git的优势"></a>Git的优势</h4><ul><li>能够对文本版本控制和多人协作开发</li><li>拥有强大的分支特性 , 所以能够灵活地以不同的工作流协同开发</li><li>分布式版本控制系统 , 即使无网络的情况下也能提交代码到本地仓库 , 有网络时再同步到远程仓库</li><li>当团队中某个成员完成某个功能时 , 通过pull request操作来通知其他团队成员 , 其他成员可以进行review code后再合并代码</li></ul><h4 id="Git的特性"><a href="#Git的特性" class="headerlink" title="Git的特性"></a>Git的特性</h4><ul><li>版本库当中的文件有3种状态 , 分别是<code>已提交(committed)</code> , <code>已修改(modified)</code> , <code>已暂存(staged)</code></li><li>直接记录快照 , 而非差异比较</li><li>多数操作仅添加数据</li><li>几乎所有的操作都是在本地执行</li><li>时刻保持数据的完整性</li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p>Git自带一个<code>git config</code>工具来帮主设置git的相关配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看操作系统中所有用户的通用配置</span></span><br><span class="line">git config --system --list</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前用户的配置</span></span><br><span class="line">git config --global --list</span><br></pre></td></tr></table></figure></p><p>如果是当前仓库中 , 则在.git/config 中的配置是只针对该仓库的 , 每个级别的配置会覆盖上一个级别的配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以单独查看某一项配置信息</span></span><br><span class="line"><span class="comment">#如果没有指定级别,则表示查看最终生效的配置信息</span></span><br><span class="line">git config user.name</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者指定某个级别的某个属性</span></span><br><span class="line">git config --global user.name</span><br></pre></td></tr></table></figure></p><h5 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"NewName"</span></span><br><span class="line"><span class="comment">#如果不加global则表示只修改当前库当中的配置信息</span></span><br></pre></td></tr></table></figure><h4 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h4><p>每个库中都可以存在一个该文件<br>用来配置不需要git进行追踪的文件 , 比如日志 , 编译的临时文件等<br>内容规范如下</p><ul><li><code>#</code>开头表示注释</li><li>可以使用标准的glob模式匹配</li><li>匹配模式以<code>/</code>开头防止递归</li><li>匹配模式以<code>/</code>结尾指定目录</li><li>要忽略指定模式以外的文件或目录 , 可以在模式前加上<code>!</code>表示取反</li></ul><p>glob模式是一种简化的正则表达式</p><ul><li><code>*</code> 匹配零个或多个任意字符</li><li><code>[abc]</code> 只包含括号内的任意一个字符</li><li><code>[0-9]</code> 横线表示范围</li><li><code>?</code> 匹配任意一个字符</li><li><code>**</code> 匹配任意的目录结构</li></ul>]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SASS-语法(2)</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/SASS-%E8%AF%AD%E6%B3%95(2)/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/SASS-%E8%AF%AD%E6%B3%95(2)/</url>
      <content type="html"><![CDATA[<h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符 %"></a>占位符 %</h3><p>使用占位符定义的代码块 , 它同普通的基类一样可以被继承 , 但是本身在编译后不会产生任何代码 , 可以有效避免代码的冗余</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%<span class="selector-tag">base</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span> : <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> %base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>编译后会得到<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">margin </span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在sass当中包含以下几种数据类型</p><ul><li><strong>数字</strong> , 如 1  2.6  10px</li><li><strong>字符串</strong> , 可以有引号 , 也可以无引号</li><li><strong>颜色</strong> , 如 blue  #04a3f9  rgba(255,0,0,0.5)</li><li><strong>布尔值</strong> , true与false</li><li><strong>值列表</strong> , 用空格或者逗号分隔的多个值构成的集合</li></ul><p>对于其他css当中支持的标识 , 比如!import声明 , 都被视为无引号字符串</p><p>对于有引号字符串 , 当被作为插值使用时 , 会自动变为无引号字符串<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$direction</span> : (<span class="string">'left'</span>, <span class="string">"right"</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.panel</span> &#123;</span><br><span class="line">  @<span class="keyword">each</span> <span class="variable">$direct</span> in <span class="variable">$direction</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>-#&#123;<span class="variable">$direct</span>&#125; : <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding</span>-#&#123;<span class="variable">$direct</span>&#125; : <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="值列表相关函数"><a href="#值列表相关函数" class="headerlink" title="值列表相关函数"></a>值列表相关函数</h3><p>相关的函数比较多 , 这里列举几个常用的</p><h4 id="nth-值列表-索引"><a href="#nth-值列表-索引" class="headerlink" title="nth(值列表, 索引)"></a><code>nth(值列表, 索引)</code></h4><p>根据索引获取值列表当中的某一个元素 ( 索引值从1开始 )<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$direction</span> : (left, right);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.panel</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>-#&#123;nth(<span class="variable">$direction</span>, 2)&#125; : <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>-#&#123;nth(<span class="variable">$direction</span>, 1)&#125; : <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译后的结果为<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.panel</span> &#123; </span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">10px</span>; </span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">10px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="join-值列表1-值列表2"><a href="#join-值列表1-值列表2" class="headerlink" title="join(值列表1, 值列表2)"></a><code>join(值列表1, 值列表2)</code></h4><p>将两个值列表合并为一个值列表 , 并返回合并后的结果<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$num1</span> : (<span class="number">10px</span>, <span class="number">30px</span>);</span><br><span class="line"><span class="variable">$num2</span> : (<span class="number">5px</span>, <span class="number">9px</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.panel</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: join(<span class="variable">$num1</span>, <span class="variable">$num2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="append-值列表-新元素"><a href="#append-值列表-新元素" class="headerlink" title="append(值列表, 新元素)"></a><code>append(值列表, 新元素)</code></h4><p>将某个元素添加到值列表的末尾 , 并返回新的列表 ( 是产生一个新的列表 , 并不会改变原本的列表 )</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$num1</span> : (<span class="number">10px</span>, <span class="number">30px</span>);</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span> : append(<span class="variable">$num1</span>, <span class="number">15px</span>);</span><br><span class="line">  <span class="attribute">padding</span> : <span class="variable">$num1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">margin </span>: <span class="number">10px</span> <span class="number">30px</span> <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding </span>: <span class="number">10px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>length(值列表)</code> - 返回列表中元素的数量</li><li><code>index(值列表, 元素)</code> - 返回该元素在值列表当中的位置 , 不存在则返回false</li></ul><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="长度运算"><a href="#长度运算" class="headerlink" title="长度运算"></a>长度运算</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$width1</span> : <span class="number">30pt</span>;</span><br><span class="line"><span class="variable">$width2</span> : <span class="number">10px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.panel</span> &#123;</span><br><span class="line">  <span class="attribute">width</span> : <span class="variable">$width1</span> + <span class="variable">$width2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后结果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.panel</span> &#123; <span class="attribute">width</span>: <span class="number">37.5pt</span>; &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意</strong></p><ol><li>编译后结果的单位以表达式中第一个有单位的元素的单位为准 , 单位不一致的会自动进行换算</li><li>in cm mm pt pc px等属于绝对单位<br>em rem ex 属于相对当前字体的单位<br>不同类型的不能直接进行运算</li><li>运算符两侧最好加上空格 , 避免与css本身的连接符冲突 ( 减号会存在此问题 )</li><li>乘法运算当中只能有一个元素存在单位 , 如果有多个元素存在单位则会报错</li><li>除法运算最好加括号 , 对于两个常量的情况 , 比如<code>width : 20px/2</code> , 编译后并不会执行该运算 , 应该写作<code>width:(20px/2)</code></li></ol></blockquote><h4 id="颜色运算"><a href="#颜色运算" class="headerlink" title="颜色运算"></a>颜色运算</h4><p>对于颜色类型的变量或者常量 , 都是支持运算的<br>运算的方式是进行分段运算 , 也就是对 RGB 的值分别进行运算<br>( 颜色值本身相当于4个数字 , 并不存在单位 , 所以不存在长度运算当中的单位类型不一致无法计算的问题 )<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#010203</span> + <span class="number">#040506</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译后的结果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: <span class="number">#050709</span>; &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意</strong><br>如果使用rgba , 也就是存在透明度的值 , 运算当中的a值必须相等 , 否则无法运算</p></blockquote>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> sass </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SASS-语法(1)</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/SASS-%E8%AF%AD%E6%B3%95(1)/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/SASS-%E8%AF%AD%E6%B3%95(1)/</url>
      <content type="html"><![CDATA[<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在scss当中定义变量的语法如下</p><p><pre><br>$变量名 : 变量值;<br></pre><br>代码块外部定义的变量可以在全局范围内使用<br><a id="more"></a><br>在代码块内部定义的变量是局部变量<br>例如<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="variable">$color</span>:red;</span><br><span class="line">  <span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="variable">$color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果该变量的值需要嵌入到字符串当中 , 需要加<code>#{ }</code><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$side</span> : left;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>-#&#123;<span class="variable">$side</span>&#125;-radius:<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="默认变量"><a href="#默认变量" class="headerlink" title="默认变量"></a>默认变量</h4><p>sass的默认变量一般用来设置默认值 , 然后根据需求来进行覆盖<br>例如<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a_padding</span> : <span class="number">20px</span> !default;</span><br><span class="line"><span class="variable">$a_padding</span> : <span class="number">6px</span>;</span><br></pre></td></tr></table></figure></p><p>如果对默认变量的值进行了覆盖 , 那么实际输出的就是覆盖之后的值 , 否则输出的就是默认值</p><p>如果是在一个单文件当中 , 并没有必要这样做<br>默认变量在<code>组件化开发</code>的时候会非常有用</p><blockquote><p>什么时候需要声明变量</p><ul><li>该值至少重复出现了两次</li><li>该值至少可能会被更新一次</li><li>该值所有的表现都与变量有关</li></ul></blockquote><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>使用嵌套的方式来编写css代码 , 可以使元素之间的层级关系更清晰 , 代码的可读性更强</p><h4 id="选择器嵌套"><a href="#选择器嵌套" class="headerlink" title="选择器嵌套"></a>选择器嵌套</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span> :red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div h1 &#123;</span><br><span class="line">  color : red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面如果加上 <code>&gt;</code>可以作为父子选择器</p><p>在嵌套的代码块内 , 可以使用<code>&amp;</code>引用父元素<br>比如<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  &amp;:hover&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line">  &amp;:visited&#123;<span class="attribute">color</span>:gray;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="属性嵌套"><a href="#属性嵌套" class="headerlink" title="属性嵌套"></a>属性嵌套</h4><p>有一些复合属性可以使用嵌套的方式来写<br>比如border<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">border</span> : &#123;</span><br><span class="line">    color:red;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">2px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong> : border的后面必须要加上冒号</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>SCSS可以有两种风格的注释<br>一种是标准的css注释 <code>/*  */</code><br>编译会保留<br>另一种是单行注释 <code>//</code> , 编译过程不保留</p><h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3><p>Mixin有点像C语言的宏定义 , 是可以重用的代码块<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用@mixin命令,定义一个代码块</span></span><br><span class="line">@<span class="keyword">mixin</span> left &#123;</span><br><span class="line">  <span class="attribute">float</span> : left;</span><br><span class="line">  <span class="attribute">margin-left</span> : <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用@include调用这个mixin</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mixin的强大之处 , 在于可以去指定参数和缺省值<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> left(<span class="variable">$value</span>:<span class="number">10px</span>) &#123;</span><br><span class="line">  <span class="attribute">float</span> : left;</span><br><span class="line">  <span class="attribute">margin-left</span> : <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> left(<span class="number">20px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果引入的时候不传参数 , 则使用缺省值<br>实例 : 生成浏览器前缀<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> rounded(<span class="variable">$vert</span>, <span class="variable">$horz</span>, <span class="variable">$radius</span>: 10px) &#123;</span><br><span class="line">　<span class="attribute">border</span>-#&#123;<span class="variable">$vert</span>&#125;-#&#123;<span class="variable">$horz</span>&#125;-radius: <span class="variable">$radius</span>;</span><br><span class="line">　-moz-<span class="attribute">border-radius</span>-#&#123;<span class="variable">$vert</span>&#125;#&#123;<span class="variable">$horz</span>&#125;: <span class="variable">$radius</span>;</span><br><span class="line">　-webkit-<span class="attribute">border</span>-#&#123;<span class="variable">$vert</span>&#125;-#&#123;<span class="variable">$horz</span>&#125;-radius: <span class="variable">$radius</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#navbar</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> rounded(top,left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> rounded(top,left,<span class="number">5px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="颜色函数"><a href="#颜色函数" class="headerlink" title="颜色函数"></a>颜色函数</h3><p>颜色函数是基于某个颜色进行的色彩调整<br>利用这些函数 , 可以很方便完成界面上风格统一的色彩搭配<br>涉及色彩的部分 , 可以很方便修改 , 完成主题风格的切换<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$base_color</span> : chocolate;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">mixin</span> size &#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size;</span><br><span class="line">  <span class="attribute">background</span>:&#123;</span><br><span class="line">    color: darken(<span class="variable">$base_color</span>, <span class="number">10%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div2</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size;</span><br><span class="line">  <span class="attribute">background</span>:&#123;</span><br><span class="line">    color: <span class="variable">$base_color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div3</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> size;</span><br><span class="line">  <span class="attribute">background</span>:&#123;</span><br><span class="line">    color: lighten(<span class="variable">$base_color</span>, <span class="number">10%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果图<br><img src="/images/前端杂烩/color_function.png" alt="color_function"></p><p>常用的颜色函数</p><ul><li><code>darken</code> , <code>lighten</code> - 调整亮度 , 变暗/变亮</li><li><code>sturate</code> , <code>desaturate</code> - 增加/减小 饱和度</li><li><code>adjust-hue</code> - 调整 色相</li><li><code>grayscale</code> - 灰度处理</li><li><code>complement</code> - 色彩反相</li></ul><h3 id="文件引入"><a href="#文件引入" class="headerlink" title="文件引入"></a>文件引入</h3><p>使用<code>@import</code> 引入另一个样式文件 , 可以是scss文件 , 也可以是css文件<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"path/filename.scss"</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">"path/base.css"</span></span><br></pre></td></tr></table></figure></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>SASS允许一个选择器 , 继承另一个选择器<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class1</span> &#123;</span><br><span class="line">  <span class="attribute">border</span> : <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.class2</span> &#123;</span><br><span class="line">  @<span class="keyword">extend</span> .class1;</span><br><span class="line">  <span class="attribute">font-size</span> : <span class="number">120%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在编译过后 , 会生成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class1</span>, <span class="selector-class">.class2</span> &#123;</span><br><span class="line">  <span class="attribute">border </span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.class2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">120%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相比于mixin会生成很多重复的代码 , 这种方式能够对代码进行复用 , 有利于提高css解析的效率</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>使用<code>@if</code>和<code>@else</code>可以进行判断<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">if</span> lightness(<span class="variable">$color</span>) &gt; 30% &#123;</span><br><span class="line">　<span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">　<span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p>for循环<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">for</span> <span class="variable">$i</span> from 1 to 10 &#123;</span><br><span class="line">  <span class="selector-class">.border-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">border</span>: #&#123;<span class="variable">$i</span>&#125;px solid blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>while循环<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$i</span>: <span class="number">6</span>;</span><br><span class="line">@<span class="keyword">while</span> <span class="variable">$i</span> &gt; 0 &#123;</span><br><span class="line">  <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123; <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>; &#125;</span><br><span class="line">  <span class="variable">$i</span>: <span class="variable">$i</span> - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>each循环 , 类似于迭代器<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">each</span> <span class="variable">$member</span> in a, b, c, d &#123;</span><br><span class="line">  .#&#123;<span class="variable">$member</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">"/image/#&#123;$member&#125;.jpg"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/前端杂烩/each循环.png" alt="each循环"></p><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>使用<code>@function</code>可以自定义一个函数<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@function double(<span class="variable">$n</span>) &#123;</span><br><span class="line">  @return <span class="variable">$n</span> * 2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span> : double(<span class="number">5px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>附 : 知识结构梳理<br><img src="/images/前端杂烩/Sass知识结构梳理.png" alt="Sass知识结构梳理"></p>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> sass </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SASS-初见</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/SASS-%E5%88%9D%E8%A7%81/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/SASS-%E5%88%9D%E8%A7%81/</url>
      <content type="html"><![CDATA[<p>CSS本身并不算是一种编程语言 , 它没有变量 , 也没有条件语句<br>只是作为单纯的描述 , 写起来比较费事 , 同时也需要考虑很多的兼容性问题<br>很自然地 , 有人开始为CSS加入编程元素 , 这类工具就叫做<code>CSS预处理器</code><br>这类工具使用编程的风格去编写类似CSS的代码 , 然后通过工具的处理生成浏览器可以识别的CSS文件<br><a id="more"></a></p><h4 id="SASS与SCSS"><a href="#SASS与SCSS" class="headerlink" title="SASS与SCSS"></a>SASS与SCSS</h4><p>这两者其实是同一种东西 , 都可以称之为SASS</p><ul><li>文件的扩展名不同 , 分别是sass和scss</li><li>sass以严格的缩进式语法规则来编写 , 不带大括号和分号 , 而scss的语法与css的语法非常类似</li></ul><p>下面是最简单的例子 , 运用了变量的定义和调用<br>sass语法<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$font-stack</span>: Helvetica, sans-serif  //定义变量</span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span> //定义变量</span><br><span class="line"></span><br><span class="line">body</span><br><span class="line">  font: <span class="number">100%</span> <span class="variable">$font-stack</span></span><br><span class="line">  color: <span class="variable">$primary-color</span></span><br></pre></td></tr></table></figure></p><p>scss语法<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$font-stack</span>: Helvetica, sans-serif;</span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">100%</span> <span class="variable">$font-stack</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终编译出来的css都是<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">100%</span> Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="sass编译工具"><a href="#sass编译工具" class="headerlink" title="sass编译工具"></a>sass编译工具</h4><p>sass本身是类似ruby的语法的 , 使用ruby去编译sass是最直接的<br>可以使用<code>ruby -v</code> 查看是否安装ruby ( Mac系统自带 )<br>使用ruby的包管理工具<code>gem</code>安装sass模块<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install sass</span><br></pre></td></tr></table></figure></p><blockquote><p>如果需要进行卸载 , 执行 gem uninstall sass 即可</p></blockquote><p>执行<code>sass -v</code> 正常显示版本号代表安装成功<br>执行编译的操作非常简单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sass 源文件名:目标文件名</span></span><br><span class="line">$ sass test.scss:test.css</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>添加<code>--watch</code>参数可以启动一个程序监控该scss文件的变化 , 一旦发生变化则重新执行编译</li><li>添加<code>--style</code>参数可以使用不同风格的输出方式 ( 通常可以用于压缩css代码 )<br>例如<code>sass test.scss:test.css --style compressed</code><br>nested  - 嵌套输出<br>expanded - 展开输出<br>compact - 紧凑输出<br>compressed - 压缩输出</li></ul></blockquote><hr><h4 id="node-sass"><a href="#node-sass" class="headerlink" title="node-sass"></a>node-sass</h4><p>这个模块是nodejs的一个第三方模块 , 用于编译sass代码 , 为了方便 , 我们配合webpack来进行使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install node-sass sass-loader --save-dev</span><br></pre></td></tr></table></figure></p><p>为了查看编译过后的文件 , 我们需要把编译过后的css代码放入一个独立的文件当中<br>需要使用<code>extract-text-webpack-plugin</code>模块<br>这是一个webpack的插件<br>安装之后<br>在webpack.config.js当中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    entry : <span class="string">'./src/entry.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname+<span class="string">"/dist"</span>,</span><br><span class="line">    filename: <span class="string">'js/[name].bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loaders</span>: [<span class="string">"style-loader"</span>,<span class="string">"css-loader"</span>]&#125;,</span><br><span class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">loaders</span> : ExtractTextPlugin.extract(&#123;<span class="attr">fallback</span>:<span class="string">"style-loader"</span>,<span class="attr">use</span>:[<span class="string">"css-loader"</span>,<span class="string">"postcss-loader"</span>,<span class="string">"sass-loader?outputStyle=compact"</span>]&#125;)&#125;</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins : [</span><br><span class="line">  <span class="comment">//压缩打包之后的js</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">            warnings: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  <span class="comment">//写入的文件</span></span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"css/[name][contenthash].css"</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><blockquote><p>上面为sass-loader加的参数<code>outputStyle</code>作用与ruby当中的–style相同</p></blockquote><p>在src/entry.js当中引入scss文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"./style/test.scss"</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> sass </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5的缓存策略</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/HTML5%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/HTML5%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<p>HTML5当中新增了两种浏览器端的缓存方式<br>分别是<code>sessionStorage</code>和<code>localStorage</code></p><ul><li><strong>sessionStorage</strong> - 用于会话级别数据的缓存 , 这些数据只有在同一个会话中的页面才能访问 , 当会话结束后数据就会随之销毁</li><li><strong>localStorage</strong> - 用于持久化的本地存储 , 除非主动删除数据 , 否则数据是永远不会过期的<a id="more"></a>在此之前 , 本地缓存的方式主要就是cookie<br>但是cookie有很多弊端 , 比如</li><li>存储容量是受限的</li><li>每次请求一个新的页面 , cookie都会被带过去 , 浪费了带宽</li><li>无法跨域调用</li><li>明文存储 , 安全性很差</li></ul><p>当然有了web storage , 也并不能完全取代cookie , 因为cookie的作用是与服务器进行交互 , 作为HTTP规范的一部分而存在 , 而Web Storage仅仅是为了在本地存储数据而已</p><hr><p>在支持web storage的浏览器当中 , <code>sessionStorage</code>和<code>localStorage</code>都是window当中的全局对象 , 可以直接使用<br>用法都很简单<br><img src="/images/前端杂烩/localstorage.png" alt="localstorage"><br>可以直接使用继承自原型对象的这几个方法 , 添加 获取 移除 键值对 , 也可以当做普通的JS对象来使用 , 直接给对象属性赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">"name"</span>,<span class="string">"Sookie"</span>);</span><br><span class="line"><span class="comment">//或者 localStorage.name = "Sookie";</span></span><br><span class="line">localStorage.getItem(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//或者 localStorage.name;</span></span><br><span class="line">localStorage.removeItem(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//或者 delete localStorage.name</span></span><br></pre></td></tr></table></figure><p>除此之外 , <code>key()</code>方法可以获取到Storage当中指定索引的键 , 与length配合可以用于遍历所有缓存的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index=<span class="number">0</span> ; index&lt;localStorage.length ; index++) &#123;</span><br><span class="line">  <span class="keyword">let</span> key = localStorage.key(index);</span><br><span class="line">  <span class="keyword">let</span> value = localStorage.getItem(key);</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>####事件<br>浏览器提供了<code>storage</code>事件 , 用于监听<strong>localStorage</strong>的变化</p><blockquote><p>需要注意的是 , 在某一个页面设置这个事件的回调函数之后 , 在本页面对localStorage进行操作 , 是不会触发这个事件的 , 在另外一个标签中打开该页面 , 才会触发这个事件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"storage"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/images/前端杂烩/storage_event.png" alt="storage_event"></p>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实现call方法</title>
      <link href="/JavaScript/%E5%AE%9E%E7%8E%B0call%E6%96%B9%E6%B3%95/"/>
      <url>/JavaScript/%E5%AE%9E%E7%8E%B0call%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote><p>call方法在使用一个指定的this值和若干个指定参数值的前提下调用某个函数<br><a id="more"></a><br>常规调用方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name : <span class="string">"Sookie"</span>,</span><br><span class="line">  func : <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" : "</span> + msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn1 = obj.func;</span><br><span class="line">fn1.call(obj, <span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure></p></blockquote><p>现在如果要尝试实现一个call方法</p><h4 id="雏形"><a href="#雏形" class="headerlink" title="雏形"></a>雏形</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  context.fn();</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初步实现了不传参情况下的函数调用<br>但是还有不少缺陷</p><h4 id="对参数的处理"><a href="#对参数的处理" class="headerlink" title="对参数的处理"></a>对参数的处理</h4><p>由于需要处理实际参数 , 而且实际参数的数量又是不确定的<br>所以我们可以考虑使用<code>eval</code>来执行这个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span> ; i&lt;<span class="built_in">arguments</span>.length ; i++) &#123;</span><br><span class="line">    args.push(<span class="string">"arguments["</span> + i + <span class="string">"]"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">"context.fn("</span> + args + <span class="string">")"</span>);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比如实际调用函数的时候需要传入2个参数 , 包括前面的context , 所以arguments当中就有3个元素</p><p>那么就相当于执行<br>context.fn(arguments[1], arguments[2])</p><h4 id="返回值与完善"><a href="#返回值与完善" class="headerlink" title="返回值与完善"></a>返回值与完善</h4><p>还需要处理函数的返回值<br>另外 , 在我们的call方法当中 , 对上下文对象添加了fn属性 , 最后又删除了它<br>如果这个对象上原本就有这个属性 , 那么就对这个对象产生了破坏<br>可以预先把这个对象保存下来<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _fn = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">"fn"</span> <span class="keyword">in</span> context) &#123;</span><br><span class="line">    _fn = context.fn;</span><br><span class="line">  &#125;</span><br><span class="line">  _fn = context.fn;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span> ; i&lt;<span class="built_in">arguments</span>.length ; i++) &#123;</span><br><span class="line">    args.push(<span class="string">"arguments["</span> + i + <span class="string">"]"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">"context.fn("</span> + args + <span class="string">")"</span>);</span><br><span class="line">  <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">    context.fn = _fn;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> prototype </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Maven(5)-jetty-plugin</title>
      <link href="/Java/Maven(5)-jetty-plugin/"/>
      <url>/Java/Maven(5)-jetty-plugin/</url>
      <content type="html"><![CDATA[<p>与tomcat类似 , jetty也是一个servlet容器 , 为例如jsp和servlet提供运行环境</p><p>这里我们使用<code>jetty-maven-plugin</code>来部署运行一个web项目<br>关于如何把普通的maven项目改造为web项目 , 可以参考 <a href="/Java/Maven(2)-搭建web项目/">Maven(2)-搭建web项目</a><br><a id="more"></a><br>在之前 , 我们仍然需要把这个项目去发布到tomcat然后运行tomcat<br>这里使用插件来实现把jetty嵌入到项目当中</p><h4 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h4><p>首先需要在pom.xml当中配置这个插件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.4.7.RC0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">jettyXml</span>&gt;</span>jetty.xml<span class="tag">&lt;/<span class="name">jettyXml</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">webAppSourceDirectory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">webAppSourceDirectory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scanIntervalSeconds</span>&gt;</span>3<span class="tag">&lt;/<span class="name">scanIntervalSeconds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="创建jetty配置文件"><a href="#创建jetty配置文件" class="headerlink" title="创建jetty配置文件"></a>创建jetty配置文件</h4><p>上面的配置指定了jetty.xml作为jetty的配置文件<br>当然如果配置比较简单 , 也可以直接写在这个插件的<code>&lt;configuration&gt;</code>当中</p><p>jetty.xml ( 直接放在项目的根目录下 )<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE Configure PUBLIC "-//Jetty//Configure//EN" "http://www.eclipse.org/jetty/configure.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Configure</span> <span class="attr">id</span>=<span class="string">"Server"</span> <span class="attr">class</span>=<span class="string">"org.eclipse.jetty.server.Server"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Arg</span> <span class="attr">name</span>=<span class="string">"threadpool"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">New</span> <span class="attr">id</span>=<span class="string">"threadpool"</span> <span class="attr">class</span>=<span class="string">"org.eclipse.jetty.util.thread.QueuedThreadPool"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">Arg</span> <span class="attr">name</span>=<span class="string">"minThreads"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">Arg</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">Arg</span> <span class="attr">name</span>=<span class="string">"maxThreads"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span>200<span class="tag">&lt;/<span class="name">Arg</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">Arg</span> <span class="attr">name</span>=<span class="string">"idleTimeout"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span>60000<span class="tag">&lt;/<span class="name">Arg</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"detailedDump"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">New</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">Arg</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">Call</span> <span class="attr">name</span>=<span class="string">"addBean"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">Arg</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">New</span> <span class="attr">class</span>=<span class="string">"org.eclipse.jetty.util.thread.ScheduledExecutorScheduler"</span>/&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">Arg</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">Call</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">New</span> <span class="attr">id</span>=<span class="string">"httpConfig"</span> <span class="attr">class</span>=<span class="string">"org.eclipse.jetty.server.HttpConfiguration"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"secureScheme"</span>&gt;</span>https<span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"securePort"</span>&gt;</span><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"jetty.secure.port"</span> <span class="attr">default</span>=<span class="string">"8443"</span> /&gt;</span><span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"outputBufferSize"</span>&gt;</span>32768<span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"requestHeaderSize"</span>&gt;</span>8192<span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"responseHeaderSize"</span>&gt;</span>8192<span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"sendServerVersion"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"sendDateHeader"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"headerCacheSize"</span>&gt;</span>512<span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">New</span>&gt;</span>  </span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;<span class="name">Call</span> <span class="attr">name</span>=<span class="string">"addConnector"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Arg</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">New</span> <span class="attr">class</span>=<span class="string">"org.eclipse.jetty.server.ServerConnector"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">Arg</span> <span class="attr">name</span>=<span class="string">"server"</span>&gt;</span><span class="tag">&lt;<span class="name">Ref</span> <span class="attr">refid</span>=<span class="string">"Server"</span> /&gt;</span><span class="tag">&lt;/<span class="name">Arg</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">Arg</span> <span class="attr">name</span>=<span class="string">"factories"</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">Array</span> <span class="attr">type</span>=<span class="string">"org.eclipse.jetty.server.ConnectionFactory"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">Item</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">New</span> <span class="attr">class</span>=<span class="string">"org.eclipse.jetty.server.HttpConnectionFactory"</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">Arg</span> <span class="attr">name</span>=<span class="string">"config"</span>&gt;</span><span class="tag">&lt;<span class="name">Ref</span> <span class="attr">refid</span>=<span class="string">"httpConfig"</span> /&gt;</span><span class="tag">&lt;/<span class="name">Arg</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;/<span class="name">New</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">Item</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;/<span class="name">Array</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">Arg</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"host"</span>&gt;</span><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"jetty.host"</span> /&gt;</span><span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"port"</span>&gt;</span><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"jetty.port"</span> <span class="attr">default</span>=<span class="string">"8080"</span> /&gt;</span><span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"idleTimeout"</span>&gt;</span>30000<span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">New</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">Arg</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">Call</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"stopAtShutdown"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"stopTimeout"</span>&gt;</span>5000<span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"dumpAfterStart"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">"dumpBeforeStop"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">Set</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">Configure</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="启动运行"><a href="#启动运行" class="headerlink" title="启动运行"></a>启动运行</h4><p>直接在项目目录下执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn jetty:run -e</span><br></pre></td></tr></table></figure></p><p>加上<code>-e</code>参数 , 如果运行有报错会在控制台打印堆栈信息<br>之后项目启动成功 , 就可以在浏览器当中根据配置的端口访问了</p><p><img src="/images/Java/maven-jetty-plugin.png" alt="maven-jetty-plugin"></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS中的字体</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E4%B8%AD%E7%9A%84%E5%AD%97%E4%BD%93/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E4%B8%AD%E7%9A%84%E5%AD%97%E4%BD%93/</url>
      <content type="html"><![CDATA[<p>在CSS当中 , 我们通常使用<code>@font-face</code>来定义字体<br>除了可以引入外部字体之外 , 也可以给系统本地的字体定义别名<br>比如<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family </span>: YH;</span><br><span class="line">  <span class="attribute">src </span>: <span class="built_in">local</span>(<span class="string">"microsoft yahei"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.font</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>:YH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就可以在需要使用这个字体的地方直接使用这个别名<br><a id="more"></a></p><blockquote><p>通常不推荐在网页当中引入外部的中文字体包<br>因为中文字体包通常很大 , 会导致严重的加载缓慢</p></blockquote><p>然而在Mac系统当中没有微软雅黑字体 , 我们希望在Mac系统上使用苹方字体 , windows系统上使用微软雅黑字体<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family </span>: BASE;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">local</span>(<span class="string">"PingFang SC"</span>),</span><br><span class="line">    <span class="built_in">local</span>(<span class="string">"Microsoft Yahei"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样字体的应用就更加简便了</p><h3 id="unicode-range"><a href="#unicode-range" class="headerlink" title="unicode-range"></a>unicode-range</h3><p>这个属性可以给特定的字符指定特定的字体<br>通过unicode编码去指定字符<br>比如我们需要给一段文字当中的引号使用宋体 , 其他的文字使用微软雅黑或者苹方字体<br>可以这样做<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: BASE;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">local</span>(<span class="string">'PingFang SC'</span>),</span><br><span class="line">       <span class="built_in">local</span>(<span class="string">'Microsoft Yahei'</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: quote;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">local</span>(<span class="string">'SimSun'</span>);    </span><br><span class="line">  <span class="attribute">unicode-range</span>: U+<span class="number">201</span>c, U+<span class="number">201</span>d;</span><br><span class="line">  <span class="comment">/* 中文前引号与后引号对应的unicode编码 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.font</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: quote, BASE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/前端杂烩/css_font.png" alt="css_font"></p><blockquote><p>FireFox浏览器对字体名称的大小写敏感</p></blockquote><p>unicode-range的用法<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 支持的值 */</span></span><br><span class="line"><span class="selector-tag">unicode-range</span>: <span class="selector-tag">U</span>+26;               <span class="comment">/* 单个字符编码 */</span></span><br><span class="line"><span class="selector-tag">unicode-range</span>: <span class="selector-tag">U</span>+0<span class="selector-tag">-7F</span>;</span><br><span class="line"><span class="selector-tag">unicode-range</span>: <span class="selector-tag">U</span>+0025<span class="selector-tag">-00FF</span>;        <span class="comment">/* 字符编码区间 */</span></span><br><span class="line"><span class="selector-tag">unicode-range</span>: <span class="selector-tag">U</span>+4??;              <span class="comment">/* 通配符区间 */</span></span><br><span class="line"><span class="selector-tag">unicode-range</span>: <span class="selector-tag">U</span>+0025<span class="selector-tag">-00FF</span>, <span class="selector-tag">U</span>+4??; <span class="comment">/* 多个值 */</span></span><br></pre></td></tr></table></figure></p><blockquote><p><strong>前端领域的字符表示方式总结</strong></p><ol><li>HTML中字符输出使用<code>&amp;#x</code>配上charCode值</li><li>在JavaScript文件中为防止乱码转义，则是<code>\u</code>配上charCode值</li><li>在CSS文件中，如CSS伪元素的content属性，直接使用<code>\</code>配上charCode值</li><li>unicode-range是<code>U+</code>配上charCode值</li></ol></blockquote><hr><h3 id="补充-使用千位分隔符表示大数字"><a href="#补充-使用千位分隔符表示大数字" class="headerlink" title="补充 : 使用千位分隔符表示大数字"></a>补充 : <strong>使用千位分隔符表示大数字</strong></h3><p>在移动端 , 对于超过一定个数的连续数字 , 系统会默认当做电话号码来处理 , 而不是一个数字<br>点击这个数字的时候 , 可以触发系统的电话呼叫</p><p>如果我们想干掉这个特性 , 通常的做法是使用<code>&lt;meta&gt;</code>标签<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span></span></span><br></pre></td></tr></table></figure></p><p>这样就意味着本来可以进行便捷呼叫的手机号码 , 变成了一串普通的数字<br>对于确实表示数字含义的一串数字来说 ( 不是编码或者流水号之类的内容 ) , 只是这样做也是影响体验的<br>它本身也不方便进行辨识<br>我们可以考虑将其格式化为包含千位分隔符的一个字符串</p><p>处理方式</p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>用法举例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="number">123456789</span>).replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">"$1,"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="使用toLocalString-方法"><a href="#使用toLocalString-方法" class="headerlink" title="使用toLocalString()方法"></a>使用<code>toLocalString()</code>方法</h4><p>用法举例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">123456789</span>).toLocaleString(<span class="string">'en-US'</span>);</span><br></pre></td></tr></table></figure></p><p>对于中文场景下，toLocaleString(‘en-US’)中的’en-US’理论上是可以缺省的<br>但是如果产品可能海外用户使用，则保险起见，还是保留’en-US’</p><p>在这种情况下 , 如果我们想要美化这个逗号<br>使用JS进行筛选处理会十分繁琐<br>我们就可以使用<code>unicode-range</code>单独对其中的逗号进行处理</p>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Maven(4)-补充</title>
      <link href="/Java/Maven(4)-%E8%A1%A5%E5%85%85/"/>
      <url>/Java/Maven(4)-%E8%A1%A5%E5%85%85/</url>
      <content type="html"><![CDATA[<p>maven默认使用的JDK版本是1.5 , 我们可以在配置文件中<code>&lt;profiles&gt;</code>标签里加入如下内容 , 将默认JDK改为1.8<br><a id="more"></a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h4><p>不同的jar包之间可能存在相对复杂的依赖关系<br>比如A依赖于B , B依赖于C<br>那么A就是同时依赖于B和C , 这就是依赖传递</p><p>如果在A当中只是用到了B当中的部分内容 , 并不需要依赖于C<br>那么我们可以将C排除<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>B-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>C-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样就可以把对C的依赖排除</p><h4 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h4><p>由于jar包可以有不同的版本 , 所以在依赖的关系当中就可能出现依赖的冲突<br>比如A依赖于B , B依赖于C的2.0版本<br>A依赖于D , D依赖于E , E依赖于C的2.1版本<br>那么在A当中实际引入的C , 就会出现冲突</p><p>maven在处理这种冲突的时候 , 有以下的原则</p><ol><li><strong>最短路径优先</strong> - 也就是在依赖链当中到达该jar包的最短路径 , 比如在上面的例子当中 , 显然到达C的2.0版本的路径较短 , 所以A最终引入的就是C的2.0版本</li><li><strong>先声明的优先</strong> - 在路径长度相同的情况下 , 根据在pom.xml当中声明的先后顺序 , 优先使用先声明的</li></ol><h4 id="变量的声明与使用"><a href="#变量的声明与使用" class="headerlink" title="变量的声明与使用"></a>变量的声明与使用</h4><p>对于一个框架 , 比如spring , 要在项目当中使用需要添加多个依赖包<br>我们需要对这些依赖包指定统一的版本 , 避免版本不一致出现的问题</p><p>这种情况下可以在pom.xml当中声明一个公共的变量<br>比如<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spring-version</span>&gt;</span>4.3.11.RELEASE<span class="tag">&lt;/<span class="name">spring-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样就更加清晰 , 也为统一的修改创造了方便</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Maven(3)-从入门到重新入门</title>
      <link href="/Java/Maven(3)-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8/"/>
      <url>/Java/Maven(3)-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%87%8D%E6%96%B0%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p><code>Maven</code>是基于项目对象模型 ( POM ) , 可以通过描述信息来管理项目的构建 报告 和文档的软件项目管理工具</p><p>简而言之 , 使用maven可以帮助我们更高效地管理项目<br>它也是一套强大的构建工具 , 覆盖了编译 测试 运行 清理 打包部署各项构建周期<br><a id="more"></a></p><h4 id="修改maven的配置"><a href="#修改maven的配置" class="headerlink" title="修改maven的配置"></a>修改maven的配置</h4><p>在maven根目录/conf/setting.xml当中 , 可以修改maven的配置<br>可以修改本地仓库所在位置 , 比如<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span></span><br><span class="line">/Users/Sookie/Documents/maven_lib</span><br><span class="line"><span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>由于官方的远程仓库位于国外 , 在国内的访问速度比较捉急<br>所以也可以配置一个国内的镜像地址<br>比如在<code>&lt;mirrors&gt;</code>节点当中添加阿里云的maven镜像<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="创建符合maven项目目录结构的项目"><a href="#创建符合maven项目目录结构的项目" class="headerlink" title="创建符合maven项目目录结构的项目"></a>创建符合maven项目目录结构的项目</h4><p>这里需要用到<code>archetype</code>这个插件<br>执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate</span><br></pre></td></tr></table></figure></p><p>来构建一个新的maven项目<br>执行过程中需要指定archetype的版本 , 使用默认即可<br>然后输入该项目的groupId , artifactId 等内容</p><h4 id="maven的常用命令"><a href="#maven的常用命令" class="headerlink" title="maven的常用命令"></a>maven的常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除项目中的target目录</span></span><br><span class="line">mvn clean</span><br><span class="line"></span><br><span class="line"><span class="comment">#项目编译</span></span><br><span class="line">mvn compile</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行所有测试用例</span></span><br><span class="line">mvn <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#打包项目</span></span><br><span class="line">mvn package</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装jar包到本地仓库</span></span><br><span class="line">mvn install</span><br></pre></td></tr></table></figure><p>安装到本地仓库就意味着其他的项目可以引入这个jar包</p><h4 id="maven的生命周期"><a href="#maven的生命周期" class="headerlink" title="maven的生命周期"></a>maven的生命周期</h4><p>上面提到的几个常用命令 , 其实就是maven的几个生命周期<br>clean compile test package install<br>后面的4个统称为<strong>default</strong> , 也叫项目构建的阶段</p><p>之所以称之为生命周期 , 是因为在执行后面的操作的时候 , 也会自动执行前面的操作<br>比如执行<code>mvn package</code> , 那么在进行打包之前 , 也会先进行compile和test ( 默认不会进行clean , 如果需要先清理 , 那么可以执行 <code>mvn clean package</code> ) </p><h4 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h4><p>maven提供了可扩展的插件机制 , 除了官方提供的插件之外 , 还有很多第三方开发的插件</p><p>这里使用一个官方提供的<code>source</code>插件作为示例<br>使用这个插件可以把项目的源码进行打包</p><p>配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>打包输出的绝对路径<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>文件名<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">attach</span>&gt;</span>false<span class="tag">&lt;/<span class="name">attach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>说明 : 最终输出的文件名是<code>文件名-source.jar</code><br>执行源码打包的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打包项目源码包(main目录当中的所有内容)</span></span><br><span class="line">mvn <span class="built_in">source</span>:jar</span><br><span class="line"></span><br><span class="line"><span class="comment">#打包测试源码包(test目录当中的所有内容)</span></span><br><span class="line">mvn <span class="built_in">source</span>:<span class="built_in">test</span>-jar</span><br></pre></td></tr></table></figure><h5 id="将插件绑定到maven的生命周期"><a href="#将插件绑定到maven的生命周期" class="headerlink" title="将插件绑定到maven的生命周期"></a>将插件绑定到maven的生命周期</h5><p>在插件的配置当中加入对maven生命周期的绑定<br>比如说绑定到package生命周期<br>那么在执行到该生命周期的时候 , 就会对源码进行打包<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实现bind方法</title>
      <link href="/JavaScript/%E5%AE%9E%E7%8E%B0bind%E6%96%B9%E6%B3%95/"/>
      <url>/JavaScript/%E5%AE%9E%E7%8E%B0bind%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>bind方法来自于<code>Function.prototype</code><br>这个方法会创建一个新函数 , 当这个函数被调用时 , 第一个参数将会作为它运行时的this , 之后的参数会作为实际调用时传递的实参前作为实参<br><a id="more"></a><br>语法</p><pre>func.bind(thisArg [,arg1[,arg2[, ...]]])</pre>**应用示例 :** <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name : <span class="string">"Sookie"</span>,</span><br><span class="line">  show : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _show = obj.show.bind(obj,<span class="string">"aa"</span>,<span class="string">"bb"</span>);</span><br><span class="line">_show(<span class="string">"cc"</span>);</span><br><span class="line"><span class="comment">/*output:</span></span><br><span class="line"><span class="comment">Sookie</span></span><br><span class="line"><span class="comment">&#123; '0': 'aa', '1': 'bb', '2': 'cc' &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>如果要实现一个bind方法 , 需要用到柯里化<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> me = <span class="keyword">this</span>;<span class="comment">//调用bind的函数对象</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);<span class="comment">//传入的固定实参</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//实际调用时传入的参数</span></span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">//合并两个参数数组</span></span><br><span class="line">    <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">    <span class="comment">//调用该函数</span></span><br><span class="line">    <span class="keyword">return</span> me.apply(context, finalArgs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这里解释一下 , arguments并不是数组对象 , 而是**类数组**+ 具有 : 指向对象元素的数字索引 , 以及length属性+ 不具有 : push , slice等数组对象的方法> 数组对象的\_\_proto\_\_是Array而arguments的 \_\_proto\_\_是Object如果要把一个arguments转化为一个数组对象 , 可以使用如下方式<pre>var args = Array.prototype.slice.call(arguments);</pre><h4 id="嗅探"><a href="#嗅探" class="headerlink" title="嗅探"></a>嗅探</h4><p>在运行时如果对标准库当中的内容有修改<br>( 可能是出于兼容性的需要 , 比如旧版本的标准库当中无此函数 )<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这属于一个加分项<br>由于标准库当中的函数多是经过了深度优化的<br>一般要比我们自己写的函数效率更高 更健壮<br>所以如果标准库中存在 , 其实没有必要用我们自己写的方法去替换<br>这里就是进行<code>嗅探</code></p><blockquote><p>这是一个典型的 <code>Monkey patch(猴子补丁)</code><br>主要有以下几个用处</p><ul><li>在运行时替换方法 属性等</li><li>在不修改第三方代码的情况下增加原来不支持的功能</li><li>在运行时为内存中的对象增加patch而不是在磁盘的源代码中增加</li></ul></blockquote><h4 id="更严谨的做法"><a href="#更严谨的做法" class="headerlink" title="更严谨的做法"></a>更严谨的做法</h4><p>由于需要调用bind方法的一定是一个函数 , 所以有必要在bind的内部做一个校验<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"what is trying to be bound is not callable"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> prototype </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>变量的定义提升</title>
      <link href="/JavaScript/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E6%8F%90%E5%8D%87/"/>
      <url>/JavaScript/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E6%8F%90%E5%8D%87/</url>
      <content type="html"><![CDATA[<p>从一道笔试题说起<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log (<span class="number">1</span>); &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log (<span class="number">2</span>);&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log (<span class="number">3</span>);&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log (<span class="number">4</span>);&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log (<span class="number">5</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line">Foo.getName();</span><br><span class="line">getName();</span><br><span class="line">Foo().getName();</span><br><span class="line">getName();</span><br><span class="line"><span class="keyword">new</span> Foo.getName();</span><br><span class="line"><span class="keyword">new</span> Foo().getName();</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h4><p>Foo是一个函数对象 , <code>Foo.getName = …</code>在其中定义了一个名为getName的属性 , 也是一个函数<br>所以第一问当中的调用输出的应该是2</p><h4 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h4><p>这里涉及到了变量的定义提升问题 , 如果不了解容易误认为答案是5<br>例如如下语句<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span> <span class="keyword">in</span> <span class="built_in">window</span>);</span><br><span class="line"><span class="keyword">var</span> x;</span><br></pre></td></tr></table></figure></p><p>虽然变量的定义是在第二个语句 , 但是输出的结果仍然是true<br>因为代码执行时 JS引擎会把变量的声明语句提升到最上方<br>但是提升的仅仅是变量声明 , 如果声明变量的时候包含初始化<br>则会将初始化作为单纯的一条赋值语句保留在原处<br>例如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span> <span class="keyword">in</span> <span class="built_in">window</span>);</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p><p>在JS引擎处理之后会改变为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span> <span class="keyword">in</span> <span class="built_in">window</span>);</span><br><span class="line">x = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p><blockquote><p>补充说明 : 只有显式的变量定义才会被提升<br>隐式的变量定义并不会<br>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;x&quot; in window);//false</span><br><span class="line">x = 10;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>输出就是false , 因为x未定义</p></blockquote><p>全局函数的定义与全局变量的定义本质是一样的<br>所以它也会被提升到顶部<br>但是 <code>var x = function(){}</code>与<code>function x(){}</code>两种定义方式最终效果相同<br>执行过程却是不同的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">//function x()&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">//function x()&#123;&#125;</span></span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">//function x()&#123;&#125;</span></span><br></pre></td></tr></table></figure></p><p>那么具体到这个题目<br>代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log (<span class="number">4</span>);&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log (<span class="number">5</span>);&#125;</span><br></pre></td></tr></table></figure></p><p>会被JS引擎在解析时修改为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log (<span class="number">5</span>);&#125;</span><br><span class="line">getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log (<span class="number">4</span>);&#125;;</span><br></pre></td></tr></table></figure></p><p>显然 , 第三行的赋值会将第二行的定义覆盖掉<br>最终这个全局的getName函数输出的值是4</p><h4 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h4><p>Foo() 是在全局的基础上调用的 , 也就是由window对象调用的<br>所以return this返回的是window对象<br>但是在这个函数的内部 , 修改了全局的getName的值<br>现在名为getName的全局函数输出是1了<br>所以再调用window.getName() 的输出当然是1</p><h4 id="第四问"><a href="#第四问" class="headerlink" title="第四问"></a>第四问</h4><p>同样是调用全局的getName函数 , 所以结果和第三问一样 , 也是1</p><h4 id="第五问"><a href="#第五问" class="headerlink" title="第五问"></a>第五问</h4><p>成员访问的点号( . )优先级高于 new , 所以结果与第一问相同 , 也是2</p><h4 id="第六问"><a href="#第六问" class="headerlink" title="第六问"></a>第六问</h4><p>括号运算符的优先级高于点号( . )<br>实际执行为 <code>( new Foo( ) ).getName()</code><br>所以调用的是原型对象上的getName函数 , 输出是3</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>函数形参与arguments</title>
      <link href="/JavaScript/%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E4%B8%8Earguments/"/>
      <url>/JavaScript/%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E4%B8%8Earguments/</url>
      <content type="html"><![CDATA[<p>在之前我们知道 , 在JS当中函数的形参与调用时传入的实参并不需要必须对应<br>在函数的内部有一个对象<code>arguments</code> , 这是一个类数组 , 其中包含调用时传入的实参<br>当然函数在调用的时候 , 会按照形参的位置给形参赋值<br><a id="more"></a><br>但是如果我们在函数内部对形参进行赋值 , 或者对arguments当中的元素进行赋值 , 会出现怎样的情况呢</p><p>这在一般模式和严格模式下会有不同的行为</p><h3 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h3><p>调用时对于没有对应到实参的形参进行赋值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">arg0, arg1</span>) </span>&#123;</span><br><span class="line">  arg1 = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(arg1, <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">func1(<span class="number">19</span>);<span class="comment">// 10 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params">arg0, arg1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(arg1, <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">func2(<span class="number">21</span>);<span class="comment">// undefined 10</span></span><br></pre></td></tr></table></figure></p><p>上面两个函数都有两个形参 , 实际调用时传入了一个实参 , <strong>arg1</strong>是没有与实参对应的<br>这时候对形参赋值 , 或者对arguments当中对应的元素赋值 , 各自的行为都是<strong>独立</strong>的 , 彼此不会产生影响</p><p>形参与实参有对应的情况<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">arg0</span>) </span>&#123;</span><br><span class="line">  arg0 = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(arg0, <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">func1(<span class="number">19</span>);<span class="comment">// 10 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params">arg0</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(arg0, <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">func2(<span class="number">21</span>);<span class="comment">// 10 10</span></span><br></pre></td></tr></table></figure></p><p>可以看到 , 在这种情况下 , 形参与arguments当中的元素是双向绑定的 , 修改一个会自动影响另一个</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>在严格模式下同样执行与上面类似的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">arg0</span>) </span>&#123;</span><br><span class="line">  arg0 = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(arg0, <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">func1(<span class="number">19</span>);<span class="comment">// 10 19</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params">arg0</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(arg0, <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">func2(<span class="number">21</span>);<span class="comment">// 21 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func3</span>(<span class="params">arg0</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(arg0, <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">func3();<span class="comment">// undefined 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func4</span>(<span class="params">arg0</span>) </span>&#123;</span><br><span class="line">  arg0 = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(arg0, <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">func4();<span class="comment">// 10 undefined</span></span><br></pre></td></tr></table></figure></p><p>可见严格模式之下 , 无论是哪种情况 , arguments与形参都是独立的 , 不会进行绑定 , 之间互不影响</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS动画(3)-animation</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%8A%A8%E7%94%BB(3)-animation/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%8A%A8%E7%94%BB(3)-animation/</url>
      <content type="html"><![CDATA[<p>使用上一节提到的transition已经可以实现相对简单的一些动画效果<br>但是对于相对复杂一些的效果 , 尤其是其中需要分为多个阶段的 , 就难以实现<br>CSS3的animation属性 , 就提供了更加强大的动画设计功能<br><a id="more"></a></p><h4 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h4><p>这个词的意思是<code>关键帧</code><br>与flash当中的动画制作一样 , 要设计一个完整的动画 , 需要定义其中的几个关键节点的样式<br>再去自动产生这些节点之间的平滑过渡效果</p><p>CSS当中以动画开始的点为<code>0%</code> , 以动画结束的点为<code>100%</code><br>我们可以尝试去定义一组关键帧<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> ANI &#123; <span class="comment">/*指定该组关键帧的名称*/</span></span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">width </span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#629411</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">width </span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: darkgoldenrod;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">width </span>: <span class="number">250px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>0% 也可以写作 <code>from</code><br>100% 也可以写作 <code>to</code><br>定义之后我们就可以在DOM元素上调用这组关键帧 , 用来创建动画了<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.animation_div</span> &#123;</span><br><span class="line">  <span class="comment">/* 就是之前定义的关键帧名称 */</span></span><br><span class="line">  <span class="attribute">animation-name </span>: ANI;</span><br><span class="line">  <span class="comment">/* 动画持续的时间 */</span></span><br><span class="line">  <span class="attribute">animation-duration </span>: <span class="number">5s</span>;</span><br><span class="line">  <span class="comment">/* 和transition-timing-function一样 */</span></span><br><span class="line">  <span class="attribute">animation-timing-function </span>: ease-in-out;</span><br><span class="line">  <span class="comment">/* 动画延迟时间 */</span></span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">0.5s</span>;</span><br><span class="line">  <span class="comment">/* 定义循环次数，infinite为无限次 */</span></span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="comment">/* 动画执行的方向 */</span></span><br><span class="line">  <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">  <span class="comment">/* 当前动画正在播放(running)或者暂停(paused) */</span></span><br><span class="line">  <span class="attribute">animation-play-state </span>: running;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然动画效果也可以放在<code>:hover</code>等伪类当中 , 以创建响应式的效果<br>前面几项都没什么特别的 , 最后两个属性简单说明一下</p><h4 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h4><p>可以取以下几个值</p><ul><li><strong>normal</strong><br>每次都正向运行动画，这是默认属性。</li><li><strong>alternate</strong><br>动画交替反向运行，反向运行时，动画按步后退，同时，带时间功能的函数也反向，比如，ease-in 在反向时成为ease-out。<br>反向动画同样计入次数<br>例如次数指定为3 , 那么实际就是正向1次 -&gt; 反向1次 -&gt; 正向1次</li><li><strong>reverse</strong><br>每次都反向运行动画</li><li><strong>alternate-reverse</strong><br>与alternate的区别是 : 首次是反向动画</li></ul><h4 id="animation-play-state"><a href="#animation-play-state" class="headerlink" title="animation-play-state"></a>animation-play-state</h4><p>控制当前元素上的动画播放与暂停<br>暂停之后会定格在当前播放的进度上 , 类似于播放器的暂停<br>我们可以使用一些伪类 , 或者是JS来控制这个属性 , 从而改变动画的播放状态<br>比如<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.animation_div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation-play-state </span>: paused;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样可以实现指向该元素的时候暂停动画的播放</p><blockquote><p><strong>补充说明</strong></p><ol><li>由于每个元素上都可以包含多个动画 , 所以上述的每个属性的取值都可以是单值或者多值</li><li>可以使用animation这个复合属性来涵盖上面的这些单属性<br><img src="/images/前端杂烩/animation/animation-pro.png" alt="animation属性"></li></ol></blockquote>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS动画(2)-transition</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%8A%A8%E7%94%BB(2)-transition/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%8A%A8%E7%94%BB(2)-transition/</url>
      <content type="html"><![CDATA[<p>CSS的<code>transition</code>允许CSS的属性值在一定的时间区间内平滑地过渡<br>这种效果可以在鼠标点击 获得焦点 或对元素的任何改变中触发<br>并圆滑的以动画效果改变CSS的属性值<br><a id="more"></a><br><strong>语法</strong><br>transition本身也是一个复合属性 , 主要包含4个属性值</p><ol><li>执行变换的属性 <code>transition-property</code></li><li>变换延续的时间 <code>transition-duration</code></li><li>在变换时间内 , 变换的速率变化 <code>transition-timing-function</code></li><li>变换的延迟时间 <code>transition-delay</code></li></ol><p>对于多组值 , 它们之间使用逗号分隔</p><h4 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a>transition-property</h4><p>用来指定哪个CSS属性在变换的过程中应用动画效果<br>可以取值 <code>none</code> , <code>all</code> 或者具体的属性名称<br>all代表任何可以实现动画变换的属性 , 在变换时都会应用动画效果 , 它是默认值</p><h4 id="transition-duration"><a href="#transition-duration" class="headerlink" title="transition-duration"></a>transition-duration</h4><p>用于指定元素转换过程的持续时间 , 单位可以是<code>s</code>或者<code>ms</code><br>例如 0.5s , 或者也可以写作 .5s<br>默认值为0</p><h4 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h4><p>这个属性值的本身是一个<strong>贝塞尔曲线</strong><br>有几个预定义的值 , 或者也可以自定义一个曲线<br><img src="/images/前端杂烩/animation/cubic-bezier.png" alt="cubic bezier"><br>如图所示 , 起点和终点也就是P<sub>0</sub>和P<sub>3</sub>的位置是固定的<br>只需要指定P<sub>1</sub>和P<sub>2</sub>的坐标 , 即可决定该曲线的曲率变化<br>曲线上每个点的切线斜率代表在该时间点的变换速率</p><p>P<sub>1</sub>(x1,y1)<br>P<sub>2</sub>(x2,y2)<br>所以自定义贝塞尔曲线的方式就是 <code>cubic-bezier(x1,y1,x2,y2)</code><br>当然x的值需要在[0,1]的区间内 , 否则无效<br>y的值可以超过1或者小于0 , 比如构造一个来回的缓冲效果</p><p><img src="/images/前端杂烩/animation/bezier.png" alt="贝塞尔曲线"></p><p>预定义的贝塞尔曲线</p><ol><li><strong>ease</strong>：（逐渐变慢）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0).</li><li><strong>linear</strong>：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0).</li><li><strong>ease-in</strong>：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0).</li><li><strong>ease-out</strong>：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0).</li><li><strong>ease-in-out</strong>：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)</li></ol><h4 id="transition-delay"><a href="#transition-delay" class="headerlink" title="transition-delay"></a>transition-delay</h4><p>指定一个动画开始的延迟时间 , 默认为0</p><blockquote><p>补充说明 :<br>在transition当中 , 这4个单属性值其中的每个都是可以省略的<br>但通常不会省略持续时间 , 因为省略之后就看不到动画的效果了</p></blockquote><hr><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>为了兼容旧版本的浏览器 , 我们通常需要给transition属性加上前缀<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box</span> &#123;</span><br><span class="line">  <span class="attribute">-moz-transition</span>:color <span class="number">0.5s</span> ease-in;</span><br><span class="line">  <span class="attribute">-webkit-transition</span>:color <span class="number">0.5s</span> ease-in;</span><br><span class="line">  <span class="attribute">-o-transition</span>:color <span class="number">0.5s</span> ease-in;</span><br><span class="line">  <span class="attribute">transition </span>: color <span class="number">0.5s</span> ease-in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者也可以使用<strong>postcss</strong>这种预处理工具 , 来自动添加属性的前缀</p>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS动画(1)-transform</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%8A%A8%E7%94%BB(1)-transform/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%8A%A8%E7%94%BB(1)-transform/</url>
      <content type="html"><![CDATA[<p>CSS3当中与动画有关的属性有 : </p><ul><li>transform - 变形</li><li>transition - 转换</li><li>animation - 动画<a id="more"></a><blockquote><p><strong>准备知识 :</strong><br>网页中对于元素所定义的坐标系<br>通常所关注的网页是一个平面<br>所以有X轴和Y轴<br>X轴是水平的 , 向右为正方向<br>Y轴是竖直的 , 向下为正方向<br>但是在元素动画相关的属性当中 , 存在3D变换<br>所以还需要一个Z轴<br>这个Z轴是垂直于平面 , 向外为正方向<br><img src="/images/前端杂烩/animation/3d_axes.png" alt="3d_axes"><br>z-index属性值大小影响元素在Z轴方向上的排布与此同理</p></blockquote></li></ul><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><blockquote><p>该属性只对block级元素生效</p></blockquote><p>语法格式</p><p><pre><br>transform:  &lt;transform-function&gt; [&lt;transform-function&gt;]* | none<br></pre><br>也就是说这个属性对应的值可以是none , 代表不进行任何变形<br>也可以使用一个或多个<strong>变形函数</strong><br>多个函数之间是以<strong>空格</strong>进行分割<br>函数有以下几类 ( 每一类都有若干个分功能的函数 , 类似于margin与margin-top的关系 )</p><ul><li>translate - 转换</li><li>rotate - 旋转</li><li>scale - 缩放</li><li>skew - 倾斜</li></ul><h4 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate - 旋转"></a>rotate - 旋转</h4><p>直接使用同名的函数表示2D旋转<br>参数是旋转的角度<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.rotate_div</span> &#123;</span><br><span class="line">  <span class="attribute">transform </span>: <span class="built_in">rotate</span>(30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/前端杂烩/animation/rotate.png" alt="rotate"></p><p>deg是旋转的角度 , 正数表示顺时针旋转 , 负数表示逆时针旋转<br>也可以使用<code>trun</code>作为单位 , 表示一周 , 比如0.25turn实际就是90度</p><ul><li>rotateX - 绕X轴旋转 ( 视觉效果上会在竖直方向上压缩 )</li><li>rotateY - 绕Y轴旋转 ( 视觉效果上会在水平方向上压缩 )</li><li>rotateZ - 绕Z轴旋转 , 实际上rotate本身执行的就是绕Z轴旋转</li></ul><h4 id="translate-移动"><a href="#translate-移动" class="headerlink" title="translate - 移动"></a>translate - 移动</h4><p>同名函数接受2个参数 , 分别表示在X轴和Y轴上的移动距离 , 正数代表向该轴的正方向移动 , 负数代表向负方向移动<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.translate_div</span> &#123;</span><br><span class="line">  <span class="attribute">tranform </span>: <span class="built_in">translate</span>(100px, 20px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/前端杂烩/animation/translate-x-y.png" alt="translate-x-y"></p><ul><li>translateX - 在X轴方向移动</li><li>translateY - 在Y轴方向移动</li><li>translateZ - 在Z轴方向移动<br>( 父元素需要有perspective属性的设置才能生效 这个属性代表透视点在Z轴上的位置 )</li></ul><h4 id="scale-缩放"><a href="#scale-缩放" class="headerlink" title="scale - 缩放"></a>scale - 缩放</h4><p>同名函数接受两个参数 , 分别表示在X轴和Y轴上的缩放比例 , 大于1是放大 , 小于1是缩小<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scale_div</span> &#123;</span><br><span class="line">  <span class="attribute">transform </span>: <span class="built_in">scale</span>(2, 1.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/前端杂烩/animation/scale-x-y.png" alt="scale-x-y"></p><ul><li>scaleX - 在X轴方向缩放</li><li>scaleY - 在Y轴方向缩放</li><li>scaleZ - 在Z轴方向缩放 ( 当然需要其他的效果 , 比如绕X轴旋转 , 使元素在Z轴方向上有一定的纵深 , 才会有效果 )</li><li>scale3d - 包含3个参数 , 分别是在XYZ轴上的缩放比例</li></ul><h4 id="skew-倾斜"><a href="#skew-倾斜" class="headerlink" title="skew - 倾斜"></a>skew - 倾斜</h4><p>同名函数可以提供1或者2个参数 , 如果只提供1个参数 , 代表在X轴方向的倾斜角度<br>如果提供两个参数 , 分别代表在X轴和Y轴方向的倾斜角度<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.skew_div</span> &#123;</span><br><span class="line">  <span class="attribute">transform </span>: <span class="built_in">skew</span>(30deg, 10deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/前端杂烩/animation/skew-x-y.png" alt="skew-x-y"></p><p>同样有 skewX 与 skewY , 与上面的几个函数类似 , 不过没有Z轴方向的</p><blockquote><p>旋转与倾斜 , 都与元素的基点有关系 , 默认情况下这个基点位于元素的中心<br>可以使用<code>transform-origin</code>属性来改变该元素的基点<br>这个属性的值可以是1~3个 , 可以使用长度值 百分比 关键字( 如top left等 )</p></blockquote>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Maven(2)-搭建web项目</title>
      <link href="/Java/Maven(2)-%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE/"/>
      <url>/Java/Maven(2)-%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<p>在Maven当中创建一个web项目的步骤如下<br><a id="more"></a></p><h5 id="1-新建maven项目"><a href="#1-新建maven项目" class="headerlink" title="(1) 新建maven项目"></a>(1) 新建maven项目</h5><p>打包方式选择<code>war</code><br><img src="/images/Java/maven_web1.png" alt="Alt text"></p><h5 id="2-设置项目属性"><a href="#2-设置项目属性" class="headerlink" title="(2) 设置项目属性"></a>(2) 设置项目属性</h5><p><img src="/images/Java/maven_web2.png" alt="Alt text"><br>点击上图中箭头所指链接</p><p><img src="/images/Java/maven_web3.png" alt="Alt text"><br>将webapp作为web项目的根目录<br><img src="/images/Java/maven_web4.png" alt="Alt text"></p><blockquote><p>此时webapp下面就已经生成了web项目的基本结构<br><img src="/images/Java/maven_web5.png" alt="Alt text"></p></blockquote><h5 id="3-修改发布规则"><a href="#3-修改发布规则" class="headerlink" title="(3) 修改发布规则"></a>(3) 修改发布规则</h5><blockquote><p>由于web项目需要发布到tomcat运行<br>所以需要指定发布的规则 , 也就是把哪个目录下的文件发布到tomcat当中</p></blockquote><p>项目属性 -&gt; Deployment Assembly<br><img src="/images/Java/maven_web6.png" alt="Alt text"><br>表示将webapp目录下的文件发布到tomcat中对应项目文件夹的根目录下<br>将maven引入的jar包发布到WEB-INF/lib目录下</p><blockquote><p>这里可以将两个 test 源码文件夹去掉 , 单元测试代码可以不需要发布</p></blockquote>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自增的线程安全问题</title>
      <link href="/Java/%E8%87%AA%E5%A2%9E%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/Java/%E8%87%AA%E5%A2%9E%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>Java中的 <code>i++</code> 操作也是有可能存在线程安全问题的<br>如果i是方法内的局部变量 , 则一定是线程安全 , 因为每个方法栈是线程私有的<br>若i是多个线程可见的变量 , 则存在线程安全问题<br><a id="more"></a><br>原因 : 这个操作不是原子性操作 , 在内存中的执行是分为3步的 , <code>读值</code> -&gt; <code>+1</code> -&gt; <code>写值</code><br>在这3步之间都可能会有CPU调度产生 , 造成值被修改 , 造成脏读脏写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">    num ++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Thread&gt; thList = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//由于自增操作的运算速度要远快于创建和启动线程</span></span><br><span class="line">          <span class="comment">//执行一个等待去保证所有的子线程都构造完成以后再执行自增操作</span></span><br><span class="line">          Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        cnt();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.start();</span><br><span class="line">    thList.add(thread);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//判断是否所有子线程都已结束</span></span><br><span class="line">    <span class="keyword">for</span>(Thread thread : thList) &#123;</span><br><span class="line">      flag = flag &amp;&amp; !thread.isAlive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果多数情况都不是1000 , 虽然num++确实被执行了1000次<br>这就是不同线程之间的脏读和脏写造成的</p><hr><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>这是Java当中的一个关键字 , 它的作用概括来说有两点 : <code>可见性</code> 和 <code>有序性</code></p><ul><li><p><strong>可见性 :</strong> 当一个线程修改了这个变量的值以后 , 其他线程在尝试读取这个值的时候看到的一定是新值<br>因为运算的操作只有在CPU当中才能执行 , 使用volatile修饰的变量在执行修改以后会立即写入内存 , 而其他线程需要读取值的时候也一定会直接去内存当中读取<br>反映到硬件层的话 , 就是cpu中的缓存无效</p><blockquote><p>从上面的例子来说就是 <strong>+1</strong> 和 <strong>写值</strong>两个操作之间不会被其他线程中断</p></blockquote></li><li><p><strong>有序性 : </strong>禁止进行指令重排序<br>比如如下代码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;<span class="comment">//语句1</span></span><br><span class="line">falg = <span class="keyword">true</span>;<span class="comment">//语句2</span></span><br></pre></td></tr></table></figure></li></ul><p>在这种情况下 , 并不能保证语句1一定在语句2之前执行 , 可能会发生指令重排序<br>处理器为了提高程序运行效率 , 可能会对输入代码进行优化<br>当然这种优化的前提是优化以后程序的执行结果和按照代码顺序执行的结果是一致的<br>显然上述代码当中先执行语句1还是语句2都是没问题的( 语句2并不依赖语句1的执行结果 ) , 最终结果也没有差别</p><p>在单线程中 , 我们通常不会去关注这个问题 , 因为不会对程序的正常执行造成任何影响 , 但是多线程就不同了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程A</span></span><br><span class="line">context = loadContext();<span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;<span class="comment">//语句2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程B</span></span><br><span class="line"><span class="keyword">while</span>(!inited) &#123;</span><br><span class="line">  sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomething(context);</span><br></pre></td></tr></table></figure></p><p>如果只看线程A , 那么语句1和语句2的执行先后并没有什么差别<br>但是如果线程A真的先执行了语句2 , 然后cpu调度切换到了线程B , 那么doSomething就会报错 , 因为此时context还没有被初始化</p><blockquote><p>指令重排序不会影响单线程的执行 , 但是会影响到线程并发执行的正确性</p></blockquote><p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”<br>     ——摘自&lt;深入理解Java虚拟机&gt;</p><p>　　lock前缀指令实际上相当于一个内存屏障（也称内存栅栏），内存屏障会提供3个功能：<br>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>　　2）它会强制将对缓存的修改操作立即写入主存；<br>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><hr><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>如果一个操作是原子性的 , 就代表它是不可分割的 , 无法被其他线程中断介入的<br>可以与事务类比</p><p>在Java当中 , 对<strong>基本数据类型变量</strong>的<code>读取</code>和<code>赋值</code>是原子性操作<br>但是表现在代码当中 , 是十分不易区分的<br>例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;<span class="comment">//语句1</span></span><br><span class="line">y = x;<span class="comment">//语句2</span></span><br><span class="line">x++;<span class="comment">//语句3</span></span><br><span class="line">x = x+<span class="number">1</span>;<span class="comment">//语句4</span></span><br></pre></td></tr></table></figure></p><p>在上述的4个语句当中 , 其实只有语句1是原子性的操作<br>语句2包含读取x的值和赋值给y两个操作<br>3和4则包含读取值 , 进行运算 , 赋值操作</p><p>根据上述<code>volatile</code>的作用 , 可见volatile并<strong>不能</strong>保证原子性<br>对于开始的程序 , 即使用volatile修饰num , 最终结果也可能不是1000</p><hr><h4 id="Java中的锁机制"><a href="#Java中的锁机制" class="headerlink" title="Java中的锁机制"></a>Java中的锁机制</h4><p>运用synchronized或者ReentrantLock都可以解决这个问题</p><ul><li><p>使用synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">      num ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ReentrantLock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock objLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">    objLock.lock();</span><br><span class="line">    num ++;</span><br><span class="line">    objLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><p>这个类的实例表示可以用原子方式更新的int值<br>调用这个类中的可用方法进行自增操作 , 可以保证线程安全<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">    num.getAndIncrement();<span class="comment">//以原子方式获取并且自增1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>传统的锁机制需要陷入内核态，造成上下文切换，但是一般持有锁的时间很短，频繁的陷入内核开销太大，所以随着机器硬件支持CAS后，JAVA推出基于compare and set机制的AtomicInteger，实际上就是一个CPU循环忙等待。因为持有锁时间一般较短，所以大部分情况CAS比锁性能更优。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Maven(1)-初见</title>
      <link href="/Java/Maven(1)-%E5%88%9D%E8%A7%81/"/>
      <url>/Java/Maven(1)-%E5%88%9D%E8%A7%81/</url>
      <content type="html"><![CDATA[<p>我们在工作中可能会在IDE当中有很多项目<br>这些项目多数需要引用一些第三方的jar包<br>但是对于相同类型的项目 , 引用的jar包很可能是重复的</p><p>在以往 , 我们需要在每个项目中都拷贝一份这些jar包 , 以保证这些项目可以独立运行 , 这样显然不好<br>而且对于同一个jar包来说 , 它也会存在不同的版本 , 缺乏统一的管理<br><a id="more"></a><br>对于较为复杂的项目 , 可能会有主项目和若干个子项目 , 他们之间的依赖关系也难以维护</p><p><code>Maven</code>就是用来解决项目管理中遇到的这些问题<br>它引入了<code>仓库</code>的概念 , 实现了对jar包的统一管理</p><h4 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h4><ol><li>解压存放到一个固定的目录当中<br>然后配置环境变量 , 例如<br><code>MAVEN_HOME=D:/maven-3.3.9</code><br>在PATH当中添加<br><code>%MAVEN_HOME%/bin</code><blockquote><p>Mac平台直接修改 .bash_profile文件</p></blockquote></li></ol><p>在控制台输入<code>mvn -version</code>正确显示maven的版本代表配置正确</p><ol start="2"><li><p>修改maven目录下conf/setting.xml文件<br>添加本地仓库位置 , 例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/Users/Sookie/Documents/apache-maven-3.3.9/mavenLib<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在myeclipse/eclipse当中配置maven<br><img src="/images/Java/maven1.png" alt="Alt text"><br>点击Add选择到Maven的根目录即可<br><img src="/images/Java/maven2.png" alt="Alt text"><br>然后在User Setting里面设置setting.xml文件的根目录( 就是上一步当中修改的setting.xml文件 )</p></li></ol><h4 id="第一个Maven项目"><a href="#第一个Maven项目" class="headerlink" title="第一个Maven项目"></a>第一个Maven项目</h4><p>在myeclipse当中新建一个maven项目<br>结构如下<br><img src="/images/Java/maven3.png" alt="Alt text"><br><code>src/main/java</code>用于存放源代码<br><code>src/main/test</code>用于存放测试代码<br><code>target</code>目录用于存放编译 打包后的输出文件<br>这是maven项目的通用约定</p><p>如果要引入第三方jar包 , 需要编辑pom.xml文件</p><blockquote><p>这里在引入jar包的时候 , 如果本地仓库中没有 , 则会去maven官方的服务器上去下载<br>下载后保存到本地仓库<br>如果官方没有这个jar包 , 也可以自己放进仓库里</p></blockquote><p>这里尝试引入几个jar包<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>maven_demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello_maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mongo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mongo-java-driver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mongo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>morphia<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>观察本地仓库的目录结构就可以发现 , 从左到右依次是groupId  artifactId  version<br><img src="/images/Java/maven4.png" alt="Alt text"><br>如果要放入自己的jar包 , 按照这个结构去创建目录即可</p><p>引入以后 , 刷新项目 , 引入的jar包就会出现在这里<br><img src="/images/Java/maven5.png" alt="Alt text"><br>在代码中可以直接使用</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS布局(4)-grid</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%B8%83%E5%B1%80(4)-Grid/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%B8%83%E5%B1%80(4)-Grid/</url>
      <content type="html"><![CDATA[<p>Grid布局是网站设计的基础<br>是创建网格布局最强大和最简单的工具</p><h3 id="FlexBox与Grid"><a href="#FlexBox与Grid" class="headerlink" title="FlexBox与Grid"></a>FlexBox与Grid</h3><p>FlexBox是一维布局系统 , 适合做局部布局 , 比如导航栏组件<br>Grid是二维布局系统 , 通常用于整个页面的规划<br>二者从应用场景来说并不冲突<br>虽然FlexBox也可以用于大的页面布局 , 但是没有Grid强大和灵活<br>二者结合使用更加轻松<br><a id="more"></a></p><h3 id="应用指南"><a href="#应用指南" class="headerlink" title="应用指南"></a>应用指南</h3><h4 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h4><p>要把某个元素变成一个网格(grid) , 只需要把<code>display</code>属性设置为<code>grid</code>即可<br>DOM结构<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>CSS<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display </span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这里为了清晰看到效果,给子元素添加了一些样式,不过与grid无关 */</span></span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">3px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/前端杂烩/grid/grid1.png" alt="Alt text"><br>当然此时还没有什么特别的表现 , 只是6个div简单地堆叠在一起</p><h4 id="Columns与Rows"><a href="#Columns与Rows" class="headerlink" title="Columns与Rows"></a>Columns与Rows</h4><p>为了使其成为二维的网格容器 , 我们需要定义这个网格的<code>列</code>和<code>行</code><br>分别对应<code>grid-template-columns</code>和<code>grid-template-rows</code>属性<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display </span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">60px</span> <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">120px</span> <span class="number">60px</span> <span class="number">80px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>grid-template-columns</strong> 属性的值当中有几个数值 , 就代表有几列 , 每个数值对应每一列的宽度<br><strong>grid-template-rows</strong> 属性的值当中有几个数值 , 就代表有几行 , 每个数值对应每一行的高度</p><p>所以在上面的例子里面 , 是定义了一个3行×2列的网格</p><p>现在的效果是这样了<br><img src="/images/前端杂烩/grid/grid2.png" alt="Alt text"><br>当然 , grid容器中的子元素会依次填充每个网格<br>如果不够 , 那就留空<br><img src="/images/前端杂烩/grid/grid3.png" alt="Alt text"><br>如果多了 , 也会继续往后排 , 但是新的一行已经没有高度值可用 , 所以就是这个div的默认高度(根据div的内容而定)<br>但是仍然被第一列的宽度约束<br><img src="/images/前端杂烩/grid/grid4.png" alt="Alt text"></p><h4 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h4><p>与以往使用的<code>&lt;table&gt;</code>元素一样 , 我们常常需要某个单元格来横跨多列 , 或者纵跨多行<br>体现在grid当中 , 就是对子元素添加css属性进行控制了<br>但是需要首先了解grid布局当中的一个参照 , 就是网格线<br><img src="/images/前端杂烩/grid/grid5.png" alt="Alt text"><br>这里有4条纵向的网格线 , 也就是columns的网格线<br>以及3条横向的网格线 , 也就是rows的网格线</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item4"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在我们要让item1横跨3列 , 也就是从第一条纵向网格线 , 到第四条纵向网格线<br>那么需要对其定义css属性如下<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &gt; <span class="selector-class">.item1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/前端杂烩/grid/grid6.png" alt="Alt text"><br>这个元素实际占据了3个网格 , 把之后的元素都推到了下一行</p><blockquote><p>到这里grid布局比起传统的table元素 , 优势就体现出来了<br>grid本身虽是二维布局 , 但是内部的元素却是以一维方式去定义的 , 在网格当中顺序填充 , 在页面中表现为二维结构<br>而传统的table元素 , 则必须要在其中以二维的方式去定义tr和td<br>灵活性相比就差了很多</p></blockquote><p>我们还可以用更简洁的写法<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &gt; <span class="selector-class">.item1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="再复杂一些"><a href="#再复杂一些" class="headerlink" title="再复杂一些"></a>再复杂一些</h4><p>理解了子元素的控制是以网格线为参照之后<br>我们就可以实现出更加复杂的布局了<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display </span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">60px</span> <span class="number">40px</span> <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">120px</span> <span class="number">60px</span> <span class="number">80px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &gt; <span class="selector-class">.item1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &gt; <span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &gt; <span class="selector-class">.item4</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际效果如下<br><img src="/images/前端杂烩/grid/grid7.png" alt="Alt text"></p>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS布局(3)-Flex实践</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%B8%83%E5%B1%80(3)-Flex%E5%AE%9E%E8%B7%B5/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%B8%83%E5%B1%80(3)-Flex%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<p>熟悉flex布局方式以后 , 就会发现flex布局十分灵活<br>19.1当中提到的多列布局<br>使用flex都可以以十分简洁的代码搞定<br><a id="more"></a><br>DOM结构<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout_aside"</span>&gt;</span>侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout_main"</span>&gt;</span>主内容栏宽度自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout_main"</span>&gt;</span>主内容栏宽度自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout_aside"</span>&gt;</span>侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout_aside"</span>&gt;</span>左侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout_main"</span>&gt;</span>主内容栏宽度自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout_aside"</span>&gt;</span>右侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout_aside"</span>&gt;</span>第1个侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout_aside"</span>&gt;</span>第2个侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout_main"</span>&gt;</span>主内容栏宽度自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout_main"</span>&gt;</span>主内容栏宽度自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout_aside"</span>&gt;</span>第1个侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"layout_aside"</span>&gt;</span>第2个侧边栏宽度固定<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>css样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layout</span> &#123;</span><br><span class="line">  <span class="attribute">height </span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span> &gt; <span class="selector-class">.layout_aside</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span> &gt; <span class="selector-class">.layout_main</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>无论结构是什么样子 , 只要让main区域自动放大 , 侧边栏的宽度固定即可</p><hr><p>对于常见的 上 左下 右下 将整个窗口区域分为3部分 , 并且外部区域没有滚动条的布局 ( 通常右下作为主内容显示区 , 这部分可以有自己的纵向滚动条 )<br>使用flex实现起来也十分简单 , 不需要使用js获取可视区域的尺寸进行控制</p><p>DOM结构<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"top"</span>&gt;</span>我是顶部条<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"down"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>我是侧边栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>我是主面板<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>main是最外层的flex容器 , 其中包含top和down两个项目<br>down本身也是一个flex容器 , 其中包含left和content两个项目</p><p>CSS样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding </span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">height </span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> &gt; <span class="selector-class">.top</span>&#123;</span><br><span class="line">  <span class="attribute">height </span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> &gt; <span class="selector-class">.down</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> &gt; <span class="selector-class">.down</span> &gt; <span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> &gt; <span class="selector-class">.down</span> &gt; <span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS布局(2)-Flex</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%B8%83%E5%B1%80(2)-Flex/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%B8%83%E5%B1%80(2)-Flex/</url>
      <content type="html"><![CDATA[<p>Flex是<code>Flexible Box</code>的缩写，意为<code>弹性布局</code>，用来为盒状模型提供最大的灵活性。<br>目前，它已经得到了所有浏览器的支持<br>Flex布局将成为未来布局的首选方案<br><a id="more"></a><br>任何一个容器都可以指定为flex布局<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对于块元素*/</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display </span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对于行内元素*/</span></span><br><span class="line"><span class="selector-class">.inline-box</span> &#123;</span><br><span class="line">  <span class="attribute">display </span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了兼容性的需要 , 通常可以加上<code>display:-webkit-flex;</code></p><blockquote><p>设为Flex布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效</p></blockquote><h3 id="Flex容器的基本模型"><a href="#Flex容器的基本模型" class="headerlink" title="Flex容器的基本模型"></a>Flex容器的基本模型</h3><p>采用了flex布局的元素 , 可以称之为<code>Flex容器</code> , 它的子元素自动成为这个容器的成员 , 被称为<code>Flex项目</code><br><img src="/images/前端杂烩/flex/Flex容器.png" alt="Alt text"><br>容器默认存在两根轴：水平的<code>主轴（main axis）</code>和竖直的<code>交叉轴（cross axis）</code>。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h3 id="Flex容器的属性"><a href="#Flex容器的属性" class="headerlink" title="Flex容器的属性"></a>Flex容器的属性</h3><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>决定主轴的方向 , 也就是项目的排列方向</p><p><pre>row(默认) | row-reverse | column | column-reverse</pre><br><img src="/images/前端杂烩/flex/flex-direction.png" alt="flex-direction"></p><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>默认情况下 , 项目都排列在一条轴线上 , 该属性定义了当一条轴线排列不下的时候 , 如何换行</p><p><pre>nowrap(默认) | wrap | wrap-reverse</pre><br><img src="/images/前端杂烩/flex/flex-wrap.jpg" alt="flex-wrap"></p><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>这个属性是上面两个属性的简写形式 , 例如<br>flex-flow : column wrap , 就相当于 flex-direction:column;flex-wrap:wrap;</p><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>项目在主轴上的对其方式</p><p><pre>flex-start(默认) | flex-end | center | space-between | space-around</pre><br>( 假设主轴为从左到右 ↓ )<br><img src="/images/前端杂烩/flex/justify-content.png" alt="justify-content"></p><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>定义项目在交叉轴上如何对齐</p><p><pre>flex-start | flex-end | center | baseline | stretch(默认)</pre><br><img src="/images/前端杂烩/flex/align-items.png" alt="align-items"></p><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>定义了多根轴线的对齐方式 , 如果项目只形成了一条轴线 , 那么该属性不起作用</p><p><pre>flex-start | flex-end | center | space-between | space-around | stretch(默认)</pre><br><img src="/images/前端杂烩/flex/align-content.png" alt="align-content"></p><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>定义项目的排列顺序 , 升序排列 , 默认值为0</p><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>定义项目的放大比例 , 默认为0 , 即为即使有剩余的空间 , 也不放大</p><blockquote><p>这个值定义的是不同项目之间的放大比值<br>比如共有3个项目 , 一个项目的flex-grow为2 , 其余的为1 , 如果有剩余可供放大的空间为400px , 那个flex-grow为2的项目将多占据200px , 其余2个各自多占据100px</p></blockquote><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>定义项目的缩小比例 , 默认为1 , 即空间不足时 , 该项目将被压缩<br>与flex-grow类似 , 这个属性也是不同项目之间的一个比例<br>如果定义为0 , 则不会被压缩 , 负值无效</p><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>定义了在分配多余空间之前 , 项目占据的主轴空间</p><p><pre> &lt;length&gt; | auto(默认)</pre><br>它可以设为像width height类似的值 , 比如100px , 项目将占据固定的主轴空间</p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>是flex-grow flex-shrink flex-basis的简写形式<br>默认 0 1 auto , 后两个值可选</p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>允许单个项目与其他项目在交叉轴上有不同的对齐方式<br>也就是Flex容器定义的align-items在该项目上不会生效 , 而会被这个项目自身的align-self覆盖</p><p><pre>auto(默认) | flex-start | flex-end | center | baseline | stretch</pre><br>默认值auto表示继承父元素的align-items属性 , 除了auto以外 , 可以取的值与align-items完全一致<br><img src="/images/前端杂烩/flex/align-self.png" alt="Alt text"></p>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS布局(1)</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%B8%83%E5%B1%80(1)/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/CSS%E5%B8%83%E5%B1%80(1)/</url>
      <content type="html"><![CDATA[<h4 id="常用的居中方法"><a href="#常用的居中方法" class="headerlink" title="常用的居中方法"></a>常用的居中方法</h4><ol><li><strong>水平居中</strong><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>对于子元素的不同情况 , 需要进行不同的处理<br><a id="more"></a></p><ul><li>行内元素 : 对父元素设置<code>text-align:center</code></li><li>定宽的块元素 : 对子元素设置<code>margin-left:auto</code>以及<code>margin-right:auto</code></li><li>不定宽的块元素 : 可以把子元素转化为行内元素 , 然后使用行内元素的方案 , 对子元素设置<code>display: inline</code> , 对父元素设置<code>text-align:center</code></li></ul><blockquote><p><strong>通用方案</strong><br> 使用flex布局 , 对父元素设置<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display </span>: flex;</span><br><span class="line">  <span class="attribute">justify-content </span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ol start="2"><li><strong>垂直居中</strong><br>垂直居中的情况通常是父元素的高度固定 , 以下是在此前提下实现的</li></ol><ul><li>子元素为块元素 : 设置子元素<code>position:absolute</code> , 然后<code>margin:auto</code></li><li>子元素为单行内联文本 : 父元素的<code>height</code>与<code>line-height</code>相同即可</li><li>子元素为多行内联文本 : 父元素<code>display:table-cell</code> , 再设置<code>vertical-align:middle</code><br>例如<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">height</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">width</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">display</span><span class="selector-pseudo">:table-cell</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">vertical-align</span><span class="selector-pseudo">:middle</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>通用方案</strong><br>使用flex布局 , 父元素<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><h4 id="单列布局"><a href="#单列布局" class="headerlink" title="单列布局"></a>单列布局</h4><p><img src="/images/前端杂烩/single_column.png" alt="single_column"><br>第一种布局方式DOM结构<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span>头部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span>尾部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>第二种布局方式DOM结构<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span>头部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout content"</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span>尾部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layout</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>:<span class="number">960px</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h4><p>可能有以下各种情况 , 当然如果更多列的话也是类似的<br><img src="/images/前端杂烩/many_columns.png" alt="many_columns"></p><h5 id="实现方式1-float-margin"><a href="#实现方式1-float-margin" class="headerlink" title="实现方式1 : float+margin"></a>实现方式1 : float+margin</h5><p>DOM结构<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sub"</span>&gt;</span>侧边栏1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"extra"</span>&gt;</span>侧边栏2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>内容区域<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>CSS样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sub</span>,<span class="selector-class">.extra</span>,<span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">height </span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sub</span> &#123;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">float </span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.extra</span> &#123;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float </span>: right;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际效果如下<br><img src="/images/前端杂烩/many_columns2.png" alt="many_columns2"></p><blockquote><p><strong>注意</strong> : DOM文档的书写顺序，先写两侧栏，再写主面板，更换后则侧栏会被挤到下一列<br>这种布局方式比较简单明了 , 缺点是渲染时首先渲染了侧边栏 , 而不是重要的内容区域</p></blockquote><h5 id="实现方式2-position-margin"><a href="#实现方式2-position-margin" class="headerlink" title="实现方式2 : position+margin"></a>实现方式2 : position+margin</h5><ol><li>对两个侧边栏分别设置宽度</li><li>将两个侧边栏设置为绝对定位 , 需要位于左侧的left值为0 , 位于右侧的right值为0</li><li>内容区域设置左外边距和右外边距<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sub</span>,<span class="selector-class">.extra</span>,<span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">height </span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sub</span>,<span class="selector-class">.extra</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top </span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sub</span> &#123;</span><br><span class="line">  <span class="attribute">left </span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.extra</span> &#123;</span><br><span class="line">  <span class="attribute">right </span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">backgroun-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>如果中间栏有最小宽度限制 , 或者其中包含有宽度的元素 , 那么当窗口宽度压缩到一定程度 , 中间栏与侧栏将会发生重叠</p></blockquote><h5 id="实现方式3-圣杯布局-float-负margin-padding-position"><a href="#实现方式3-圣杯布局-float-负margin-padding-position" class="headerlink" title="实现方式3 : 圣杯布局(float + 负margin + padding + position)"></a>实现方式3 : 圣杯布局(float + 负margin + padding + position)</h5><p>DOM结构<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>内容区域<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sub"</span>&gt;</span>侧边栏1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"extra"</span>&gt;</span>侧边栏2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>布局步骤:</p><ol><li>三者都设置向左浮动。</li><li>设置main宽度为100%，设置两侧栏的宽度。</li><li>设置 负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。</li><li>设置main的padding值给左右两个子面板留出空间。</li><li>设置两个子面板为相对定位，sub的left值为负的sub宽度，extra的right值为负的extra宽度。</li></ol><p>CSS样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sub</span> , <span class="selector-class">.extra</span>, <span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">float </span>:left;</span><br><span class="line">  <span class="attribute">height </span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sub</span> &#123;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left </span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.extra</span> &#123;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content</span> &#123;</span><br><span class="line">  <span class="attribute">padding </span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这种布局方式仍然存在一个缺陷 : 当main的实际宽度比侧边栏的宽度小的时候 , 布局就会乱掉</p></blockquote><h5 id="实现方式4-双飞翼布局-float-负margin-margin"><a href="#实现方式4-双飞翼布局-float-负margin-margin" class="headerlink" title="实现方式4 : 双飞翼布局(float + 负margin + margin)"></a>实现方式4 : 双飞翼布局(float + 负margin + margin)</h5><p>双飞翼布局实际上是在圣杯布局的基础上做了改进 , 在main部分的外层套上了一层div<br>并设置margin,由于两侧栏的负边距都是相对于main-wrap而言，main的margin值变化便不会影响两个侧栏，因此省掉了对两侧栏设置相对布局的步骤<br>DOM结构<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main-wrap"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>内容区域<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sub"</span>&gt;</span>侧边栏1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"extra"</span>&gt;</span>侧边栏2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>布局步骤</p><ol><li>三者都设置向左浮动。</li><li>设置main-wrap宽度为100%，设置两个侧栏的宽度。</li><li>设置 负边距，sub设置负左边距为100%，extra设置负左边距为负的自身宽度。</li><li>设置main的margin值给左右两个子面板留出空间。</li></ol><p>CSS样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main-wrap</span>, <span class="selector-class">.sub</span>, <span class="selector-class">.extra</span> &#123;</span><br><span class="line">  <span class="attribute">float </span>: left;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sub</span> &#123;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.extra</span> &#123;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap的工作原理</title>
      <link href="/Java/HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/Java/HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>为了验证HashMap的工作原理 , 先创建一个JavaBean实体类<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">long</span> population;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Country</span><span class="params">(String name, <span class="keyword">long</span> population)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.population = population;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.name.length() % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">95</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Country other = (Country) obj;</span><br><span class="line">    <span class="keyword">if</span> (name.equalsIgnoreCase(other.name))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是这个类重写了hashCode和equals方法<br>hashCode方法在name字符串的长度为奇数和偶数的时候会返回不同的常数值<br>equals方法则是忽略大小写比较name属性是否相同</p><p>调试执行以下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Country india = <span class="keyword">new</span> Country(<span class="string">"India"</span>, <span class="number">1000</span>);</span><br><span class="line">  Country japan = <span class="keyword">new</span> Country(<span class="string">"Japan"</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">  Country france = <span class="keyword">new</span> Country(<span class="string">"France"</span>, <span class="number">2000</span>);</span><br><span class="line">  Country russia = <span class="keyword">new</span> Country(<span class="string">"Russia"</span>, <span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">  HashMap&lt;Country, String&gt; countryCapitalMap = <span class="keyword">new</span> HashMap&lt;Country, String&gt;();</span><br><span class="line">  countryCapitalMap.put(india, <span class="string">"Delhi"</span>);</span><br><span class="line">  countryCapitalMap.put(japan, <span class="string">"Tokyo"</span>);</span><br><span class="line">  countryCapitalMap.put(france, <span class="string">"Paris"</span>);</span><br><span class="line">  countryCapitalMap.put(russia, <span class="string">"Moscow"</span>);</span><br><span class="line"></span><br><span class="line">  Iterator&lt;Country&gt; countryCapitalIter = countryCapitalMap.keySet().iterator();</span><br><span class="line">  <span class="keyword">while</span> (countryCapitalIter.hasNext()) &#123;</span><br><span class="line">    Country countryObj = countryCapitalIter.next();</span><br><span class="line">    String capital = countryCapitalMap.get(countryObj);</span><br><span class="line">    System.out.println(countryObj.getName() + <span class="string">"----"</span> + capital);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/Java/HashMap1.png" alt="HashMap1"></p><p>发现这个Map当中存在4个Entry ( 一组键值对构成的对象 )<br>但是在table这个存放Entry的数组当中只有两个位置有数据<br>这两个位置上又分别使用链表的结构存放了两个Entry<br><img src="/images/Java/HashMap2.png" alt="HashMap2"></p><p>由上述现象可以总结出<br>HashMap是一个由数组和链表结合构成的复合型的数据结构<br><strong>某一个Entry存放在哪个数组索引上 , 是由该键的hashCode方法的返回值决定的</strong><br>如果两个键存在相同的哈希值( 也称为哈希冲突 ) , 那么将保存在同一个索引上面 , 以链表的形式存在<br>当向这个链表末尾追加元素时 , 需要对这个链表进行迭代<br><strong>在这个迭代过程中 , 会使用键的equals方法进行比较 , 如果在某个链表节点上获得了true的结果</strong><br><strong>那么新的Entry会替换掉这个原有的链表节点</strong><br><strong>如果遍历该链表后没有发现重复的元素 , 那么该Entry将追加到该链表末尾</strong></p><p>所以当向Map当中存放数据的时候 , “键”的对象最好是一个不可变的对象<br>但是对象本身是否可变并不是问题的关键<br>而是该对象是否会产生稳定的哈希值 ( 也就是hashCode方法的返回值 )<br>如果某些因素导致了哈希值的变化 , 虽然该元素仍然在Map当中存在<br>但是已经无法用get方法拿到其对应的值</p><p>总结</p><ul><li>HashMap有一个叫做Entry的内部类，它用来存储key-value对。</li><li>上面的Entry对象是存储在一个叫做table的Entry数组中。</li><li>table的索引在逻辑上叫做“桶”(bucket)，它存储了链表的第一个元素。</li><li>key的hashcode()方法用来找到Entry对象所在的桶。</li><li>如果两个key有相同的hash值，他们会被放在table数组的同一个桶里面。</li><li>key的equals()方法用来确保key的唯一性。</li><li>value对象的equals()和hashcode()方法根本一点用也没有。</li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>viewport</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/viewport/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/viewport/</url>
      <content type="html"><![CDATA[<p>在移动设备上的页面开发 , 首先需要搞清楚的就是<code>viewport</code> , 这是适配和响应各种不同分辨率的移动设备的前提条件</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>通俗地讲 , 移动设备上的viewport是指设备的屏幕上能用来显示网页的那块区域<br><a id="more"></a></p><blockquote><p>关于<strong>像素(px)</strong><br>这是css当中常见的定义像素值的单位<br>但是这个值并不能完全等同于设备的物理像素<br>因为页面是可以被缩放的 , 如果缩放到2倍<br>那么1px在页面上就会占用2个物理像素的距离</p></blockquote><h4 id="移动设备的3个viewport"><a href="#移动设备的3个viewport" class="headerlink" title="移动设备的3个viewport"></a>移动设备的3个viewport</h4><h5 id="layout-viewport"><a href="#layout-viewport" class="headerlink" title="layout viewport"></a>layout viewport</h5><p><img src="/images/前端杂烩/viewport1.png" alt="layout viewport"><br>它的宽度是大于浏览器可视区域的宽度的<br>宽度值可以通过<code>document.documentElement.clientWidth</code>来获取<br>还需要一个viewport来代表浏览器可视区域的大小</p><h5 id="visual-viewport"><a href="#visual-viewport" class="headerlink" title="visual viewport"></a>visual viewport</h5><p><img src="/images/前端杂烩/viewport2.png" alt="visual viewport"><br>它的宽度可以通过<code>window.innerWidth</code>来获取</p><p>现在已经有两个viewport了 , 但是浏览器还觉得不够 , 因为越来越多的网站都会为移动设备进行单独的设计 , 所以还必须要有一个能完美适配移动设备的viewport</p><blockquote><p>完美适配指的是 : </p><ol><li>不需要用户缩放和横向滚动条就能正常地查看网页的所有内容</li><li>显示的文字大小合适 , 不会因为在高密度像素的屏幕里显示得太小而无法看清 . 当然不只是文字 , 其他元素的大小也是同样的道理</li></ol></blockquote><h5 id="ideal-viewport"><a href="#ideal-viewport" class="headerlink" title="ideal viewport"></a>ideal viewport</h5><p>这是移动设备的理想viewport , 它并没有一个固定的尺寸 , 不同的设备有不同的尺寸<br>例如所有iphone设备的ideal viewport的宽度都是320px , 无论它的屏幕宽度是320还是640<br>安卓设备则比较复杂 , 有很多不同的值<br>页面中元素大小如果根据ideal viewport来适配 , 则不会出现在像素密度太高的屏幕上 , 元素显示太小的问题了</p><h4 id="利用meta标签对viewport进行控制"><a href="#利用meta标签对viewport进行控制" class="headerlink" title="利用meta标签对viewport进行控制"></a>利用meta标签对viewport进行控制</h4><p>移动设备默认的viewport是layout viewport , 但是在进行移动设备网站的开发时 , 我们需要的是ideal viewport<br>通常需要在head标签当中添加<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>属性说明 : </p><ul><li><code>width</code> - 控制viewport宽度 , 可以指定一个值 , 或者特殊的值 , <strong>device-width</strong>为设备的宽度</li><li><code>height</code> - 与width相对应 , 指定高度 , 这个属性并不重要 , 很少使用</li><li><code>initial-scale</code> - 初始缩放比例 , 比如1.0</li><li><code>maximum-scale</code> - 允许用户缩放到的最大比例</li><li><code>minimum-scale</code> - 允许用户缩放到的最小比例</li><li><code>user-scalable</code> - 用户是否可以手动缩放 , 值为yes或者no</li></ul><p>要得到ideal viewport只需要把width设置为<strong>device-width</strong>即可<br>需要说明的是 , 有关缩放的属性都是相对于ideal viewport进行缩放的<br>所以如果只写<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>也可以达到ideal viewport的效果</p><hr><h4 id="视区的相关单位"><a href="#视区的相关单位" class="headerlink" title="视区的相关单位"></a>视区的相关单位</h4><ul><li><code>vw</code> - 相对于视区的宽度 , 视区总的宽度为100vw</li><li><code>vh</code> - 相对于视区的高度 , 视区总的高度为100vh</li><li><code>vmin</code> - 相对于视区的宽度与高度当中较小的一个</li><li><code>vmax</code> - 相对于视区的宽度与高度当中较大的一个</li></ul><p>比如某种情况下视区的宽度为1000px<br>div的width为2vw , 那么这个div的实际显示宽度就是20px<br>高度同理</p><h5 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h5><ol><li>弹性布局</li></ol><p>实践当中 , 如果我们需要把两个元素横向并排布局<br>设置浮动之后 , 分别指定宽度为25%与75%<br>与指定宽度为 25vw和75vw<br>相比并没有什么优势 , 实际的作用也是一样的</p><p>在布局方面要发挥更大的作用 , 需要结合一个CSS的函数<code>calc</code><br>就是calculate的缩写<br>这个函数的作用是<strong>执行表达式的计算</strong></p><p>如果不使用这个函数 , 我们通常是需要使用一些预处理工具 , 比如sass , 才能在css当中编写表达式<br>让预处理工具在打包css代码的过程中完成这个计算<br>但是这样终究比较局限 , 因为视区的宽度高度是页面实际渲染的时候才确定的<br>如果涉及到视区的计算 , 则无法完成</p><p>回到最初的问题 , 按照宽度的百分比横向排列两个div<br>直接用百分比当然是可以的 , 但是如果这个元素有 <strong>border margin padding</strong>当中的任意一个 , 右边的div就会被挤到下一行<br>( 如果是单个元素宽度100%的话 , 盒子会被撑破 , 超出父元素的宽度 )</p><p>这时候我们就可以用calc函数配合vw来解决这个问题<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>,<span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">height </span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">border </span>: <span class="number">3px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">background </span>: blue;</span><br><span class="line">  <span class="attribute">width </span>: <span class="built_in">calc</span>(25vw - 6px);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">background </span>: pink;</span><br><span class="line">  <span class="attribute">width </span>: <span class="built_in">calc</span>(75vw - 6px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>出于兼容性的考虑 , 最好给calc加上<code>-webkit-</code>和<code>-moz-</code>的前缀</p></blockquote><ol start="2"><li>弹性字体</li></ol><p>在响应式布局中 , 字体的大小最好是能跟随视区的大小进行自动调整<br>才能达到比较好的体验<br>可以采用如下方式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">calc</span>(1vw + 1vh + .5vmin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>:root</code>伪类匹配DOM文档树的根元素 </p><blockquote><p><strong>补充说明</strong><br>使用视区的相关单位的值对应的属性 , 不会跟随页面的缩放变化<br>比如第二个例子当中的字号<br>在放大页面的时候 , 文字的大小是不会改变的</p></blockquote>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>响应式布局</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%83%A9/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>媒体查询可以使用<code>@media</code>在css样式当中进行断点 , 让指定的css样式按照要求进行生效<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> (max-width:<span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">color </span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面写在媒体查询当中的css代码 , 在页面视窗宽度小于768px时生效<br><a id="more"></a></p><h5 id="根据媒体类型进行断点"><a href="#根据媒体类型进行断点" class="headerlink" title="根据媒体类型进行断点"></a>根据媒体类型进行断点</h5><ul><li>all 所有设备</li><li>print 用于打印机和打印预览</li><li>screen 用于电脑屏幕 平板电脑 智能手机等</li><li>speech 屏幕阅读器等发声设备</li></ul><h5 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h5><p>使用逻辑操作符可以构建复杂的媒体查询 , 有<code>and</code> , <code>not</code> , <code>only</code>等<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> (min-width: <span class="number">700px</span>) and (orientation: landscape) &#123;</span><br><span class="line"><span class="comment">/* 宽度大于700并且横屏的时候应用该效果 */</span></span><br><span class="line">  <span class="selector-class">.box1</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只用于屏幕显示( 打印输出不生效 )<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (max-width:<span class="number">1150px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">div</span>&#123;<span class="attribute">border</span>:solid <span class="number">1px</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="按需加载CSS"><a href="#按需加载CSS" class="headerlink" title="按需加载CSS"></a>按需加载CSS</h5><p>其实与上面的媒体查询作用是一样的 , 只不过在页面引入css时添加媒体查询条件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"base.css"</span> <span class="attr">media</span>=<span class="string">"(max-width:500px)"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>浏览器在执行渲染的时候 , 实际和媒体查询是一样的 , 相当于给整个文件当中的css包装了一层媒体查询</p><h4 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h4><p>这是一个应用于长度的单位 , 所有可以用长度值来声明的CSS样式 , 都可以以它当做单位 , 比如width , font-size等等</p><p>这个单位代表的是相对于<code>html</code>的<code>font-size</code>的值<br>比如<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="comment">/* 为了防止元素继承html的字号,干扰全局样式,所以重置为默认 */</span></span><br><span class="line">  <span class="attribute">font-size</span>:initial;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">width </span>: <span class="number">0.5rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么box2的实际宽度就是  0.5 × 100px = 50px<br>基于这种机制 , 我们就可以编写页面<code>resize事件</code>的回调函数<br>在函数当中获取当前视窗的宽度与高度 , 去动态改变根元素(html节点)的font-size的值<br>从而让页面中的元素适应视窗大小的变化<br>( 假定设计稿给出的宽度是750px )<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> docEl = doc.documentElement,</span><br><span class="line">    resizeEvt = <span class="string">'orientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">'orientationchange'</span> : <span class="string">'resize'</span>,</span><br><span class="line">    recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> clientWidth = docEl.clientWidth;</span><br><span class="line">      <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span><br><span class="line">      docEl.style.fontSize = <span class="number">100</span> * (clientWidth / <span class="number">750</span>) + <span class="string">'px'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;</span><br><span class="line">       win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);</span><br><span class="line">       doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, recalc, <span class="literal">false</span>);</span><br><span class="line">&#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></p><h4 id="设置viewport的width"><a href="#设置viewport的width" class="headerlink" title="设置viewport的width"></a>设置viewport的width</h4><p>这种方案 , 就是直接指定viewport的width大小<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=750"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>但是使用了这种方案之后<br>因为已经将宽度定死了 , 所以针对宽度执行的媒体查询就会失效<br>存在很大的弊端<br>而使用REM方案是可以使用媒体查询的</p>]]></content>
      
      <categories>
          
          <category> 前端杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
